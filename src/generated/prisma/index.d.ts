
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Dormitory_Card
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type Dormitory_Card = $Result.DefaultSelection<Prisma.$Dormitory_CardPayload>
/**
 * Model Email
 * 
 */
export type Email = $Result.DefaultSelection<Prisma.$EmailPayload>
/**
 * Model Employee_Card
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type Employee_Card = $Result.DefaultSelection<Prisma.$Employee_CardPayload>
/**
 * Model Identity_Card
 * 
 */
export type Identity_Card = $Result.DefaultSelection<Prisma.$Identity_CardPayload>
/**
 * Model People
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type People = $Result.DefaultSelection<Prisma.$PeoplePayload>
/**
 * Model PhoneNumber
 * 
 */
export type PhoneNumber = $Result.DefaultSelection<Prisma.$PhoneNumberPayload>
/**
 * Model building
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type building = $Result.DefaultSelection<Prisma.$buildingPayload>
/**
 * Model building_equipment
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type building_equipment = $Result.DefaultSelection<Prisma.$building_equipmentPayload>
/**
 * Model disciplinaryAction
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type disciplinaryAction = $Result.DefaultSelection<Prisma.$disciplinaryActionPayload>
/**
 * Model disciplineStaff
 * 
 */
export type disciplineStaff = $Result.DefaultSelection<Prisma.$disciplineStaffPayload>
/**
 * Model employee
 * 
 */
export type employee = $Result.DefaultSelection<Prisma.$employeePayload>
/**
 * Model health_room
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type health_room = $Result.DefaultSelection<Prisma.$health_roomPayload>
/**
 * Model large_equipment
 * 
 */
export type large_equipment = $Result.DefaultSelection<Prisma.$large_equipmentPayload>
/**
 * Model living_room
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type living_room = $Result.DefaultSelection<Prisma.$living_roomPayload>
/**
 * Model management_room
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type management_room = $Result.DefaultSelection<Prisma.$management_roomPayload>
/**
 * Model managerDorm
 * 
 */
export type managerDorm = $Result.DefaultSelection<Prisma.$managerDormPayload>
/**
 * Model manager_degree
 * 
 */
export type manager_degree = $Result.DefaultSelection<Prisma.$manager_degreePayload>
/**
 * Model manager_employee
 * 
 */
export type manager_employee = $Result.DefaultSelection<Prisma.$manager_employeePayload>
/**
 * Model medical_degree
 * 
 */
export type medical_degree = $Result.DefaultSelection<Prisma.$medical_degreePayload>
/**
 * Model medical_employee
 * 
 */
export type medical_employee = $Result.DefaultSelection<Prisma.$medical_employeePayload>
/**
 * Model other_employee
 * 
 */
export type other_employee = $Result.DefaultSelection<Prisma.$other_employeePayload>
/**
 * Model other_employee_time_work
 * 
 */
export type other_employee_time_work = $Result.DefaultSelection<Prisma.$other_employee_time_workPayload>
/**
 * Model other_room
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type other_room = $Result.DefaultSelection<Prisma.$other_roomPayload>
/**
 * Model relative
 * 
 */
export type relative = $Result.DefaultSelection<Prisma.$relativePayload>
/**
 * Model room
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type room = $Result.DefaultSelection<Prisma.$roomPayload>
/**
 * Model student
 * 
 */
export type student = $Result.DefaultSelection<Prisma.$studentPayload>
/**
 * Model studentDiscipline
 * 
 */
export type studentDiscipline = $Result.DefaultSelection<Prisma.$studentDisciplinePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const other_employee_time_work_date_work: {
  monday: 'monday',
  tuesday: 'tuesday',
  wednesday: 'wednesday',
  thursday: 'thursday',
  friday: 'friday',
  saturday: 'saturday',
  sunday: 'sunday',
  other: 'other'
};

export type other_employee_time_work_date_work = (typeof other_employee_time_work_date_work)[keyof typeof other_employee_time_work_date_work]


export const room_room_status: {
  Available: 'Available',
  Occupied: 'Occupied',
  Under_Maintenance: 'Under_Maintenance'
};

export type room_room_status = (typeof room_room_status)[keyof typeof room_room_status]


export const large_equipment_equipment_status: {
  Working: 'Working',
  Damaged: 'Damaged',
  Under_Repair: 'Under_Repair'
};

export type large_equipment_equipment_status = (typeof large_equipment_equipment_status)[keyof typeof large_equipment_equipment_status]


export const health_room_equipment_status: {
  Good: 'Good',
  Under_Repair: 'Under_Repair',
  Not_Available: 'Not_Available'
};

export type health_room_equipment_status = (typeof health_room_equipment_status)[keyof typeof health_room_equipment_status]

}

export type other_employee_time_work_date_work = $Enums.other_employee_time_work_date_work

export const other_employee_time_work_date_work: typeof $Enums.other_employee_time_work_date_work

export type room_room_status = $Enums.room_room_status

export const room_room_status: typeof $Enums.room_room_status

export type large_equipment_equipment_status = $Enums.large_equipment_equipment_status

export const large_equipment_equipment_status: typeof $Enums.large_equipment_equipment_status

export type health_room_equipment_status = $Enums.health_room_equipment_status

export const health_room_equipment_status: typeof $Enums.health_room_equipment_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Addresses
 * const addresses = await prisma.address.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dormitory_Card`: Exposes CRUD operations for the **Dormitory_Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dormitory_Cards
    * const dormitory_Cards = await prisma.dormitory_Card.findMany()
    * ```
    */
  get dormitory_Card(): Prisma.Dormitory_CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **Email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.EmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee_Card`: Exposes CRUD operations for the **Employee_Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employee_Cards
    * const employee_Cards = await prisma.employee_Card.findMany()
    * ```
    */
  get employee_Card(): Prisma.Employee_CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.identity_Card`: Exposes CRUD operations for the **Identity_Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Identity_Cards
    * const identity_Cards = await prisma.identity_Card.findMany()
    * ```
    */
  get identity_Card(): Prisma.Identity_CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.people`: Exposes CRUD operations for the **People** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.people.findMany()
    * ```
    */
  get people(): Prisma.PeopleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phoneNumber`: Exposes CRUD operations for the **PhoneNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhoneNumbers
    * const phoneNumbers = await prisma.phoneNumber.findMany()
    * ```
    */
  get phoneNumber(): Prisma.PhoneNumberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.building`: Exposes CRUD operations for the **building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.buildingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.building_equipment`: Exposes CRUD operations for the **building_equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Building_equipments
    * const building_equipments = await prisma.building_equipment.findMany()
    * ```
    */
  get building_equipment(): Prisma.building_equipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disciplinaryAction`: Exposes CRUD operations for the **disciplinaryAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisciplinaryActions
    * const disciplinaryActions = await prisma.disciplinaryAction.findMany()
    * ```
    */
  get disciplinaryAction(): Prisma.disciplinaryActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disciplineStaff`: Exposes CRUD operations for the **disciplineStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisciplineStaffs
    * const disciplineStaffs = await prisma.disciplineStaff.findMany()
    * ```
    */
  get disciplineStaff(): Prisma.disciplineStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.health_room`: Exposes CRUD operations for the **health_room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Health_rooms
    * const health_rooms = await prisma.health_room.findMany()
    * ```
    */
  get health_room(): Prisma.health_roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.large_equipment`: Exposes CRUD operations for the **large_equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Large_equipments
    * const large_equipments = await prisma.large_equipment.findMany()
    * ```
    */
  get large_equipment(): Prisma.large_equipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.living_room`: Exposes CRUD operations for the **living_room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Living_rooms
    * const living_rooms = await prisma.living_room.findMany()
    * ```
    */
  get living_room(): Prisma.living_roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.management_room`: Exposes CRUD operations for the **management_room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Management_rooms
    * const management_rooms = await prisma.management_room.findMany()
    * ```
    */
  get management_room(): Prisma.management_roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.managerDorm`: Exposes CRUD operations for the **managerDorm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManagerDorms
    * const managerDorms = await prisma.managerDorm.findMany()
    * ```
    */
  get managerDorm(): Prisma.managerDormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager_degree`: Exposes CRUD operations for the **manager_degree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manager_degrees
    * const manager_degrees = await prisma.manager_degree.findMany()
    * ```
    */
  get manager_degree(): Prisma.manager_degreeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager_employee`: Exposes CRUD operations for the **manager_employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manager_employees
    * const manager_employees = await prisma.manager_employee.findMany()
    * ```
    */
  get manager_employee(): Prisma.manager_employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medical_degree`: Exposes CRUD operations for the **medical_degree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medical_degrees
    * const medical_degrees = await prisma.medical_degree.findMany()
    * ```
    */
  get medical_degree(): Prisma.medical_degreeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medical_employee`: Exposes CRUD operations for the **medical_employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medical_employees
    * const medical_employees = await prisma.medical_employee.findMany()
    * ```
    */
  get medical_employee(): Prisma.medical_employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.other_employee`: Exposes CRUD operations for the **other_employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Other_employees
    * const other_employees = await prisma.other_employee.findMany()
    * ```
    */
  get other_employee(): Prisma.other_employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.other_employee_time_work`: Exposes CRUD operations for the **other_employee_time_work** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Other_employee_time_works
    * const other_employee_time_works = await prisma.other_employee_time_work.findMany()
    * ```
    */
  get other_employee_time_work(): Prisma.other_employee_time_workDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.other_room`: Exposes CRUD operations for the **other_room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Other_rooms
    * const other_rooms = await prisma.other_room.findMany()
    * ```
    */
  get other_room(): Prisma.other_roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relative`: Exposes CRUD operations for the **relative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relatives
    * const relatives = await prisma.relative.findMany()
    * ```
    */
  get relative(): Prisma.relativeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentDiscipline`: Exposes CRUD operations for the **studentDiscipline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentDisciplines
    * const studentDisciplines = await prisma.studentDiscipline.findMany()
    * ```
    */
  get studentDiscipline(): Prisma.studentDisciplineDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Address: 'Address',
    Dormitory_Card: 'Dormitory_Card',
    Email: 'Email',
    Employee_Card: 'Employee_Card',
    Identity_Card: 'Identity_Card',
    People: 'People',
    PhoneNumber: 'PhoneNumber',
    building: 'building',
    building_equipment: 'building_equipment',
    disciplinaryAction: 'disciplinaryAction',
    disciplineStaff: 'disciplineStaff',
    employee: 'employee',
    health_room: 'health_room',
    large_equipment: 'large_equipment',
    living_room: 'living_room',
    management_room: 'management_room',
    managerDorm: 'managerDorm',
    manager_degree: 'manager_degree',
    manager_employee: 'manager_employee',
    medical_degree: 'medical_degree',
    medical_employee: 'medical_employee',
    other_employee: 'other_employee',
    other_employee_time_work: 'other_employee_time_work',
    other_room: 'other_room',
    relative: 'relative',
    room: 'room',
    student: 'student',
    studentDiscipline: 'studentDiscipline'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "address" | "dormitory_Card" | "email" | "employee_Card" | "identity_Card" | "people" | "phoneNumber" | "building" | "building_equipment" | "disciplinaryAction" | "disciplineStaff" | "employee" | "health_room" | "large_equipment" | "living_room" | "management_room" | "managerDorm" | "manager_degree" | "manager_employee" | "medical_degree" | "medical_employee" | "other_employee" | "other_employee_time_work" | "other_room" | "relative" | "room" | "student" | "studentDiscipline"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Dormitory_Card: {
        payload: Prisma.$Dormitory_CardPayload<ExtArgs>
        fields: Prisma.Dormitory_CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Dormitory_CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Dormitory_CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload>
          }
          findFirst: {
            args: Prisma.Dormitory_CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Dormitory_CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload>
          }
          findMany: {
            args: Prisma.Dormitory_CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload>[]
          }
          create: {
            args: Prisma.Dormitory_CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload>
          }
          createMany: {
            args: Prisma.Dormitory_CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Dormitory_CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload>
          }
          update: {
            args: Prisma.Dormitory_CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload>
          }
          deleteMany: {
            args: Prisma.Dormitory_CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Dormitory_CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Dormitory_CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dormitory_CardPayload>
          }
          aggregate: {
            args: Prisma.Dormitory_CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDormitory_Card>
          }
          groupBy: {
            args: Prisma.Dormitory_CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dormitory_CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.Dormitory_CardCountArgs<ExtArgs>
            result: $Utils.Optional<Dormitory_CardCountAggregateOutputType> | number
          }
        }
      }
      Email: {
        payload: Prisma.$EmailPayload<ExtArgs>
        fields: Prisma.EmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findFirst: {
            args: Prisma.EmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findMany: {
            args: Prisma.EmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          create: {
            args: Prisma.EmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          createMany: {
            args: Prisma.EmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          update: {
            args: Prisma.EmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          deleteMany: {
            args: Prisma.EmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.EmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      Employee_Card: {
        payload: Prisma.$Employee_CardPayload<ExtArgs>
        fields: Prisma.Employee_CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Employee_CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Employee_CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload>
          }
          findFirst: {
            args: Prisma.Employee_CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Employee_CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload>
          }
          findMany: {
            args: Prisma.Employee_CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload>[]
          }
          create: {
            args: Prisma.Employee_CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload>
          }
          createMany: {
            args: Prisma.Employee_CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Employee_CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload>
          }
          update: {
            args: Prisma.Employee_CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload>
          }
          deleteMany: {
            args: Prisma.Employee_CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Employee_CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Employee_CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Employee_CardPayload>
          }
          aggregate: {
            args: Prisma.Employee_CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee_Card>
          }
          groupBy: {
            args: Prisma.Employee_CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<Employee_CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.Employee_CardCountArgs<ExtArgs>
            result: $Utils.Optional<Employee_CardCountAggregateOutputType> | number
          }
        }
      }
      Identity_Card: {
        payload: Prisma.$Identity_CardPayload<ExtArgs>
        fields: Prisma.Identity_CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Identity_CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Identity_CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload>
          }
          findFirst: {
            args: Prisma.Identity_CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Identity_CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload>
          }
          findMany: {
            args: Prisma.Identity_CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload>[]
          }
          create: {
            args: Prisma.Identity_CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload>
          }
          createMany: {
            args: Prisma.Identity_CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Identity_CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload>
          }
          update: {
            args: Prisma.Identity_CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload>
          }
          deleteMany: {
            args: Prisma.Identity_CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Identity_CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Identity_CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Identity_CardPayload>
          }
          aggregate: {
            args: Prisma.Identity_CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentity_Card>
          }
          groupBy: {
            args: Prisma.Identity_CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<Identity_CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.Identity_CardCountArgs<ExtArgs>
            result: $Utils.Optional<Identity_CardCountAggregateOutputType> | number
          }
        }
      }
      People: {
        payload: Prisma.$PeoplePayload<ExtArgs>
        fields: Prisma.PeopleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeopleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeopleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload>
          }
          findFirst: {
            args: Prisma.PeopleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeopleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload>
          }
          findMany: {
            args: Prisma.PeopleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload>[]
          }
          create: {
            args: Prisma.PeopleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload>
          }
          createMany: {
            args: Prisma.PeopleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PeopleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload>
          }
          update: {
            args: Prisma.PeopleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload>
          }
          deleteMany: {
            args: Prisma.PeopleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PeopleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PeopleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeoplePayload>
          }
          aggregate: {
            args: Prisma.PeopleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeople>
          }
          groupBy: {
            args: Prisma.PeopleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeopleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PeopleCountArgs<ExtArgs>
            result: $Utils.Optional<PeopleCountAggregateOutputType> | number
          }
        }
      }
      PhoneNumber: {
        payload: Prisma.$PhoneNumberPayload<ExtArgs>
        fields: Prisma.PhoneNumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhoneNumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneNumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload>
          }
          findFirst: {
            args: Prisma.PhoneNumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhoneNumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload>
          }
          findMany: {
            args: Prisma.PhoneNumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload>[]
          }
          create: {
            args: Prisma.PhoneNumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload>
          }
          createMany: {
            args: Prisma.PhoneNumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PhoneNumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload>
          }
          update: {
            args: Prisma.PhoneNumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload>
          }
          deleteMany: {
            args: Prisma.PhoneNumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhoneNumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhoneNumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneNumberPayload>
          }
          aggregate: {
            args: Prisma.PhoneNumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoneNumber>
          }
          groupBy: {
            args: Prisma.PhoneNumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhoneNumberGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhoneNumberCountArgs<ExtArgs>
            result: $Utils.Optional<PhoneNumberCountAggregateOutputType> | number
          }
        }
      }
      building: {
        payload: Prisma.$buildingPayload<ExtArgs>
        fields: Prisma.buildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.buildingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.buildingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          findFirst: {
            args: Prisma.buildingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.buildingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          findMany: {
            args: Prisma.buildingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>[]
          }
          create: {
            args: Prisma.buildingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          createMany: {
            args: Prisma.buildingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.buildingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          update: {
            args: Prisma.buildingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          deleteMany: {
            args: Prisma.buildingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.buildingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.buildingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.buildingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.buildingCountArgs<ExtArgs>
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      building_equipment: {
        payload: Prisma.$building_equipmentPayload<ExtArgs>
        fields: Prisma.building_equipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.building_equipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.building_equipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload>
          }
          findFirst: {
            args: Prisma.building_equipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.building_equipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload>
          }
          findMany: {
            args: Prisma.building_equipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload>[]
          }
          create: {
            args: Prisma.building_equipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload>
          }
          createMany: {
            args: Prisma.building_equipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.building_equipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload>
          }
          update: {
            args: Prisma.building_equipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload>
          }
          deleteMany: {
            args: Prisma.building_equipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.building_equipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.building_equipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$building_equipmentPayload>
          }
          aggregate: {
            args: Prisma.Building_equipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding_equipment>
          }
          groupBy: {
            args: Prisma.building_equipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Building_equipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.building_equipmentCountArgs<ExtArgs>
            result: $Utils.Optional<Building_equipmentCountAggregateOutputType> | number
          }
        }
      }
      disciplinaryAction: {
        payload: Prisma.$disciplinaryActionPayload<ExtArgs>
        fields: Prisma.disciplinaryActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.disciplinaryActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.disciplinaryActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload>
          }
          findFirst: {
            args: Prisma.disciplinaryActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.disciplinaryActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload>
          }
          findMany: {
            args: Prisma.disciplinaryActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload>[]
          }
          create: {
            args: Prisma.disciplinaryActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload>
          }
          createMany: {
            args: Prisma.disciplinaryActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.disciplinaryActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload>
          }
          update: {
            args: Prisma.disciplinaryActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload>
          }
          deleteMany: {
            args: Prisma.disciplinaryActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.disciplinaryActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.disciplinaryActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinaryActionPayload>
          }
          aggregate: {
            args: Prisma.DisciplinaryActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisciplinaryAction>
          }
          groupBy: {
            args: Prisma.disciplinaryActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisciplinaryActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.disciplinaryActionCountArgs<ExtArgs>
            result: $Utils.Optional<DisciplinaryActionCountAggregateOutputType> | number
          }
        }
      }
      disciplineStaff: {
        payload: Prisma.$disciplineStaffPayload<ExtArgs>
        fields: Prisma.disciplineStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.disciplineStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.disciplineStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload>
          }
          findFirst: {
            args: Prisma.disciplineStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.disciplineStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload>
          }
          findMany: {
            args: Prisma.disciplineStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload>[]
          }
          create: {
            args: Prisma.disciplineStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload>
          }
          createMany: {
            args: Prisma.disciplineStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.disciplineStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload>
          }
          update: {
            args: Prisma.disciplineStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload>
          }
          deleteMany: {
            args: Prisma.disciplineStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.disciplineStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.disciplineStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplineStaffPayload>
          }
          aggregate: {
            args: Prisma.DisciplineStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisciplineStaff>
          }
          groupBy: {
            args: Prisma.disciplineStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisciplineStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.disciplineStaffCountArgs<ExtArgs>
            result: $Utils.Optional<DisciplineStaffCountAggregateOutputType> | number
          }
        }
      }
      employee: {
        payload: Prisma.$employeePayload<ExtArgs>
        fields: Prisma.employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findFirst: {
            args: Prisma.employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findMany: {
            args: Prisma.employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          create: {
            args: Prisma.employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          createMany: {
            args: Prisma.employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          update: {
            args: Prisma.employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          deleteMany: {
            args: Prisma.employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      health_room: {
        payload: Prisma.$health_roomPayload<ExtArgs>
        fields: Prisma.health_roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.health_roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.health_roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload>
          }
          findFirst: {
            args: Prisma.health_roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.health_roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload>
          }
          findMany: {
            args: Prisma.health_roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload>[]
          }
          create: {
            args: Prisma.health_roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload>
          }
          createMany: {
            args: Prisma.health_roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.health_roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload>
          }
          update: {
            args: Prisma.health_roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload>
          }
          deleteMany: {
            args: Prisma.health_roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.health_roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.health_roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_roomPayload>
          }
          aggregate: {
            args: Prisma.Health_roomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealth_room>
          }
          groupBy: {
            args: Prisma.health_roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Health_roomGroupByOutputType>[]
          }
          count: {
            args: Prisma.health_roomCountArgs<ExtArgs>
            result: $Utils.Optional<Health_roomCountAggregateOutputType> | number
          }
        }
      }
      large_equipment: {
        payload: Prisma.$large_equipmentPayload<ExtArgs>
        fields: Prisma.large_equipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.large_equipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.large_equipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload>
          }
          findFirst: {
            args: Prisma.large_equipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.large_equipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload>
          }
          findMany: {
            args: Prisma.large_equipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload>[]
          }
          create: {
            args: Prisma.large_equipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload>
          }
          createMany: {
            args: Prisma.large_equipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.large_equipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload>
          }
          update: {
            args: Prisma.large_equipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload>
          }
          deleteMany: {
            args: Prisma.large_equipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.large_equipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.large_equipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$large_equipmentPayload>
          }
          aggregate: {
            args: Prisma.Large_equipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLarge_equipment>
          }
          groupBy: {
            args: Prisma.large_equipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Large_equipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.large_equipmentCountArgs<ExtArgs>
            result: $Utils.Optional<Large_equipmentCountAggregateOutputType> | number
          }
        }
      }
      living_room: {
        payload: Prisma.$living_roomPayload<ExtArgs>
        fields: Prisma.living_roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.living_roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.living_roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload>
          }
          findFirst: {
            args: Prisma.living_roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.living_roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload>
          }
          findMany: {
            args: Prisma.living_roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload>[]
          }
          create: {
            args: Prisma.living_roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload>
          }
          createMany: {
            args: Prisma.living_roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.living_roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload>
          }
          update: {
            args: Prisma.living_roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload>
          }
          deleteMany: {
            args: Prisma.living_roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.living_roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.living_roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$living_roomPayload>
          }
          aggregate: {
            args: Prisma.Living_roomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiving_room>
          }
          groupBy: {
            args: Prisma.living_roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Living_roomGroupByOutputType>[]
          }
          count: {
            args: Prisma.living_roomCountArgs<ExtArgs>
            result: $Utils.Optional<Living_roomCountAggregateOutputType> | number
          }
        }
      }
      management_room: {
        payload: Prisma.$management_roomPayload<ExtArgs>
        fields: Prisma.management_roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.management_roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.management_roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload>
          }
          findFirst: {
            args: Prisma.management_roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.management_roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload>
          }
          findMany: {
            args: Prisma.management_roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload>[]
          }
          create: {
            args: Prisma.management_roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload>
          }
          createMany: {
            args: Prisma.management_roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.management_roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload>
          }
          update: {
            args: Prisma.management_roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload>
          }
          deleteMany: {
            args: Prisma.management_roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.management_roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.management_roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$management_roomPayload>
          }
          aggregate: {
            args: Prisma.Management_roomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManagement_room>
          }
          groupBy: {
            args: Prisma.management_roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Management_roomGroupByOutputType>[]
          }
          count: {
            args: Prisma.management_roomCountArgs<ExtArgs>
            result: $Utils.Optional<Management_roomCountAggregateOutputType> | number
          }
        }
      }
      managerDorm: {
        payload: Prisma.$managerDormPayload<ExtArgs>
        fields: Prisma.managerDormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.managerDormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.managerDormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload>
          }
          findFirst: {
            args: Prisma.managerDormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.managerDormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload>
          }
          findMany: {
            args: Prisma.managerDormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload>[]
          }
          create: {
            args: Prisma.managerDormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload>
          }
          createMany: {
            args: Prisma.managerDormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.managerDormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload>
          }
          update: {
            args: Prisma.managerDormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload>
          }
          deleteMany: {
            args: Prisma.managerDormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.managerDormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.managerDormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$managerDormPayload>
          }
          aggregate: {
            args: Prisma.ManagerDormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManagerDorm>
          }
          groupBy: {
            args: Prisma.managerDormGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerDormGroupByOutputType>[]
          }
          count: {
            args: Prisma.managerDormCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerDormCountAggregateOutputType> | number
          }
        }
      }
      manager_degree: {
        payload: Prisma.$manager_degreePayload<ExtArgs>
        fields: Prisma.manager_degreeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.manager_degreeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.manager_degreeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload>
          }
          findFirst: {
            args: Prisma.manager_degreeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.manager_degreeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload>
          }
          findMany: {
            args: Prisma.manager_degreeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload>[]
          }
          create: {
            args: Prisma.manager_degreeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload>
          }
          createMany: {
            args: Prisma.manager_degreeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.manager_degreeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload>
          }
          update: {
            args: Prisma.manager_degreeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload>
          }
          deleteMany: {
            args: Prisma.manager_degreeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.manager_degreeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.manager_degreeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_degreePayload>
          }
          aggregate: {
            args: Prisma.Manager_degreeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager_degree>
          }
          groupBy: {
            args: Prisma.manager_degreeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Manager_degreeGroupByOutputType>[]
          }
          count: {
            args: Prisma.manager_degreeCountArgs<ExtArgs>
            result: $Utils.Optional<Manager_degreeCountAggregateOutputType> | number
          }
        }
      }
      manager_employee: {
        payload: Prisma.$manager_employeePayload<ExtArgs>
        fields: Prisma.manager_employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.manager_employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.manager_employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload>
          }
          findFirst: {
            args: Prisma.manager_employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.manager_employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload>
          }
          findMany: {
            args: Prisma.manager_employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload>[]
          }
          create: {
            args: Prisma.manager_employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload>
          }
          createMany: {
            args: Prisma.manager_employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.manager_employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload>
          }
          update: {
            args: Prisma.manager_employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload>
          }
          deleteMany: {
            args: Prisma.manager_employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.manager_employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.manager_employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manager_employeePayload>
          }
          aggregate: {
            args: Prisma.Manager_employeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager_employee>
          }
          groupBy: {
            args: Prisma.manager_employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Manager_employeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.manager_employeeCountArgs<ExtArgs>
            result: $Utils.Optional<Manager_employeeCountAggregateOutputType> | number
          }
        }
      }
      medical_degree: {
        payload: Prisma.$medical_degreePayload<ExtArgs>
        fields: Prisma.medical_degreeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medical_degreeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medical_degreeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload>
          }
          findFirst: {
            args: Prisma.medical_degreeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medical_degreeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload>
          }
          findMany: {
            args: Prisma.medical_degreeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload>[]
          }
          create: {
            args: Prisma.medical_degreeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload>
          }
          createMany: {
            args: Prisma.medical_degreeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.medical_degreeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload>
          }
          update: {
            args: Prisma.medical_degreeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload>
          }
          deleteMany: {
            args: Prisma.medical_degreeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medical_degreeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medical_degreeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_degreePayload>
          }
          aggregate: {
            args: Prisma.Medical_degreeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedical_degree>
          }
          groupBy: {
            args: Prisma.medical_degreeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Medical_degreeGroupByOutputType>[]
          }
          count: {
            args: Prisma.medical_degreeCountArgs<ExtArgs>
            result: $Utils.Optional<Medical_degreeCountAggregateOutputType> | number
          }
        }
      }
      medical_employee: {
        payload: Prisma.$medical_employeePayload<ExtArgs>
        fields: Prisma.medical_employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medical_employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medical_employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload>
          }
          findFirst: {
            args: Prisma.medical_employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medical_employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload>
          }
          findMany: {
            args: Prisma.medical_employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload>[]
          }
          create: {
            args: Prisma.medical_employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload>
          }
          createMany: {
            args: Prisma.medical_employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.medical_employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload>
          }
          update: {
            args: Prisma.medical_employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload>
          }
          deleteMany: {
            args: Prisma.medical_employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medical_employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medical_employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_employeePayload>
          }
          aggregate: {
            args: Prisma.Medical_employeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedical_employee>
          }
          groupBy: {
            args: Prisma.medical_employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Medical_employeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.medical_employeeCountArgs<ExtArgs>
            result: $Utils.Optional<Medical_employeeCountAggregateOutputType> | number
          }
        }
      }
      other_employee: {
        payload: Prisma.$other_employeePayload<ExtArgs>
        fields: Prisma.other_employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.other_employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.other_employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload>
          }
          findFirst: {
            args: Prisma.other_employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.other_employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload>
          }
          findMany: {
            args: Prisma.other_employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload>[]
          }
          create: {
            args: Prisma.other_employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload>
          }
          createMany: {
            args: Prisma.other_employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.other_employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload>
          }
          update: {
            args: Prisma.other_employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload>
          }
          deleteMany: {
            args: Prisma.other_employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.other_employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.other_employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employeePayload>
          }
          aggregate: {
            args: Prisma.Other_employeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOther_employee>
          }
          groupBy: {
            args: Prisma.other_employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Other_employeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.other_employeeCountArgs<ExtArgs>
            result: $Utils.Optional<Other_employeeCountAggregateOutputType> | number
          }
        }
      }
      other_employee_time_work: {
        payload: Prisma.$other_employee_time_workPayload<ExtArgs>
        fields: Prisma.other_employee_time_workFieldRefs
        operations: {
          findUnique: {
            args: Prisma.other_employee_time_workFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.other_employee_time_workFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload>
          }
          findFirst: {
            args: Prisma.other_employee_time_workFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.other_employee_time_workFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload>
          }
          findMany: {
            args: Prisma.other_employee_time_workFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload>[]
          }
          create: {
            args: Prisma.other_employee_time_workCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload>
          }
          createMany: {
            args: Prisma.other_employee_time_workCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.other_employee_time_workDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload>
          }
          update: {
            args: Prisma.other_employee_time_workUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload>
          }
          deleteMany: {
            args: Prisma.other_employee_time_workDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.other_employee_time_workUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.other_employee_time_workUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_employee_time_workPayload>
          }
          aggregate: {
            args: Prisma.Other_employee_time_workAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOther_employee_time_work>
          }
          groupBy: {
            args: Prisma.other_employee_time_workGroupByArgs<ExtArgs>
            result: $Utils.Optional<Other_employee_time_workGroupByOutputType>[]
          }
          count: {
            args: Prisma.other_employee_time_workCountArgs<ExtArgs>
            result: $Utils.Optional<Other_employee_time_workCountAggregateOutputType> | number
          }
        }
      }
      other_room: {
        payload: Prisma.$other_roomPayload<ExtArgs>
        fields: Prisma.other_roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.other_roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.other_roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload>
          }
          findFirst: {
            args: Prisma.other_roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.other_roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload>
          }
          findMany: {
            args: Prisma.other_roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload>[]
          }
          create: {
            args: Prisma.other_roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload>
          }
          createMany: {
            args: Prisma.other_roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.other_roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload>
          }
          update: {
            args: Prisma.other_roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload>
          }
          deleteMany: {
            args: Prisma.other_roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.other_roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.other_roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_roomPayload>
          }
          aggregate: {
            args: Prisma.Other_roomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOther_room>
          }
          groupBy: {
            args: Prisma.other_roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Other_roomGroupByOutputType>[]
          }
          count: {
            args: Prisma.other_roomCountArgs<ExtArgs>
            result: $Utils.Optional<Other_roomCountAggregateOutputType> | number
          }
        }
      }
      relative: {
        payload: Prisma.$relativePayload<ExtArgs>
        fields: Prisma.relativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.relativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.relativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload>
          }
          findFirst: {
            args: Prisma.relativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.relativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload>
          }
          findMany: {
            args: Prisma.relativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload>[]
          }
          create: {
            args: Prisma.relativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload>
          }
          createMany: {
            args: Prisma.relativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.relativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload>
          }
          update: {
            args: Prisma.relativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload>
          }
          deleteMany: {
            args: Prisma.relativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.relativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.relativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relativePayload>
          }
          aggregate: {
            args: Prisma.RelativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelative>
          }
          groupBy: {
            args: Prisma.relativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.relativeCountArgs<ExtArgs>
            result: $Utils.Optional<RelativeCountAggregateOutputType> | number
          }
        }
      }
      room: {
        payload: Prisma.$roomPayload<ExtArgs>
        fields: Prisma.roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          findFirst: {
            args: Prisma.roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          findMany: {
            args: Prisma.roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>[]
          }
          create: {
            args: Prisma.roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          createMany: {
            args: Prisma.roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          update: {
            args: Prisma.roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          deleteMany: {
            args: Prisma.roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.roomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      student: {
        payload: Prisma.$studentPayload<ExtArgs>
        fields: Prisma.studentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findFirst: {
            args: Prisma.studentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findMany: {
            args: Prisma.studentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          create: {
            args: Prisma.studentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          createMany: {
            args: Prisma.studentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.studentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          update: {
            args: Prisma.studentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          deleteMany: {
            args: Prisma.studentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.studentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      studentDiscipline: {
        payload: Prisma.$studentDisciplinePayload<ExtArgs>
        fields: Prisma.studentDisciplineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentDisciplineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentDisciplineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload>
          }
          findFirst: {
            args: Prisma.studentDisciplineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentDisciplineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload>
          }
          findMany: {
            args: Prisma.studentDisciplineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload>[]
          }
          create: {
            args: Prisma.studentDisciplineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload>
          }
          createMany: {
            args: Prisma.studentDisciplineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.studentDisciplineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload>
          }
          update: {
            args: Prisma.studentDisciplineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload>
          }
          deleteMany: {
            args: Prisma.studentDisciplineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentDisciplineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentDisciplineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentDisciplinePayload>
          }
          aggregate: {
            args: Prisma.StudentDisciplineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentDiscipline>
          }
          groupBy: {
            args: Prisma.studentDisciplineGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentDisciplineGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentDisciplineCountArgs<ExtArgs>
            result: $Utils.Optional<StudentDisciplineCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    address?: AddressOmit
    dormitory_Card?: Dormitory_CardOmit
    email?: EmailOmit
    employee_Card?: Employee_CardOmit
    identity_Card?: Identity_CardOmit
    people?: PeopleOmit
    phoneNumber?: PhoneNumberOmit
    building?: buildingOmit
    building_equipment?: building_equipmentOmit
    disciplinaryAction?: disciplinaryActionOmit
    disciplineStaff?: disciplineStaffOmit
    employee?: employeeOmit
    health_room?: health_roomOmit
    large_equipment?: large_equipmentOmit
    living_room?: living_roomOmit
    management_room?: management_roomOmit
    managerDorm?: managerDormOmit
    manager_degree?: manager_degreeOmit
    manager_employee?: manager_employeeOmit
    medical_degree?: medical_degreeOmit
    medical_employee?: medical_employeeOmit
    other_employee?: other_employeeOmit
    other_employee_time_work?: other_employee_time_workOmit
    other_room?: other_roomOmit
    relative?: relativeOmit
    room?: roomOmit
    student?: studentOmit
    studentDiscipline?: studentDisciplineOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PeopleCountOutputType
   */

  export type PeopleCountOutputType = {
    Address: number
    Email: number
    PhoneNumber: number
  }

  export type PeopleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | PeopleCountOutputTypeCountAddressArgs
    Email?: boolean | PeopleCountOutputTypeCountEmailArgs
    PhoneNumber?: boolean | PeopleCountOutputTypeCountPhoneNumberArgs
  }

  // Custom InputTypes
  /**
   * PeopleCountOutputType without action
   */
  export type PeopleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeopleCountOutputType
     */
    select?: PeopleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PeopleCountOutputType without action
   */
  export type PeopleCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * PeopleCountOutputType without action
   */
  export type PeopleCountOutputTypeCountEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }

  /**
   * PeopleCountOutputType without action
   */
  export type PeopleCountOutputTypeCountPhoneNumberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneNumberWhereInput
  }


  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    building_equipment: number
    room: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building_equipment?: boolean | BuildingCountOutputTypeCountBuilding_equipmentArgs
    room?: boolean | BuildingCountOutputTypeCountRoomArgs
  }

  // Custom InputTypes
  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountBuilding_equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: building_equipmentWhereInput
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roomWhereInput
  }


  /**
   * Count Type DisciplinaryActionCountOutputType
   */

  export type DisciplinaryActionCountOutputType = {
    disciplineStaff: number
    studentDiscipline: number
  }

  export type DisciplinaryActionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplineStaff?: boolean | DisciplinaryActionCountOutputTypeCountDisciplineStaffArgs
    studentDiscipline?: boolean | DisciplinaryActionCountOutputTypeCountStudentDisciplineArgs
  }

  // Custom InputTypes
  /**
   * DisciplinaryActionCountOutputType without action
   */
  export type DisciplinaryActionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryActionCountOutputType
     */
    select?: DisciplinaryActionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DisciplinaryActionCountOutputType without action
   */
  export type DisciplinaryActionCountOutputTypeCountDisciplineStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disciplineStaffWhereInput
  }

  /**
   * DisciplinaryActionCountOutputType without action
   */
  export type DisciplinaryActionCountOutputTypeCountStudentDisciplineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentDisciplineWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    Employee_Card: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee_Card?: boolean | EmployeeCountOutputTypeCountEmployee_CardArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployee_CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Employee_CardWhereInput
  }


  /**
   * Count Type Health_roomCountOutputType
   */

  export type Health_roomCountOutputType = {
    medical_employee: number
  }

  export type Health_roomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical_employee?: boolean | Health_roomCountOutputTypeCountMedical_employeeArgs
  }

  // Custom InputTypes
  /**
   * Health_roomCountOutputType without action
   */
  export type Health_roomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Health_roomCountOutputType
     */
    select?: Health_roomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Health_roomCountOutputType without action
   */
  export type Health_roomCountOutputTypeCountMedical_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_employeeWhereInput
  }


  /**
   * Count Type Large_equipmentCountOutputType
   */

  export type Large_equipmentCountOutputType = {
    building_equipment: number
  }

  export type Large_equipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building_equipment?: boolean | Large_equipmentCountOutputTypeCountBuilding_equipmentArgs
  }

  // Custom InputTypes
  /**
   * Large_equipmentCountOutputType without action
   */
  export type Large_equipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Large_equipmentCountOutputType
     */
    select?: Large_equipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Large_equipmentCountOutputType without action
   */
  export type Large_equipmentCountOutputTypeCountBuilding_equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: building_equipmentWhereInput
  }


  /**
   * Count Type Living_roomCountOutputType
   */

  export type Living_roomCountOutputType = {
    student: number
  }

  export type Living_roomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Living_roomCountOutputTypeCountStudentArgs
  }

  // Custom InputTypes
  /**
   * Living_roomCountOutputType without action
   */
  export type Living_roomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Living_roomCountOutputType
     */
    select?: Living_roomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Living_roomCountOutputType without action
   */
  export type Living_roomCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
  }


  /**
   * Count Type Management_roomCountOutputType
   */

  export type Management_roomCountOutputType = {
    manager_employee: number
  }

  export type Management_roomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager_employee?: boolean | Management_roomCountOutputTypeCountManager_employeeArgs
  }

  // Custom InputTypes
  /**
   * Management_roomCountOutputType without action
   */
  export type Management_roomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management_roomCountOutputType
     */
    select?: Management_roomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Management_roomCountOutputType without action
   */
  export type Management_roomCountOutputTypeCountManager_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manager_employeeWhereInput
  }


  /**
   * Count Type Manager_employeeCountOutputType
   */

  export type Manager_employeeCountOutputType = {
    disciplineStaff: number
    manager_degree: number
  }

  export type Manager_employeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplineStaff?: boolean | Manager_employeeCountOutputTypeCountDisciplineStaffArgs
    manager_degree?: boolean | Manager_employeeCountOutputTypeCountManager_degreeArgs
  }

  // Custom InputTypes
  /**
   * Manager_employeeCountOutputType without action
   */
  export type Manager_employeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager_employeeCountOutputType
     */
    select?: Manager_employeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Manager_employeeCountOutputType without action
   */
  export type Manager_employeeCountOutputTypeCountDisciplineStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disciplineStaffWhereInput
  }

  /**
   * Manager_employeeCountOutputType without action
   */
  export type Manager_employeeCountOutputTypeCountManager_degreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manager_degreeWhereInput
  }


  /**
   * Count Type Medical_employeeCountOutputType
   */

  export type Medical_employeeCountOutputType = {
    medical_degree: number
  }

  export type Medical_employeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical_degree?: boolean | Medical_employeeCountOutputTypeCountMedical_degreeArgs
  }

  // Custom InputTypes
  /**
   * Medical_employeeCountOutputType without action
   */
  export type Medical_employeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medical_employeeCountOutputType
     */
    select?: Medical_employeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Medical_employeeCountOutputType without action
   */
  export type Medical_employeeCountOutputTypeCountMedical_degreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_degreeWhereInput
  }


  /**
   * Count Type Other_employeeCountOutputType
   */

  export type Other_employeeCountOutputType = {
    other_employee_time_work: number
  }

  export type Other_employeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_employee_time_work?: boolean | Other_employeeCountOutputTypeCountOther_employee_time_workArgs
  }

  // Custom InputTypes
  /**
   * Other_employeeCountOutputType without action
   */
  export type Other_employeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Other_employeeCountOutputType
     */
    select?: Other_employeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Other_employeeCountOutputType without action
   */
  export type Other_employeeCountOutputTypeCountOther_employee_time_workArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: other_employee_time_workWhereInput
  }


  /**
   * Count Type Other_roomCountOutputType
   */

  export type Other_roomCountOutputType = {
    other_employee: number
  }

  export type Other_roomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_employee?: boolean | Other_roomCountOutputTypeCountOther_employeeArgs
  }

  // Custom InputTypes
  /**
   * Other_roomCountOutputType without action
   */
  export type Other_roomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Other_roomCountOutputType
     */
    select?: Other_roomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Other_roomCountOutputType without action
   */
  export type Other_roomCountOutputTypeCountOther_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: other_employeeWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    Dormitory_Card: number
    relative: number
    studentDiscipline: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dormitory_Card?: boolean | StudentCountOutputTypeCountDormitory_CardArgs
    relative?: boolean | StudentCountOutputTypeCountRelativeArgs
    studentDiscipline?: boolean | StudentCountOutputTypeCountStudentDisciplineArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountDormitory_CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Dormitory_CardWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountRelativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: relativeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentDisciplineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentDisciplineWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    ssn: string | null
    commune: string | null
    district: string | null
    province: string | null
  }

  export type AddressMaxAggregateOutputType = {
    ssn: string | null
    commune: string | null
    district: string | null
    province: string | null
  }

  export type AddressCountAggregateOutputType = {
    ssn: number
    commune: number
    district: number
    province: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    ssn?: true
    commune?: true
    district?: true
    province?: true
  }

  export type AddressMaxAggregateInputType = {
    ssn?: true
    commune?: true
    district?: true
    province?: true
  }

  export type AddressCountAggregateInputType = {
    ssn?: true
    commune?: true
    district?: true
    province?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    ssn: string
    commune: string
    district: string
    province: string
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ssn?: boolean
    commune?: boolean
    district?: boolean
    province?: boolean
    People?: boolean | PeopleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>



  export type AddressSelectScalar = {
    ssn?: boolean
    commune?: boolean
    district?: boolean
    province?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ssn" | "commune" | "district" | "province", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    People?: boolean | PeopleDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      People: Prisma.$PeoplePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ssn: string
      commune: string
      district: string
      province: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `ssn`
     * const addressWithSsnOnly = await prisma.address.findMany({ select: { ssn: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    People<T extends PeopleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeopleDefaultArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly ssn: FieldRef<"Address", 'String'>
    readonly commune: FieldRef<"Address", 'String'>
    readonly district: FieldRef<"Address", 'String'>
    readonly province: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Dormitory_Card
   */

  export type AggregateDormitory_Card = {
    _count: Dormitory_CardCountAggregateOutputType | null
    _min: Dormitory_CardMinAggregateOutputType | null
    _max: Dormitory_CardMaxAggregateOutputType | null
  }

  export type Dormitory_CardMinAggregateOutputType = {
    Number: string | null
    Start_Date: Date | null
    End_Date: Date | null
    ID_Card: string | null
    Validity: boolean | null
  }

  export type Dormitory_CardMaxAggregateOutputType = {
    Number: string | null
    Start_Date: Date | null
    End_Date: Date | null
    ID_Card: string | null
    Validity: boolean | null
  }

  export type Dormitory_CardCountAggregateOutputType = {
    Number: number
    Start_Date: number
    End_Date: number
    ID_Card: number
    Validity: number
    _all: number
  }


  export type Dormitory_CardMinAggregateInputType = {
    Number?: true
    Start_Date?: true
    End_Date?: true
    ID_Card?: true
    Validity?: true
  }

  export type Dormitory_CardMaxAggregateInputType = {
    Number?: true
    Start_Date?: true
    End_Date?: true
    ID_Card?: true
    Validity?: true
  }

  export type Dormitory_CardCountAggregateInputType = {
    Number?: true
    Start_Date?: true
    End_Date?: true
    ID_Card?: true
    Validity?: true
    _all?: true
  }

  export type Dormitory_CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dormitory_Card to aggregate.
     */
    where?: Dormitory_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dormitory_Cards to fetch.
     */
    orderBy?: Dormitory_CardOrderByWithRelationInput | Dormitory_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Dormitory_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dormitory_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dormitory_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dormitory_Cards
    **/
    _count?: true | Dormitory_CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dormitory_CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dormitory_CardMaxAggregateInputType
  }

  export type GetDormitory_CardAggregateType<T extends Dormitory_CardAggregateArgs> = {
        [P in keyof T & keyof AggregateDormitory_Card]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDormitory_Card[P]>
      : GetScalarType<T[P], AggregateDormitory_Card[P]>
  }




  export type Dormitory_CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Dormitory_CardWhereInput
    orderBy?: Dormitory_CardOrderByWithAggregationInput | Dormitory_CardOrderByWithAggregationInput[]
    by: Dormitory_CardScalarFieldEnum[] | Dormitory_CardScalarFieldEnum
    having?: Dormitory_CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dormitory_CardCountAggregateInputType | true
    _min?: Dormitory_CardMinAggregateInputType
    _max?: Dormitory_CardMaxAggregateInputType
  }

  export type Dormitory_CardGroupByOutputType = {
    Number: string
    Start_Date: Date | null
    End_Date: Date | null
    ID_Card: string
    Validity: boolean | null
    _count: Dormitory_CardCountAggregateOutputType | null
    _min: Dormitory_CardMinAggregateOutputType | null
    _max: Dormitory_CardMaxAggregateOutputType | null
  }

  type GetDormitory_CardGroupByPayload<T extends Dormitory_CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dormitory_CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dormitory_CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dormitory_CardGroupByOutputType[P]>
            : GetScalarType<T[P], Dormitory_CardGroupByOutputType[P]>
        }
      >
    >


  export type Dormitory_CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Number?: boolean
    Start_Date?: boolean
    End_Date?: boolean
    ID_Card?: boolean
    Validity?: boolean
    Identity_Card?: boolean | Identity_CardDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dormitory_Card"]>



  export type Dormitory_CardSelectScalar = {
    Number?: boolean
    Start_Date?: boolean
    End_Date?: boolean
    ID_Card?: boolean
    Validity?: boolean
  }

  export type Dormitory_CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Number" | "Start_Date" | "End_Date" | "ID_Card" | "Validity", ExtArgs["result"]["dormitory_Card"]>
  export type Dormitory_CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Identity_Card?: boolean | Identity_CardDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }

  export type $Dormitory_CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dormitory_Card"
    objects: {
      Identity_Card: Prisma.$Identity_CardPayload<ExtArgs>
      student: Prisma.$studentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Number: string
      Start_Date: Date | null
      End_Date: Date | null
      ID_Card: string
      Validity: boolean | null
    }, ExtArgs["result"]["dormitory_Card"]>
    composites: {}
  }

  type Dormitory_CardGetPayload<S extends boolean | null | undefined | Dormitory_CardDefaultArgs> = $Result.GetResult<Prisma.$Dormitory_CardPayload, S>

  type Dormitory_CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Dormitory_CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Dormitory_CardCountAggregateInputType | true
    }

  export interface Dormitory_CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dormitory_Card'], meta: { name: 'Dormitory_Card' } }
    /**
     * Find zero or one Dormitory_Card that matches the filter.
     * @param {Dormitory_CardFindUniqueArgs} args - Arguments to find a Dormitory_Card
     * @example
     * // Get one Dormitory_Card
     * const dormitory_Card = await prisma.dormitory_Card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Dormitory_CardFindUniqueArgs>(args: SelectSubset<T, Dormitory_CardFindUniqueArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dormitory_Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Dormitory_CardFindUniqueOrThrowArgs} args - Arguments to find a Dormitory_Card
     * @example
     * // Get one Dormitory_Card
     * const dormitory_Card = await prisma.dormitory_Card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Dormitory_CardFindUniqueOrThrowArgs>(args: SelectSubset<T, Dormitory_CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dormitory_Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dormitory_CardFindFirstArgs} args - Arguments to find a Dormitory_Card
     * @example
     * // Get one Dormitory_Card
     * const dormitory_Card = await prisma.dormitory_Card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Dormitory_CardFindFirstArgs>(args?: SelectSubset<T, Dormitory_CardFindFirstArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dormitory_Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dormitory_CardFindFirstOrThrowArgs} args - Arguments to find a Dormitory_Card
     * @example
     * // Get one Dormitory_Card
     * const dormitory_Card = await prisma.dormitory_Card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Dormitory_CardFindFirstOrThrowArgs>(args?: SelectSubset<T, Dormitory_CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dormitory_Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dormitory_CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dormitory_Cards
     * const dormitory_Cards = await prisma.dormitory_Card.findMany()
     * 
     * // Get first 10 Dormitory_Cards
     * const dormitory_Cards = await prisma.dormitory_Card.findMany({ take: 10 })
     * 
     * // Only select the `Number`
     * const dormitory_CardWithNumberOnly = await prisma.dormitory_Card.findMany({ select: { Number: true } })
     * 
     */
    findMany<T extends Dormitory_CardFindManyArgs>(args?: SelectSubset<T, Dormitory_CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dormitory_Card.
     * @param {Dormitory_CardCreateArgs} args - Arguments to create a Dormitory_Card.
     * @example
     * // Create one Dormitory_Card
     * const Dormitory_Card = await prisma.dormitory_Card.create({
     *   data: {
     *     // ... data to create a Dormitory_Card
     *   }
     * })
     * 
     */
    create<T extends Dormitory_CardCreateArgs>(args: SelectSubset<T, Dormitory_CardCreateArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dormitory_Cards.
     * @param {Dormitory_CardCreateManyArgs} args - Arguments to create many Dormitory_Cards.
     * @example
     * // Create many Dormitory_Cards
     * const dormitory_Card = await prisma.dormitory_Card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Dormitory_CardCreateManyArgs>(args?: SelectSubset<T, Dormitory_CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dormitory_Card.
     * @param {Dormitory_CardDeleteArgs} args - Arguments to delete one Dormitory_Card.
     * @example
     * // Delete one Dormitory_Card
     * const Dormitory_Card = await prisma.dormitory_Card.delete({
     *   where: {
     *     // ... filter to delete one Dormitory_Card
     *   }
     * })
     * 
     */
    delete<T extends Dormitory_CardDeleteArgs>(args: SelectSubset<T, Dormitory_CardDeleteArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dormitory_Card.
     * @param {Dormitory_CardUpdateArgs} args - Arguments to update one Dormitory_Card.
     * @example
     * // Update one Dormitory_Card
     * const dormitory_Card = await prisma.dormitory_Card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Dormitory_CardUpdateArgs>(args: SelectSubset<T, Dormitory_CardUpdateArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dormitory_Cards.
     * @param {Dormitory_CardDeleteManyArgs} args - Arguments to filter Dormitory_Cards to delete.
     * @example
     * // Delete a few Dormitory_Cards
     * const { count } = await prisma.dormitory_Card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Dormitory_CardDeleteManyArgs>(args?: SelectSubset<T, Dormitory_CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dormitory_Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dormitory_CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dormitory_Cards
     * const dormitory_Card = await prisma.dormitory_Card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Dormitory_CardUpdateManyArgs>(args: SelectSubset<T, Dormitory_CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dormitory_Card.
     * @param {Dormitory_CardUpsertArgs} args - Arguments to update or create a Dormitory_Card.
     * @example
     * // Update or create a Dormitory_Card
     * const dormitory_Card = await prisma.dormitory_Card.upsert({
     *   create: {
     *     // ... data to create a Dormitory_Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dormitory_Card we want to update
     *   }
     * })
     */
    upsert<T extends Dormitory_CardUpsertArgs>(args: SelectSubset<T, Dormitory_CardUpsertArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dormitory_Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dormitory_CardCountArgs} args - Arguments to filter Dormitory_Cards to count.
     * @example
     * // Count the number of Dormitory_Cards
     * const count = await prisma.dormitory_Card.count({
     *   where: {
     *     // ... the filter for the Dormitory_Cards we want to count
     *   }
     * })
    **/
    count<T extends Dormitory_CardCountArgs>(
      args?: Subset<T, Dormitory_CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dormitory_CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dormitory_Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dormitory_CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dormitory_CardAggregateArgs>(args: Subset<T, Dormitory_CardAggregateArgs>): Prisma.PrismaPromise<GetDormitory_CardAggregateType<T>>

    /**
     * Group by Dormitory_Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dormitory_CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Dormitory_CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Dormitory_CardGroupByArgs['orderBy'] }
        : { orderBy?: Dormitory_CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Dormitory_CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDormitory_CardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dormitory_Card model
   */
  readonly fields: Dormitory_CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dormitory_Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Dormitory_CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Identity_Card<T extends Identity_CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Identity_CardDefaultArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dormitory_Card model
   */
  interface Dormitory_CardFieldRefs {
    readonly Number: FieldRef<"Dormitory_Card", 'String'>
    readonly Start_Date: FieldRef<"Dormitory_Card", 'DateTime'>
    readonly End_Date: FieldRef<"Dormitory_Card", 'DateTime'>
    readonly ID_Card: FieldRef<"Dormitory_Card", 'String'>
    readonly Validity: FieldRef<"Dormitory_Card", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Dormitory_Card findUnique
   */
  export type Dormitory_CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * Filter, which Dormitory_Card to fetch.
     */
    where: Dormitory_CardWhereUniqueInput
  }

  /**
   * Dormitory_Card findUniqueOrThrow
   */
  export type Dormitory_CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * Filter, which Dormitory_Card to fetch.
     */
    where: Dormitory_CardWhereUniqueInput
  }

  /**
   * Dormitory_Card findFirst
   */
  export type Dormitory_CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * Filter, which Dormitory_Card to fetch.
     */
    where?: Dormitory_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dormitory_Cards to fetch.
     */
    orderBy?: Dormitory_CardOrderByWithRelationInput | Dormitory_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dormitory_Cards.
     */
    cursor?: Dormitory_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dormitory_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dormitory_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dormitory_Cards.
     */
    distinct?: Dormitory_CardScalarFieldEnum | Dormitory_CardScalarFieldEnum[]
  }

  /**
   * Dormitory_Card findFirstOrThrow
   */
  export type Dormitory_CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * Filter, which Dormitory_Card to fetch.
     */
    where?: Dormitory_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dormitory_Cards to fetch.
     */
    orderBy?: Dormitory_CardOrderByWithRelationInput | Dormitory_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dormitory_Cards.
     */
    cursor?: Dormitory_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dormitory_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dormitory_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dormitory_Cards.
     */
    distinct?: Dormitory_CardScalarFieldEnum | Dormitory_CardScalarFieldEnum[]
  }

  /**
   * Dormitory_Card findMany
   */
  export type Dormitory_CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * Filter, which Dormitory_Cards to fetch.
     */
    where?: Dormitory_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dormitory_Cards to fetch.
     */
    orderBy?: Dormitory_CardOrderByWithRelationInput | Dormitory_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dormitory_Cards.
     */
    cursor?: Dormitory_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dormitory_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dormitory_Cards.
     */
    skip?: number
    distinct?: Dormitory_CardScalarFieldEnum | Dormitory_CardScalarFieldEnum[]
  }

  /**
   * Dormitory_Card create
   */
  export type Dormitory_CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Dormitory_Card.
     */
    data: XOR<Dormitory_CardCreateInput, Dormitory_CardUncheckedCreateInput>
  }

  /**
   * Dormitory_Card createMany
   */
  export type Dormitory_CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dormitory_Cards.
     */
    data: Dormitory_CardCreateManyInput | Dormitory_CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dormitory_Card update
   */
  export type Dormitory_CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Dormitory_Card.
     */
    data: XOR<Dormitory_CardUpdateInput, Dormitory_CardUncheckedUpdateInput>
    /**
     * Choose, which Dormitory_Card to update.
     */
    where: Dormitory_CardWhereUniqueInput
  }

  /**
   * Dormitory_Card updateMany
   */
  export type Dormitory_CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dormitory_Cards.
     */
    data: XOR<Dormitory_CardUpdateManyMutationInput, Dormitory_CardUncheckedUpdateManyInput>
    /**
     * Filter which Dormitory_Cards to update
     */
    where?: Dormitory_CardWhereInput
    /**
     * Limit how many Dormitory_Cards to update.
     */
    limit?: number
  }

  /**
   * Dormitory_Card upsert
   */
  export type Dormitory_CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Dormitory_Card to update in case it exists.
     */
    where: Dormitory_CardWhereUniqueInput
    /**
     * In case the Dormitory_Card found by the `where` argument doesn't exist, create a new Dormitory_Card with this data.
     */
    create: XOR<Dormitory_CardCreateInput, Dormitory_CardUncheckedCreateInput>
    /**
     * In case the Dormitory_Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Dormitory_CardUpdateInput, Dormitory_CardUncheckedUpdateInput>
  }

  /**
   * Dormitory_Card delete
   */
  export type Dormitory_CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    /**
     * Filter which Dormitory_Card to delete.
     */
    where: Dormitory_CardWhereUniqueInput
  }

  /**
   * Dormitory_Card deleteMany
   */
  export type Dormitory_CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dormitory_Cards to delete
     */
    where?: Dormitory_CardWhereInput
    /**
     * Limit how many Dormitory_Cards to delete.
     */
    limit?: number
  }

  /**
   * Dormitory_Card without action
   */
  export type Dormitory_CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
  }


  /**
   * Model Email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailMinAggregateOutputType = {
    ssn: string | null
    email: string | null
  }

  export type EmailMaxAggregateOutputType = {
    ssn: string | null
    email: string | null
  }

  export type EmailCountAggregateOutputType = {
    ssn: number
    email: number
    _all: number
  }


  export type EmailMinAggregateInputType = {
    ssn?: true
    email?: true
  }

  export type EmailMaxAggregateInputType = {
    ssn?: true
    email?: true
  }

  export type EmailCountAggregateInputType = {
    ssn?: true
    email?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Email to aggregate.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type EmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithAggregationInput | EmailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: EmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    ssn: string
    email: string
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends EmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type EmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ssn?: boolean
    email?: boolean
    People?: boolean | PeopleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>



  export type EmailSelectScalar = {
    ssn?: boolean
    email?: boolean
  }

  export type EmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ssn" | "email", ExtArgs["result"]["email"]>
  export type EmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    People?: boolean | PeopleDefaultArgs<ExtArgs>
  }

  export type $EmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Email"
    objects: {
      People: Prisma.$PeoplePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ssn: string
      email: string
    }, ExtArgs["result"]["email"]>
    composites: {}
  }

  type EmailGetPayload<S extends boolean | null | undefined | EmailDefaultArgs> = $Result.GetResult<Prisma.$EmailPayload, S>

  type EmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCountAggregateInputType | true
    }

  export interface EmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Email'], meta: { name: 'Email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {EmailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailFindUniqueArgs>(args: SelectSubset<T, EmailFindUniqueArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailFindFirstArgs>(args?: SelectSubset<T, EmailFindFirstArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `ssn`
     * const emailWithSsnOnly = await prisma.email.findMany({ select: { ssn: true } })
     * 
     */
    findMany<T extends EmailFindManyArgs>(args?: SelectSubset<T, EmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email.
     * @param {EmailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
     */
    create<T extends EmailCreateArgs>(args: SelectSubset<T, EmailCreateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emails.
     * @param {EmailCreateManyArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCreateManyArgs>(args?: SelectSubset<T, EmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Email.
     * @param {EmailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
     */
    delete<T extends EmailDeleteArgs>(args: SelectSubset<T, EmailDeleteArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email.
     * @param {EmailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailUpdateArgs>(args: SelectSubset<T, EmailUpdateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emails.
     * @param {EmailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailDeleteManyArgs>(args?: SelectSubset<T, EmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailUpdateManyArgs>(args: SelectSubset<T, EmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Email.
     * @param {EmailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
     */
    upsert<T extends EmailUpsertArgs>(args: SelectSubset<T, EmailUpsertArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends EmailCountArgs>(
      args?: Subset<T, EmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGroupByArgs['orderBy'] }
        : { orderBy?: EmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Email model
   */
  readonly fields: EmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    People<T extends PeopleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeopleDefaultArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Email model
   */
  interface EmailFieldRefs {
    readonly ssn: FieldRef<"Email", 'String'>
    readonly email: FieldRef<"Email", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Email findUnique
   */
  export type EmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findUniqueOrThrow
   */
  export type EmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findFirst
   */
  export type EmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findFirstOrThrow
   */
  export type EmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findMany
   */
  export type EmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Emails to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email create
   */
  export type EmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to create a Email.
     */
    data: XOR<EmailCreateInput, EmailUncheckedCreateInput>
  }

  /**
   * Email createMany
   */
  export type EmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Email update
   */
  export type EmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to update a Email.
     */
    data: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    /**
     * Choose, which Email to update.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email updateMany
   */
  export type EmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to update.
     */
    limit?: number
  }

  /**
   * Email upsert
   */
  export type EmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The filter to search for the Email to update in case it exists.
     */
    where: EmailWhereUniqueInput
    /**
     * In case the Email found by the `where` argument doesn't exist, create a new Email with this data.
     */
    create: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    /**
     * In case the Email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
  }

  /**
   * Email delete
   */
  export type EmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter which Email to delete.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email deleteMany
   */
  export type EmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emails to delete
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to delete.
     */
    limit?: number
  }

  /**
   * Email without action
   */
  export type EmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
  }


  /**
   * Model Employee_Card
   */

  export type AggregateEmployee_Card = {
    _count: Employee_CardCountAggregateOutputType | null
    _min: Employee_CardMinAggregateOutputType | null
    _max: Employee_CardMaxAggregateOutputType | null
  }

  export type Employee_CardMinAggregateOutputType = {
    Number: string | null
    Start_Date: Date | null
    End_Date: Date | null
    ID_Card: string | null
    Employee_Type: string | null
  }

  export type Employee_CardMaxAggregateOutputType = {
    Number: string | null
    Start_Date: Date | null
    End_Date: Date | null
    ID_Card: string | null
    Employee_Type: string | null
  }

  export type Employee_CardCountAggregateOutputType = {
    Number: number
    Start_Date: number
    End_Date: number
    ID_Card: number
    Employee_Type: number
    _all: number
  }


  export type Employee_CardMinAggregateInputType = {
    Number?: true
    Start_Date?: true
    End_Date?: true
    ID_Card?: true
    Employee_Type?: true
  }

  export type Employee_CardMaxAggregateInputType = {
    Number?: true
    Start_Date?: true
    End_Date?: true
    ID_Card?: true
    Employee_Type?: true
  }

  export type Employee_CardCountAggregateInputType = {
    Number?: true
    Start_Date?: true
    End_Date?: true
    ID_Card?: true
    Employee_Type?: true
    _all?: true
  }

  export type Employee_CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee_Card to aggregate.
     */
    where?: Employee_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employee_Cards to fetch.
     */
    orderBy?: Employee_CardOrderByWithRelationInput | Employee_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Employee_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employee_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employee_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employee_Cards
    **/
    _count?: true | Employee_CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Employee_CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Employee_CardMaxAggregateInputType
  }

  export type GetEmployee_CardAggregateType<T extends Employee_CardAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee_Card]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee_Card[P]>
      : GetScalarType<T[P], AggregateEmployee_Card[P]>
  }




  export type Employee_CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Employee_CardWhereInput
    orderBy?: Employee_CardOrderByWithAggregationInput | Employee_CardOrderByWithAggregationInput[]
    by: Employee_CardScalarFieldEnum[] | Employee_CardScalarFieldEnum
    having?: Employee_CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Employee_CardCountAggregateInputType | true
    _min?: Employee_CardMinAggregateInputType
    _max?: Employee_CardMaxAggregateInputType
  }

  export type Employee_CardGroupByOutputType = {
    Number: string
    Start_Date: Date | null
    End_Date: Date | null
    ID_Card: string
    Employee_Type: string | null
    _count: Employee_CardCountAggregateOutputType | null
    _min: Employee_CardMinAggregateOutputType | null
    _max: Employee_CardMaxAggregateOutputType | null
  }

  type GetEmployee_CardGroupByPayload<T extends Employee_CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Employee_CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Employee_CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Employee_CardGroupByOutputType[P]>
            : GetScalarType<T[P], Employee_CardGroupByOutputType[P]>
        }
      >
    >


  export type Employee_CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Number?: boolean
    Start_Date?: boolean
    End_Date?: boolean
    ID_Card?: boolean
    Employee_Type?: boolean
    Identity_Card?: boolean | Identity_CardDefaultArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_Card"]>



  export type Employee_CardSelectScalar = {
    Number?: boolean
    Start_Date?: boolean
    End_Date?: boolean
    ID_Card?: boolean
    Employee_Type?: boolean
  }

  export type Employee_CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Number" | "Start_Date" | "End_Date" | "ID_Card" | "Employee_Type", ExtArgs["result"]["employee_Card"]>
  export type Employee_CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Identity_Card?: boolean | Identity_CardDefaultArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $Employee_CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee_Card"
    objects: {
      Identity_Card: Prisma.$Identity_CardPayload<ExtArgs>
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Number: string
      Start_Date: Date | null
      End_Date: Date | null
      ID_Card: string
      Employee_Type: string | null
    }, ExtArgs["result"]["employee_Card"]>
    composites: {}
  }

  type Employee_CardGetPayload<S extends boolean | null | undefined | Employee_CardDefaultArgs> = $Result.GetResult<Prisma.$Employee_CardPayload, S>

  type Employee_CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Employee_CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Employee_CardCountAggregateInputType | true
    }

  export interface Employee_CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee_Card'], meta: { name: 'Employee_Card' } }
    /**
     * Find zero or one Employee_Card that matches the filter.
     * @param {Employee_CardFindUniqueArgs} args - Arguments to find a Employee_Card
     * @example
     * // Get one Employee_Card
     * const employee_Card = await prisma.employee_Card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Employee_CardFindUniqueArgs>(args: SelectSubset<T, Employee_CardFindUniqueArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee_Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Employee_CardFindUniqueOrThrowArgs} args - Arguments to find a Employee_Card
     * @example
     * // Get one Employee_Card
     * const employee_Card = await prisma.employee_Card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Employee_CardFindUniqueOrThrowArgs>(args: SelectSubset<T, Employee_CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_CardFindFirstArgs} args - Arguments to find a Employee_Card
     * @example
     * // Get one Employee_Card
     * const employee_Card = await prisma.employee_Card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Employee_CardFindFirstArgs>(args?: SelectSubset<T, Employee_CardFindFirstArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_CardFindFirstOrThrowArgs} args - Arguments to find a Employee_Card
     * @example
     * // Get one Employee_Card
     * const employee_Card = await prisma.employee_Card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Employee_CardFindFirstOrThrowArgs>(args?: SelectSubset<T, Employee_CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employee_Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employee_Cards
     * const employee_Cards = await prisma.employee_Card.findMany()
     * 
     * // Get first 10 Employee_Cards
     * const employee_Cards = await prisma.employee_Card.findMany({ take: 10 })
     * 
     * // Only select the `Number`
     * const employee_CardWithNumberOnly = await prisma.employee_Card.findMany({ select: { Number: true } })
     * 
     */
    findMany<T extends Employee_CardFindManyArgs>(args?: SelectSubset<T, Employee_CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee_Card.
     * @param {Employee_CardCreateArgs} args - Arguments to create a Employee_Card.
     * @example
     * // Create one Employee_Card
     * const Employee_Card = await prisma.employee_Card.create({
     *   data: {
     *     // ... data to create a Employee_Card
     *   }
     * })
     * 
     */
    create<T extends Employee_CardCreateArgs>(args: SelectSubset<T, Employee_CardCreateArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employee_Cards.
     * @param {Employee_CardCreateManyArgs} args - Arguments to create many Employee_Cards.
     * @example
     * // Create many Employee_Cards
     * const employee_Card = await prisma.employee_Card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Employee_CardCreateManyArgs>(args?: SelectSubset<T, Employee_CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee_Card.
     * @param {Employee_CardDeleteArgs} args - Arguments to delete one Employee_Card.
     * @example
     * // Delete one Employee_Card
     * const Employee_Card = await prisma.employee_Card.delete({
     *   where: {
     *     // ... filter to delete one Employee_Card
     *   }
     * })
     * 
     */
    delete<T extends Employee_CardDeleteArgs>(args: SelectSubset<T, Employee_CardDeleteArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee_Card.
     * @param {Employee_CardUpdateArgs} args - Arguments to update one Employee_Card.
     * @example
     * // Update one Employee_Card
     * const employee_Card = await prisma.employee_Card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Employee_CardUpdateArgs>(args: SelectSubset<T, Employee_CardUpdateArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employee_Cards.
     * @param {Employee_CardDeleteManyArgs} args - Arguments to filter Employee_Cards to delete.
     * @example
     * // Delete a few Employee_Cards
     * const { count } = await prisma.employee_Card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Employee_CardDeleteManyArgs>(args?: SelectSubset<T, Employee_CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employee_Cards
     * const employee_Card = await prisma.employee_Card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Employee_CardUpdateManyArgs>(args: SelectSubset<T, Employee_CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee_Card.
     * @param {Employee_CardUpsertArgs} args - Arguments to update or create a Employee_Card.
     * @example
     * // Update or create a Employee_Card
     * const employee_Card = await prisma.employee_Card.upsert({
     *   create: {
     *     // ... data to create a Employee_Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee_Card we want to update
     *   }
     * })
     */
    upsert<T extends Employee_CardUpsertArgs>(args: SelectSubset<T, Employee_CardUpsertArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employee_Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_CardCountArgs} args - Arguments to filter Employee_Cards to count.
     * @example
     * // Count the number of Employee_Cards
     * const count = await prisma.employee_Card.count({
     *   where: {
     *     // ... the filter for the Employee_Cards we want to count
     *   }
     * })
    **/
    count<T extends Employee_CardCountArgs>(
      args?: Subset<T, Employee_CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Employee_CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee_Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Employee_CardAggregateArgs>(args: Subset<T, Employee_CardAggregateArgs>): Prisma.PrismaPromise<GetEmployee_CardAggregateType<T>>

    /**
     * Group by Employee_Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Employee_CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Employee_CardGroupByArgs['orderBy'] }
        : { orderBy?: Employee_CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Employee_CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployee_CardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee_Card model
   */
  readonly fields: Employee_CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee_Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Employee_CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Identity_Card<T extends Identity_CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Identity_CardDefaultArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee_Card model
   */
  interface Employee_CardFieldRefs {
    readonly Number: FieldRef<"Employee_Card", 'String'>
    readonly Start_Date: FieldRef<"Employee_Card", 'DateTime'>
    readonly End_Date: FieldRef<"Employee_Card", 'DateTime'>
    readonly ID_Card: FieldRef<"Employee_Card", 'String'>
    readonly Employee_Type: FieldRef<"Employee_Card", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employee_Card findUnique
   */
  export type Employee_CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * Filter, which Employee_Card to fetch.
     */
    where: Employee_CardWhereUniqueInput
  }

  /**
   * Employee_Card findUniqueOrThrow
   */
  export type Employee_CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * Filter, which Employee_Card to fetch.
     */
    where: Employee_CardWhereUniqueInput
  }

  /**
   * Employee_Card findFirst
   */
  export type Employee_CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * Filter, which Employee_Card to fetch.
     */
    where?: Employee_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employee_Cards to fetch.
     */
    orderBy?: Employee_CardOrderByWithRelationInput | Employee_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employee_Cards.
     */
    cursor?: Employee_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employee_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employee_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employee_Cards.
     */
    distinct?: Employee_CardScalarFieldEnum | Employee_CardScalarFieldEnum[]
  }

  /**
   * Employee_Card findFirstOrThrow
   */
  export type Employee_CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * Filter, which Employee_Card to fetch.
     */
    where?: Employee_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employee_Cards to fetch.
     */
    orderBy?: Employee_CardOrderByWithRelationInput | Employee_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employee_Cards.
     */
    cursor?: Employee_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employee_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employee_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employee_Cards.
     */
    distinct?: Employee_CardScalarFieldEnum | Employee_CardScalarFieldEnum[]
  }

  /**
   * Employee_Card findMany
   */
  export type Employee_CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * Filter, which Employee_Cards to fetch.
     */
    where?: Employee_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employee_Cards to fetch.
     */
    orderBy?: Employee_CardOrderByWithRelationInput | Employee_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employee_Cards.
     */
    cursor?: Employee_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employee_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employee_Cards.
     */
    skip?: number
    distinct?: Employee_CardScalarFieldEnum | Employee_CardScalarFieldEnum[]
  }

  /**
   * Employee_Card create
   */
  export type Employee_CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee_Card.
     */
    data: XOR<Employee_CardCreateInput, Employee_CardUncheckedCreateInput>
  }

  /**
   * Employee_Card createMany
   */
  export type Employee_CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employee_Cards.
     */
    data: Employee_CardCreateManyInput | Employee_CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee_Card update
   */
  export type Employee_CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee_Card.
     */
    data: XOR<Employee_CardUpdateInput, Employee_CardUncheckedUpdateInput>
    /**
     * Choose, which Employee_Card to update.
     */
    where: Employee_CardWhereUniqueInput
  }

  /**
   * Employee_Card updateMany
   */
  export type Employee_CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employee_Cards.
     */
    data: XOR<Employee_CardUpdateManyMutationInput, Employee_CardUncheckedUpdateManyInput>
    /**
     * Filter which Employee_Cards to update
     */
    where?: Employee_CardWhereInput
    /**
     * Limit how many Employee_Cards to update.
     */
    limit?: number
  }

  /**
   * Employee_Card upsert
   */
  export type Employee_CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee_Card to update in case it exists.
     */
    where: Employee_CardWhereUniqueInput
    /**
     * In case the Employee_Card found by the `where` argument doesn't exist, create a new Employee_Card with this data.
     */
    create: XOR<Employee_CardCreateInput, Employee_CardUncheckedCreateInput>
    /**
     * In case the Employee_Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Employee_CardUpdateInput, Employee_CardUncheckedUpdateInput>
  }

  /**
   * Employee_Card delete
   */
  export type Employee_CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    /**
     * Filter which Employee_Card to delete.
     */
    where: Employee_CardWhereUniqueInput
  }

  /**
   * Employee_Card deleteMany
   */
  export type Employee_CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee_Cards to delete
     */
    where?: Employee_CardWhereInput
    /**
     * Limit how many Employee_Cards to delete.
     */
    limit?: number
  }

  /**
   * Employee_Card without action
   */
  export type Employee_CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
  }


  /**
   * Model Identity_Card
   */

  export type AggregateIdentity_Card = {
    _count: Identity_CardCountAggregateOutputType | null
    _min: Identity_CardMinAggregateOutputType | null
    _max: Identity_CardMaxAggregateOutputType | null
  }

  export type Identity_CardMinAggregateOutputType = {
    ID: string | null
    Issued_Date: Date | null
  }

  export type Identity_CardMaxAggregateOutputType = {
    ID: string | null
    Issued_Date: Date | null
  }

  export type Identity_CardCountAggregateOutputType = {
    ID: number
    Issued_Date: number
    _all: number
  }


  export type Identity_CardMinAggregateInputType = {
    ID?: true
    Issued_Date?: true
  }

  export type Identity_CardMaxAggregateInputType = {
    ID?: true
    Issued_Date?: true
  }

  export type Identity_CardCountAggregateInputType = {
    ID?: true
    Issued_Date?: true
    _all?: true
  }

  export type Identity_CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identity_Card to aggregate.
     */
    where?: Identity_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identity_Cards to fetch.
     */
    orderBy?: Identity_CardOrderByWithRelationInput | Identity_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Identity_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identity_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identity_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Identity_Cards
    **/
    _count?: true | Identity_CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Identity_CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Identity_CardMaxAggregateInputType
  }

  export type GetIdentity_CardAggregateType<T extends Identity_CardAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentity_Card]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentity_Card[P]>
      : GetScalarType<T[P], AggregateIdentity_Card[P]>
  }




  export type Identity_CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Identity_CardWhereInput
    orderBy?: Identity_CardOrderByWithAggregationInput | Identity_CardOrderByWithAggregationInput[]
    by: Identity_CardScalarFieldEnum[] | Identity_CardScalarFieldEnum
    having?: Identity_CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Identity_CardCountAggregateInputType | true
    _min?: Identity_CardMinAggregateInputType
    _max?: Identity_CardMaxAggregateInputType
  }

  export type Identity_CardGroupByOutputType = {
    ID: string
    Issued_Date: Date
    _count: Identity_CardCountAggregateOutputType | null
    _min: Identity_CardMinAggregateOutputType | null
    _max: Identity_CardMaxAggregateOutputType | null
  }

  type GetIdentity_CardGroupByPayload<T extends Identity_CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Identity_CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Identity_CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Identity_CardGroupByOutputType[P]>
            : GetScalarType<T[P], Identity_CardGroupByOutputType[P]>
        }
      >
    >


  export type Identity_CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Issued_Date?: boolean
    Dormitory_Card?: boolean | Identity_Card$Dormitory_CardArgs<ExtArgs>
    Employee_Card?: boolean | Identity_Card$Employee_CardArgs<ExtArgs>
  }, ExtArgs["result"]["identity_Card"]>



  export type Identity_CardSelectScalar = {
    ID?: boolean
    Issued_Date?: boolean
  }

  export type Identity_CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Issued_Date", ExtArgs["result"]["identity_Card"]>
  export type Identity_CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dormitory_Card?: boolean | Identity_Card$Dormitory_CardArgs<ExtArgs>
    Employee_Card?: boolean | Identity_Card$Employee_CardArgs<ExtArgs>
  }

  export type $Identity_CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Identity_Card"
    objects: {
      Dormitory_Card: Prisma.$Dormitory_CardPayload<ExtArgs> | null
      Employee_Card: Prisma.$Employee_CardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: string
      Issued_Date: Date
    }, ExtArgs["result"]["identity_Card"]>
    composites: {}
  }

  type Identity_CardGetPayload<S extends boolean | null | undefined | Identity_CardDefaultArgs> = $Result.GetResult<Prisma.$Identity_CardPayload, S>

  type Identity_CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Identity_CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Identity_CardCountAggregateInputType | true
    }

  export interface Identity_CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Identity_Card'], meta: { name: 'Identity_Card' } }
    /**
     * Find zero or one Identity_Card that matches the filter.
     * @param {Identity_CardFindUniqueArgs} args - Arguments to find a Identity_Card
     * @example
     * // Get one Identity_Card
     * const identity_Card = await prisma.identity_Card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Identity_CardFindUniqueArgs>(args: SelectSubset<T, Identity_CardFindUniqueArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Identity_Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Identity_CardFindUniqueOrThrowArgs} args - Arguments to find a Identity_Card
     * @example
     * // Get one Identity_Card
     * const identity_Card = await prisma.identity_Card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Identity_CardFindUniqueOrThrowArgs>(args: SelectSubset<T, Identity_CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identity_Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Identity_CardFindFirstArgs} args - Arguments to find a Identity_Card
     * @example
     * // Get one Identity_Card
     * const identity_Card = await prisma.identity_Card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Identity_CardFindFirstArgs>(args?: SelectSubset<T, Identity_CardFindFirstArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identity_Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Identity_CardFindFirstOrThrowArgs} args - Arguments to find a Identity_Card
     * @example
     * // Get one Identity_Card
     * const identity_Card = await prisma.identity_Card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Identity_CardFindFirstOrThrowArgs>(args?: SelectSubset<T, Identity_CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Identity_Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Identity_CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Identity_Cards
     * const identity_Cards = await prisma.identity_Card.findMany()
     * 
     * // Get first 10 Identity_Cards
     * const identity_Cards = await prisma.identity_Card.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const identity_CardWithIDOnly = await prisma.identity_Card.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends Identity_CardFindManyArgs>(args?: SelectSubset<T, Identity_CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Identity_Card.
     * @param {Identity_CardCreateArgs} args - Arguments to create a Identity_Card.
     * @example
     * // Create one Identity_Card
     * const Identity_Card = await prisma.identity_Card.create({
     *   data: {
     *     // ... data to create a Identity_Card
     *   }
     * })
     * 
     */
    create<T extends Identity_CardCreateArgs>(args: SelectSubset<T, Identity_CardCreateArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Identity_Cards.
     * @param {Identity_CardCreateManyArgs} args - Arguments to create many Identity_Cards.
     * @example
     * // Create many Identity_Cards
     * const identity_Card = await prisma.identity_Card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Identity_CardCreateManyArgs>(args?: SelectSubset<T, Identity_CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Identity_Card.
     * @param {Identity_CardDeleteArgs} args - Arguments to delete one Identity_Card.
     * @example
     * // Delete one Identity_Card
     * const Identity_Card = await prisma.identity_Card.delete({
     *   where: {
     *     // ... filter to delete one Identity_Card
     *   }
     * })
     * 
     */
    delete<T extends Identity_CardDeleteArgs>(args: SelectSubset<T, Identity_CardDeleteArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Identity_Card.
     * @param {Identity_CardUpdateArgs} args - Arguments to update one Identity_Card.
     * @example
     * // Update one Identity_Card
     * const identity_Card = await prisma.identity_Card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Identity_CardUpdateArgs>(args: SelectSubset<T, Identity_CardUpdateArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Identity_Cards.
     * @param {Identity_CardDeleteManyArgs} args - Arguments to filter Identity_Cards to delete.
     * @example
     * // Delete a few Identity_Cards
     * const { count } = await prisma.identity_Card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Identity_CardDeleteManyArgs>(args?: SelectSubset<T, Identity_CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identity_Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Identity_CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Identity_Cards
     * const identity_Card = await prisma.identity_Card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Identity_CardUpdateManyArgs>(args: SelectSubset<T, Identity_CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Identity_Card.
     * @param {Identity_CardUpsertArgs} args - Arguments to update or create a Identity_Card.
     * @example
     * // Update or create a Identity_Card
     * const identity_Card = await prisma.identity_Card.upsert({
     *   create: {
     *     // ... data to create a Identity_Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Identity_Card we want to update
     *   }
     * })
     */
    upsert<T extends Identity_CardUpsertArgs>(args: SelectSubset<T, Identity_CardUpsertArgs<ExtArgs>>): Prisma__Identity_CardClient<$Result.GetResult<Prisma.$Identity_CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Identity_Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Identity_CardCountArgs} args - Arguments to filter Identity_Cards to count.
     * @example
     * // Count the number of Identity_Cards
     * const count = await prisma.identity_Card.count({
     *   where: {
     *     // ... the filter for the Identity_Cards we want to count
     *   }
     * })
    **/
    count<T extends Identity_CardCountArgs>(
      args?: Subset<T, Identity_CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Identity_CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Identity_Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Identity_CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Identity_CardAggregateArgs>(args: Subset<T, Identity_CardAggregateArgs>): Prisma.PrismaPromise<GetIdentity_CardAggregateType<T>>

    /**
     * Group by Identity_Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Identity_CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Identity_CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Identity_CardGroupByArgs['orderBy'] }
        : { orderBy?: Identity_CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Identity_CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentity_CardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Identity_Card model
   */
  readonly fields: Identity_CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Identity_Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Identity_CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Dormitory_Card<T extends Identity_Card$Dormitory_CardArgs<ExtArgs> = {}>(args?: Subset<T, Identity_Card$Dormitory_CardArgs<ExtArgs>>): Prisma__Dormitory_CardClient<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Employee_Card<T extends Identity_Card$Employee_CardArgs<ExtArgs> = {}>(args?: Subset<T, Identity_Card$Employee_CardArgs<ExtArgs>>): Prisma__Employee_CardClient<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Identity_Card model
   */
  interface Identity_CardFieldRefs {
    readonly ID: FieldRef<"Identity_Card", 'String'>
    readonly Issued_Date: FieldRef<"Identity_Card", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Identity_Card findUnique
   */
  export type Identity_CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * Filter, which Identity_Card to fetch.
     */
    where: Identity_CardWhereUniqueInput
  }

  /**
   * Identity_Card findUniqueOrThrow
   */
  export type Identity_CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * Filter, which Identity_Card to fetch.
     */
    where: Identity_CardWhereUniqueInput
  }

  /**
   * Identity_Card findFirst
   */
  export type Identity_CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * Filter, which Identity_Card to fetch.
     */
    where?: Identity_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identity_Cards to fetch.
     */
    orderBy?: Identity_CardOrderByWithRelationInput | Identity_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identity_Cards.
     */
    cursor?: Identity_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identity_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identity_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identity_Cards.
     */
    distinct?: Identity_CardScalarFieldEnum | Identity_CardScalarFieldEnum[]
  }

  /**
   * Identity_Card findFirstOrThrow
   */
  export type Identity_CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * Filter, which Identity_Card to fetch.
     */
    where?: Identity_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identity_Cards to fetch.
     */
    orderBy?: Identity_CardOrderByWithRelationInput | Identity_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identity_Cards.
     */
    cursor?: Identity_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identity_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identity_Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identity_Cards.
     */
    distinct?: Identity_CardScalarFieldEnum | Identity_CardScalarFieldEnum[]
  }

  /**
   * Identity_Card findMany
   */
  export type Identity_CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * Filter, which Identity_Cards to fetch.
     */
    where?: Identity_CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identity_Cards to fetch.
     */
    orderBy?: Identity_CardOrderByWithRelationInput | Identity_CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Identity_Cards.
     */
    cursor?: Identity_CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identity_Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identity_Cards.
     */
    skip?: number
    distinct?: Identity_CardScalarFieldEnum | Identity_CardScalarFieldEnum[]
  }

  /**
   * Identity_Card create
   */
  export type Identity_CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Identity_Card.
     */
    data: XOR<Identity_CardCreateInput, Identity_CardUncheckedCreateInput>
  }

  /**
   * Identity_Card createMany
   */
  export type Identity_CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Identity_Cards.
     */
    data: Identity_CardCreateManyInput | Identity_CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Identity_Card update
   */
  export type Identity_CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Identity_Card.
     */
    data: XOR<Identity_CardUpdateInput, Identity_CardUncheckedUpdateInput>
    /**
     * Choose, which Identity_Card to update.
     */
    where: Identity_CardWhereUniqueInput
  }

  /**
   * Identity_Card updateMany
   */
  export type Identity_CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Identity_Cards.
     */
    data: XOR<Identity_CardUpdateManyMutationInput, Identity_CardUncheckedUpdateManyInput>
    /**
     * Filter which Identity_Cards to update
     */
    where?: Identity_CardWhereInput
    /**
     * Limit how many Identity_Cards to update.
     */
    limit?: number
  }

  /**
   * Identity_Card upsert
   */
  export type Identity_CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Identity_Card to update in case it exists.
     */
    where: Identity_CardWhereUniqueInput
    /**
     * In case the Identity_Card found by the `where` argument doesn't exist, create a new Identity_Card with this data.
     */
    create: XOR<Identity_CardCreateInput, Identity_CardUncheckedCreateInput>
    /**
     * In case the Identity_Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Identity_CardUpdateInput, Identity_CardUncheckedUpdateInput>
  }

  /**
   * Identity_Card delete
   */
  export type Identity_CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
    /**
     * Filter which Identity_Card to delete.
     */
    where: Identity_CardWhereUniqueInput
  }

  /**
   * Identity_Card deleteMany
   */
  export type Identity_CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identity_Cards to delete
     */
    where?: Identity_CardWhereInput
    /**
     * Limit how many Identity_Cards to delete.
     */
    limit?: number
  }

  /**
   * Identity_Card.Dormitory_Card
   */
  export type Identity_Card$Dormitory_CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    where?: Dormitory_CardWhereInput
  }

  /**
   * Identity_Card.Employee_Card
   */
  export type Identity_Card$Employee_CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    where?: Employee_CardWhereInput
  }

  /**
   * Identity_Card without action
   */
  export type Identity_CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity_Card
     */
    select?: Identity_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity_Card
     */
    omit?: Identity_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Identity_CardInclude<ExtArgs> | null
  }


  /**
   * Model People
   */

  export type AggregatePeople = {
    _count: PeopleCountAggregateOutputType | null
    _min: PeopleMinAggregateOutputType | null
    _max: PeopleMaxAggregateOutputType | null
  }

  export type PeopleMinAggregateOutputType = {
    SSN: string | null
    Full_Name: string | null
    Last_Name: string | null
    Birthday: Date | null
    Sex: string | null
    Health_State: string | null
    Ethnic_Group: string | null
  }

  export type PeopleMaxAggregateOutputType = {
    SSN: string | null
    Full_Name: string | null
    Last_Name: string | null
    Birthday: Date | null
    Sex: string | null
    Health_State: string | null
    Ethnic_Group: string | null
  }

  export type PeopleCountAggregateOutputType = {
    SSN: number
    Full_Name: number
    Last_Name: number
    Birthday: number
    Sex: number
    Health_State: number
    Ethnic_Group: number
    _all: number
  }


  export type PeopleMinAggregateInputType = {
    SSN?: true
    Full_Name?: true
    Last_Name?: true
    Birthday?: true
    Sex?: true
    Health_State?: true
    Ethnic_Group?: true
  }

  export type PeopleMaxAggregateInputType = {
    SSN?: true
    Full_Name?: true
    Last_Name?: true
    Birthday?: true
    Sex?: true
    Health_State?: true
    Ethnic_Group?: true
  }

  export type PeopleCountAggregateInputType = {
    SSN?: true
    Full_Name?: true
    Last_Name?: true
    Birthday?: true
    Sex?: true
    Health_State?: true
    Ethnic_Group?: true
    _all?: true
  }

  export type PeopleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to aggregate.
     */
    where?: PeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PeopleOrderByWithRelationInput | PeopleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PeopleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeopleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeopleMaxAggregateInputType
  }

  export type GetPeopleAggregateType<T extends PeopleAggregateArgs> = {
        [P in keyof T & keyof AggregatePeople]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeople[P]>
      : GetScalarType<T[P], AggregatePeople[P]>
  }




  export type PeopleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeopleWhereInput
    orderBy?: PeopleOrderByWithAggregationInput | PeopleOrderByWithAggregationInput[]
    by: PeopleScalarFieldEnum[] | PeopleScalarFieldEnum
    having?: PeopleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeopleCountAggregateInputType | true
    _min?: PeopleMinAggregateInputType
    _max?: PeopleMaxAggregateInputType
  }

  export type PeopleGroupByOutputType = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date
    Sex: string | null
    Health_State: string | null
    Ethnic_Group: string | null
    _count: PeopleCountAggregateOutputType | null
    _min: PeopleMinAggregateOutputType | null
    _max: PeopleMaxAggregateOutputType | null
  }

  type GetPeopleGroupByPayload<T extends PeopleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeopleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeopleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeopleGroupByOutputType[P]>
            : GetScalarType<T[P], PeopleGroupByOutputType[P]>
        }
      >
    >


  export type PeopleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SSN?: boolean
    Full_Name?: boolean
    Last_Name?: boolean
    Birthday?: boolean
    Sex?: boolean
    Health_State?: boolean
    Ethnic_Group?: boolean
    Address?: boolean | People$AddressArgs<ExtArgs>
    Email?: boolean | People$EmailArgs<ExtArgs>
    PhoneNumber?: boolean | People$PhoneNumberArgs<ExtArgs>
    employee?: boolean | People$employeeArgs<ExtArgs>
    student?: boolean | People$studentArgs<ExtArgs>
    _count?: boolean | PeopleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["people"]>



  export type PeopleSelectScalar = {
    SSN?: boolean
    Full_Name?: boolean
    Last_Name?: boolean
    Birthday?: boolean
    Sex?: boolean
    Health_State?: boolean
    Ethnic_Group?: boolean
  }

  export type PeopleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SSN" | "Full_Name" | "Last_Name" | "Birthday" | "Sex" | "Health_State" | "Ethnic_Group", ExtArgs["result"]["people"]>
  export type PeopleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | People$AddressArgs<ExtArgs>
    Email?: boolean | People$EmailArgs<ExtArgs>
    PhoneNumber?: boolean | People$PhoneNumberArgs<ExtArgs>
    employee?: boolean | People$employeeArgs<ExtArgs>
    student?: boolean | People$studentArgs<ExtArgs>
    _count?: boolean | PeopleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PeoplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "People"
    objects: {
      Address: Prisma.$AddressPayload<ExtArgs>[]
      Email: Prisma.$EmailPayload<ExtArgs>[]
      PhoneNumber: Prisma.$PhoneNumberPayload<ExtArgs>[]
      employee: Prisma.$employeePayload<ExtArgs> | null
      student: Prisma.$studentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      SSN: string
      Full_Name: string
      Last_Name: string
      Birthday: Date
      Sex: string | null
      Health_State: string | null
      Ethnic_Group: string | null
    }, ExtArgs["result"]["people"]>
    composites: {}
  }

  type PeopleGetPayload<S extends boolean | null | undefined | PeopleDefaultArgs> = $Result.GetResult<Prisma.$PeoplePayload, S>

  type PeopleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PeopleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PeopleCountAggregateInputType | true
    }

  export interface PeopleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['People'], meta: { name: 'People' } }
    /**
     * Find zero or one People that matches the filter.
     * @param {PeopleFindUniqueArgs} args - Arguments to find a People
     * @example
     * // Get one People
     * const people = await prisma.people.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PeopleFindUniqueArgs>(args: SelectSubset<T, PeopleFindUniqueArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one People that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PeopleFindUniqueOrThrowArgs} args - Arguments to find a People
     * @example
     * // Get one People
     * const people = await prisma.people.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PeopleFindUniqueOrThrowArgs>(args: SelectSubset<T, PeopleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeopleFindFirstArgs} args - Arguments to find a People
     * @example
     * // Get one People
     * const people = await prisma.people.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PeopleFindFirstArgs>(args?: SelectSubset<T, PeopleFindFirstArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first People that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeopleFindFirstOrThrowArgs} args - Arguments to find a People
     * @example
     * // Get one People
     * const people = await prisma.people.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PeopleFindFirstOrThrowArgs>(args?: SelectSubset<T, PeopleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeopleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.people.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.people.findMany({ take: 10 })
     * 
     * // Only select the `SSN`
     * const peopleWithSSNOnly = await prisma.people.findMany({ select: { SSN: true } })
     * 
     */
    findMany<T extends PeopleFindManyArgs>(args?: SelectSubset<T, PeopleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a People.
     * @param {PeopleCreateArgs} args - Arguments to create a People.
     * @example
     * // Create one People
     * const People = await prisma.people.create({
     *   data: {
     *     // ... data to create a People
     *   }
     * })
     * 
     */
    create<T extends PeopleCreateArgs>(args: SelectSubset<T, PeopleCreateArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many People.
     * @param {PeopleCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const people = await prisma.people.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PeopleCreateManyArgs>(args?: SelectSubset<T, PeopleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a People.
     * @param {PeopleDeleteArgs} args - Arguments to delete one People.
     * @example
     * // Delete one People
     * const People = await prisma.people.delete({
     *   where: {
     *     // ... filter to delete one People
     *   }
     * })
     * 
     */
    delete<T extends PeopleDeleteArgs>(args: SelectSubset<T, PeopleDeleteArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one People.
     * @param {PeopleUpdateArgs} args - Arguments to update one People.
     * @example
     * // Update one People
     * const people = await prisma.people.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PeopleUpdateArgs>(args: SelectSubset<T, PeopleUpdateArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more People.
     * @param {PeopleDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.people.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PeopleDeleteManyArgs>(args?: SelectSubset<T, PeopleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeopleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const people = await prisma.people.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PeopleUpdateManyArgs>(args: SelectSubset<T, PeopleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one People.
     * @param {PeopleUpsertArgs} args - Arguments to update or create a People.
     * @example
     * // Update or create a People
     * const people = await prisma.people.upsert({
     *   create: {
     *     // ... data to create a People
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the People we want to update
     *   }
     * })
     */
    upsert<T extends PeopleUpsertArgs>(args: SelectSubset<T, PeopleUpsertArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeopleCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.people.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PeopleCountArgs>(
      args?: Subset<T, PeopleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeopleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeopleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeopleAggregateArgs>(args: Subset<T, PeopleAggregateArgs>): Prisma.PrismaPromise<GetPeopleAggregateType<T>>

    /**
     * Group by People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeopleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeopleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeopleGroupByArgs['orderBy'] }
        : { orderBy?: PeopleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeopleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeopleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the People model
   */
  readonly fields: PeopleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for People.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeopleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Address<T extends People$AddressArgs<ExtArgs> = {}>(args?: Subset<T, People$AddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Email<T extends People$EmailArgs<ExtArgs> = {}>(args?: Subset<T, People$EmailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PhoneNumber<T extends People$PhoneNumberArgs<ExtArgs> = {}>(args?: Subset<T, People$PhoneNumberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee<T extends People$employeeArgs<ExtArgs> = {}>(args?: Subset<T, People$employeeArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends People$studentArgs<ExtArgs> = {}>(args?: Subset<T, People$studentArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the People model
   */
  interface PeopleFieldRefs {
    readonly SSN: FieldRef<"People", 'String'>
    readonly Full_Name: FieldRef<"People", 'String'>
    readonly Last_Name: FieldRef<"People", 'String'>
    readonly Birthday: FieldRef<"People", 'DateTime'>
    readonly Sex: FieldRef<"People", 'String'>
    readonly Health_State: FieldRef<"People", 'String'>
    readonly Ethnic_Group: FieldRef<"People", 'String'>
  }
    

  // Custom InputTypes
  /**
   * People findUnique
   */
  export type PeopleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where: PeopleWhereUniqueInput
  }

  /**
   * People findUniqueOrThrow
   */
  export type PeopleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where: PeopleWhereUniqueInput
  }

  /**
   * People findFirst
   */
  export type PeopleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PeopleOrderByWithRelationInput | PeopleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PeopleScalarFieldEnum | PeopleScalarFieldEnum[]
  }

  /**
   * People findFirstOrThrow
   */
  export type PeopleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PeopleOrderByWithRelationInput | PeopleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PeopleScalarFieldEnum | PeopleScalarFieldEnum[]
  }

  /**
   * People findMany
   */
  export type PeopleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PeopleOrderByWithRelationInput | PeopleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PeopleScalarFieldEnum | PeopleScalarFieldEnum[]
  }

  /**
   * People create
   */
  export type PeopleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * The data needed to create a People.
     */
    data: XOR<PeopleCreateInput, PeopleUncheckedCreateInput>
  }

  /**
   * People createMany
   */
  export type PeopleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PeopleCreateManyInput | PeopleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * People update
   */
  export type PeopleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * The data needed to update a People.
     */
    data: XOR<PeopleUpdateInput, PeopleUncheckedUpdateInput>
    /**
     * Choose, which People to update.
     */
    where: PeopleWhereUniqueInput
  }

  /**
   * People updateMany
   */
  export type PeopleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PeopleUpdateManyMutationInput, PeopleUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PeopleWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * People upsert
   */
  export type PeopleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * The filter to search for the People to update in case it exists.
     */
    where: PeopleWhereUniqueInput
    /**
     * In case the People found by the `where` argument doesn't exist, create a new People with this data.
     */
    create: XOR<PeopleCreateInput, PeopleUncheckedCreateInput>
    /**
     * In case the People was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeopleUpdateInput, PeopleUncheckedUpdateInput>
  }

  /**
   * People delete
   */
  export type PeopleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
    /**
     * Filter which People to delete.
     */
    where: PeopleWhereUniqueInput
  }

  /**
   * People deleteMany
   */
  export type PeopleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PeopleWhereInput
    /**
     * Limit how many People to delete.
     */
    limit?: number
  }

  /**
   * People.Address
   */
  export type People$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * People.Email
   */
  export type People$EmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * People.PhoneNumber
   */
  export type People$PhoneNumberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    where?: PhoneNumberWhereInput
    orderBy?: PhoneNumberOrderByWithRelationInput | PhoneNumberOrderByWithRelationInput[]
    cursor?: PhoneNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[]
  }

  /**
   * People.employee
   */
  export type People$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
  }

  /**
   * People.student
   */
  export type People$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
  }

  /**
   * People without action
   */
  export type PeopleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the People
     */
    select?: PeopleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the People
     */
    omit?: PeopleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeopleInclude<ExtArgs> | null
  }


  /**
   * Model PhoneNumber
   */

  export type AggregatePhoneNumber = {
    _count: PhoneNumberCountAggregateOutputType | null
    _min: PhoneNumberMinAggregateOutputType | null
    _max: PhoneNumberMaxAggregateOutputType | null
  }

  export type PhoneNumberMinAggregateOutputType = {
    ssn: string | null
    phoneNumber: string | null
  }

  export type PhoneNumberMaxAggregateOutputType = {
    ssn: string | null
    phoneNumber: string | null
  }

  export type PhoneNumberCountAggregateOutputType = {
    ssn: number
    phoneNumber: number
    _all: number
  }


  export type PhoneNumberMinAggregateInputType = {
    ssn?: true
    phoneNumber?: true
  }

  export type PhoneNumberMaxAggregateInputType = {
    ssn?: true
    phoneNumber?: true
  }

  export type PhoneNumberCountAggregateInputType = {
    ssn?: true
    phoneNumber?: true
    _all?: true
  }

  export type PhoneNumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneNumber to aggregate.
     */
    where?: PhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneNumbers to fetch.
     */
    orderBy?: PhoneNumberOrderByWithRelationInput | PhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhoneNumbers
    **/
    _count?: true | PhoneNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneNumberMaxAggregateInputType
  }

  export type GetPhoneNumberAggregateType<T extends PhoneNumberAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoneNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoneNumber[P]>
      : GetScalarType<T[P], AggregatePhoneNumber[P]>
  }




  export type PhoneNumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneNumberWhereInput
    orderBy?: PhoneNumberOrderByWithAggregationInput | PhoneNumberOrderByWithAggregationInput[]
    by: PhoneNumberScalarFieldEnum[] | PhoneNumberScalarFieldEnum
    having?: PhoneNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneNumberCountAggregateInputType | true
    _min?: PhoneNumberMinAggregateInputType
    _max?: PhoneNumberMaxAggregateInputType
  }

  export type PhoneNumberGroupByOutputType = {
    ssn: string
    phoneNumber: string
    _count: PhoneNumberCountAggregateOutputType | null
    _min: PhoneNumberMinAggregateOutputType | null
    _max: PhoneNumberMaxAggregateOutputType | null
  }

  type GetPhoneNumberGroupByPayload<T extends PhoneNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhoneNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneNumberGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneNumberGroupByOutputType[P]>
        }
      >
    >


  export type PhoneNumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ssn?: boolean
    phoneNumber?: boolean
    People?: boolean | PeopleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phoneNumber"]>



  export type PhoneNumberSelectScalar = {
    ssn?: boolean
    phoneNumber?: boolean
  }

  export type PhoneNumberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ssn" | "phoneNumber", ExtArgs["result"]["phoneNumber"]>
  export type PhoneNumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    People?: boolean | PeopleDefaultArgs<ExtArgs>
  }

  export type $PhoneNumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhoneNumber"
    objects: {
      People: Prisma.$PeoplePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ssn: string
      phoneNumber: string
    }, ExtArgs["result"]["phoneNumber"]>
    composites: {}
  }

  type PhoneNumberGetPayload<S extends boolean | null | undefined | PhoneNumberDefaultArgs> = $Result.GetResult<Prisma.$PhoneNumberPayload, S>

  type PhoneNumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhoneNumberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhoneNumberCountAggregateInputType | true
    }

  export interface PhoneNumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhoneNumber'], meta: { name: 'PhoneNumber' } }
    /**
     * Find zero or one PhoneNumber that matches the filter.
     * @param {PhoneNumberFindUniqueArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhoneNumberFindUniqueArgs>(args: SelectSubset<T, PhoneNumberFindUniqueArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhoneNumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhoneNumberFindUniqueOrThrowArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhoneNumberFindUniqueOrThrowArgs>(args: SelectSubset<T, PhoneNumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberFindFirstArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhoneNumberFindFirstArgs>(args?: SelectSubset<T, PhoneNumberFindFirstArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberFindFirstOrThrowArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhoneNumberFindFirstOrThrowArgs>(args?: SelectSubset<T, PhoneNumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhoneNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneNumbers
     * const phoneNumbers = await prisma.phoneNumber.findMany()
     * 
     * // Get first 10 PhoneNumbers
     * const phoneNumbers = await prisma.phoneNumber.findMany({ take: 10 })
     * 
     * // Only select the `ssn`
     * const phoneNumberWithSsnOnly = await prisma.phoneNumber.findMany({ select: { ssn: true } })
     * 
     */
    findMany<T extends PhoneNumberFindManyArgs>(args?: SelectSubset<T, PhoneNumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhoneNumber.
     * @param {PhoneNumberCreateArgs} args - Arguments to create a PhoneNumber.
     * @example
     * // Create one PhoneNumber
     * const PhoneNumber = await prisma.phoneNumber.create({
     *   data: {
     *     // ... data to create a PhoneNumber
     *   }
     * })
     * 
     */
    create<T extends PhoneNumberCreateArgs>(args: SelectSubset<T, PhoneNumberCreateArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhoneNumbers.
     * @param {PhoneNumberCreateManyArgs} args - Arguments to create many PhoneNumbers.
     * @example
     * // Create many PhoneNumbers
     * const phoneNumber = await prisma.phoneNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhoneNumberCreateManyArgs>(args?: SelectSubset<T, PhoneNumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhoneNumber.
     * @param {PhoneNumberDeleteArgs} args - Arguments to delete one PhoneNumber.
     * @example
     * // Delete one PhoneNumber
     * const PhoneNumber = await prisma.phoneNumber.delete({
     *   where: {
     *     // ... filter to delete one PhoneNumber
     *   }
     * })
     * 
     */
    delete<T extends PhoneNumberDeleteArgs>(args: SelectSubset<T, PhoneNumberDeleteArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhoneNumber.
     * @param {PhoneNumberUpdateArgs} args - Arguments to update one PhoneNumber.
     * @example
     * // Update one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhoneNumberUpdateArgs>(args: SelectSubset<T, PhoneNumberUpdateArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhoneNumbers.
     * @param {PhoneNumberDeleteManyArgs} args - Arguments to filter PhoneNumbers to delete.
     * @example
     * // Delete a few PhoneNumbers
     * const { count } = await prisma.phoneNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhoneNumberDeleteManyArgs>(args?: SelectSubset<T, PhoneNumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneNumbers
     * const phoneNumber = await prisma.phoneNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhoneNumberUpdateManyArgs>(args: SelectSubset<T, PhoneNumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhoneNumber.
     * @param {PhoneNumberUpsertArgs} args - Arguments to update or create a PhoneNumber.
     * @example
     * // Update or create a PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.upsert({
     *   create: {
     *     // ... data to create a PhoneNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneNumber we want to update
     *   }
     * })
     */
    upsert<T extends PhoneNumberUpsertArgs>(args: SelectSubset<T, PhoneNumberUpsertArgs<ExtArgs>>): Prisma__PhoneNumberClient<$Result.GetResult<Prisma.$PhoneNumberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberCountArgs} args - Arguments to filter PhoneNumbers to count.
     * @example
     * // Count the number of PhoneNumbers
     * const count = await prisma.phoneNumber.count({
     *   where: {
     *     // ... the filter for the PhoneNumbers we want to count
     *   }
     * })
    **/
    count<T extends PhoneNumberCountArgs>(
      args?: Subset<T, PhoneNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneNumberAggregateArgs>(args: Subset<T, PhoneNumberAggregateArgs>): Prisma.PrismaPromise<GetPhoneNumberAggregateType<T>>

    /**
     * Group by PhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneNumberGroupByArgs['orderBy'] }
        : { orderBy?: PhoneNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhoneNumber model
   */
  readonly fields: PhoneNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhoneNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhoneNumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    People<T extends PeopleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeopleDefaultArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhoneNumber model
   */
  interface PhoneNumberFieldRefs {
    readonly ssn: FieldRef<"PhoneNumber", 'String'>
    readonly phoneNumber: FieldRef<"PhoneNumber", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PhoneNumber findUnique
   */
  export type PhoneNumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which PhoneNumber to fetch.
     */
    where: PhoneNumberWhereUniqueInput
  }

  /**
   * PhoneNumber findUniqueOrThrow
   */
  export type PhoneNumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which PhoneNumber to fetch.
     */
    where: PhoneNumberWhereUniqueInput
  }

  /**
   * PhoneNumber findFirst
   */
  export type PhoneNumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which PhoneNumber to fetch.
     */
    where?: PhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneNumbers to fetch.
     */
    orderBy?: PhoneNumberOrderByWithRelationInput | PhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneNumbers.
     */
    cursor?: PhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneNumbers.
     */
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[]
  }

  /**
   * PhoneNumber findFirstOrThrow
   */
  export type PhoneNumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which PhoneNumber to fetch.
     */
    where?: PhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneNumbers to fetch.
     */
    orderBy?: PhoneNumberOrderByWithRelationInput | PhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneNumbers.
     */
    cursor?: PhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneNumbers.
     */
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[]
  }

  /**
   * PhoneNumber findMany
   */
  export type PhoneNumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * Filter, which PhoneNumbers to fetch.
     */
    where?: PhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneNumbers to fetch.
     */
    orderBy?: PhoneNumberOrderByWithRelationInput | PhoneNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhoneNumbers.
     */
    cursor?: PhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneNumbers.
     */
    skip?: number
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[]
  }

  /**
   * PhoneNumber create
   */
  export type PhoneNumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * The data needed to create a PhoneNumber.
     */
    data: XOR<PhoneNumberCreateInput, PhoneNumberUncheckedCreateInput>
  }

  /**
   * PhoneNumber createMany
   */
  export type PhoneNumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhoneNumbers.
     */
    data: PhoneNumberCreateManyInput | PhoneNumberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhoneNumber update
   */
  export type PhoneNumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * The data needed to update a PhoneNumber.
     */
    data: XOR<PhoneNumberUpdateInput, PhoneNumberUncheckedUpdateInput>
    /**
     * Choose, which PhoneNumber to update.
     */
    where: PhoneNumberWhereUniqueInput
  }

  /**
   * PhoneNumber updateMany
   */
  export type PhoneNumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhoneNumbers.
     */
    data: XOR<PhoneNumberUpdateManyMutationInput, PhoneNumberUncheckedUpdateManyInput>
    /**
     * Filter which PhoneNumbers to update
     */
    where?: PhoneNumberWhereInput
    /**
     * Limit how many PhoneNumbers to update.
     */
    limit?: number
  }

  /**
   * PhoneNumber upsert
   */
  export type PhoneNumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * The filter to search for the PhoneNumber to update in case it exists.
     */
    where: PhoneNumberWhereUniqueInput
    /**
     * In case the PhoneNumber found by the `where` argument doesn't exist, create a new PhoneNumber with this data.
     */
    create: XOR<PhoneNumberCreateInput, PhoneNumberUncheckedCreateInput>
    /**
     * In case the PhoneNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneNumberUpdateInput, PhoneNumberUncheckedUpdateInput>
  }

  /**
   * PhoneNumber delete
   */
  export type PhoneNumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
    /**
     * Filter which PhoneNumber to delete.
     */
    where: PhoneNumberWhereUniqueInput
  }

  /**
   * PhoneNumber deleteMany
   */
  export type PhoneNumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneNumbers to delete
     */
    where?: PhoneNumberWhereInput
    /**
     * Limit how many PhoneNumbers to delete.
     */
    limit?: number
  }

  /**
   * PhoneNumber without action
   */
  export type PhoneNumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneNumber
     */
    select?: PhoneNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneNumber
     */
    omit?: PhoneNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneNumberInclude<ExtArgs> | null
  }


  /**
   * Model building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingAvgAggregateOutputType = {
    floors: number | null
    rooms: number | null
  }

  export type BuildingSumAggregateOutputType = {
    floors: number | null
    rooms: number | null
  }

  export type BuildingMinAggregateOutputType = {
    building_id: string | null
    building_name: string | null
    floors: number | null
    rooms: number | null
    has_air_conditioner: boolean | null
    sponsor: string | null
    construction_date: Date | null
    last_renovation: Date | null
  }

  export type BuildingMaxAggregateOutputType = {
    building_id: string | null
    building_name: string | null
    floors: number | null
    rooms: number | null
    has_air_conditioner: boolean | null
    sponsor: string | null
    construction_date: Date | null
    last_renovation: Date | null
  }

  export type BuildingCountAggregateOutputType = {
    building_id: number
    building_name: number
    floors: number
    rooms: number
    has_air_conditioner: number
    sponsor: number
    construction_date: number
    last_renovation: number
    _all: number
  }


  export type BuildingAvgAggregateInputType = {
    floors?: true
    rooms?: true
  }

  export type BuildingSumAggregateInputType = {
    floors?: true
    rooms?: true
  }

  export type BuildingMinAggregateInputType = {
    building_id?: true
    building_name?: true
    floors?: true
    rooms?: true
    has_air_conditioner?: true
    sponsor?: true
    construction_date?: true
    last_renovation?: true
  }

  export type BuildingMaxAggregateInputType = {
    building_id?: true
    building_name?: true
    floors?: true
    rooms?: true
    has_air_conditioner?: true
    sponsor?: true
    construction_date?: true
    last_renovation?: true
  }

  export type BuildingCountAggregateInputType = {
    building_id?: true
    building_name?: true
    floors?: true
    rooms?: true
    has_air_conditioner?: true
    sponsor?: true
    construction_date?: true
    last_renovation?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which building to aggregate.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type buildingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: buildingWhereInput
    orderBy?: buildingOrderByWithAggregationInput | buildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: buildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _avg?: BuildingAvgAggregateInputType
    _sum?: BuildingSumAggregateInputType
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor: string | null
    construction_date: Date
    last_renovation: Date | null
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends buildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type buildingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    building_id?: boolean
    building_name?: boolean
    floors?: boolean
    rooms?: boolean
    has_air_conditioner?: boolean
    sponsor?: boolean
    construction_date?: boolean
    last_renovation?: boolean
    building_equipment?: boolean | building$building_equipmentArgs<ExtArgs>
    room?: boolean | building$roomArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>



  export type buildingSelectScalar = {
    building_id?: boolean
    building_name?: boolean
    floors?: boolean
    rooms?: boolean
    has_air_conditioner?: boolean
    sponsor?: boolean
    construction_date?: boolean
    last_renovation?: boolean
  }

  export type buildingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"building_id" | "building_name" | "floors" | "rooms" | "has_air_conditioner" | "sponsor" | "construction_date" | "last_renovation", ExtArgs["result"]["building"]>
  export type buildingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building_equipment?: boolean | building$building_equipmentArgs<ExtArgs>
    room?: boolean | building$roomArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $buildingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "building"
    objects: {
      building_equipment: Prisma.$building_equipmentPayload<ExtArgs>[]
      room: Prisma.$roomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      building_id: string
      building_name: string
      floors: number
      rooms: number
      has_air_conditioner: boolean
      sponsor: string | null
      construction_date: Date
      last_renovation: Date | null
    }, ExtArgs["result"]["building"]>
    composites: {}
  }

  type buildingGetPayload<S extends boolean | null | undefined | buildingDefaultArgs> = $Result.GetResult<Prisma.$buildingPayload, S>

  type buildingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<buildingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface buildingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['building'], meta: { name: 'building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {buildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends buildingFindUniqueArgs>(args: SelectSubset<T, buildingFindUniqueArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Building that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {buildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends buildingFindUniqueOrThrowArgs>(args: SelectSubset<T, buildingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends buildingFindFirstArgs>(args?: SelectSubset<T, buildingFindFirstArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends buildingFindFirstOrThrowArgs>(args?: SelectSubset<T, buildingFindFirstOrThrowArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `building_id`
     * const buildingWithBuilding_idOnly = await prisma.building.findMany({ select: { building_id: true } })
     * 
     */
    findMany<T extends buildingFindManyArgs>(args?: SelectSubset<T, buildingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Building.
     * @param {buildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
     */
    create<T extends buildingCreateArgs>(args: SelectSubset<T, buildingCreateArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buildings.
     * @param {buildingCreateManyArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends buildingCreateManyArgs>(args?: SelectSubset<T, buildingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Building.
     * @param {buildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
     */
    delete<T extends buildingDeleteArgs>(args: SelectSubset<T, buildingDeleteArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Building.
     * @param {buildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends buildingUpdateArgs>(args: SelectSubset<T, buildingUpdateArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buildings.
     * @param {buildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends buildingDeleteManyArgs>(args?: SelectSubset<T, buildingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends buildingUpdateManyArgs>(args: SelectSubset<T, buildingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Building.
     * @param {buildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
     */
    upsert<T extends buildingUpsertArgs>(args: SelectSubset<T, buildingUpsertArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends buildingCountArgs>(
      args?: Subset<T, buildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends buildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: buildingGroupByArgs['orderBy'] }
        : { orderBy?: buildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, buildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the building model
   */
  readonly fields: buildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__buildingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building_equipment<T extends building$building_equipmentArgs<ExtArgs> = {}>(args?: Subset<T, building$building_equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room<T extends building$roomArgs<ExtArgs> = {}>(args?: Subset<T, building$roomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the building model
   */
  interface buildingFieldRefs {
    readonly building_id: FieldRef<"building", 'String'>
    readonly building_name: FieldRef<"building", 'String'>
    readonly floors: FieldRef<"building", 'Int'>
    readonly rooms: FieldRef<"building", 'Int'>
    readonly has_air_conditioner: FieldRef<"building", 'Boolean'>
    readonly sponsor: FieldRef<"building", 'String'>
    readonly construction_date: FieldRef<"building", 'DateTime'>
    readonly last_renovation: FieldRef<"building", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * building findUnique
   */
  export type buildingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building findUniqueOrThrow
   */
  export type buildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building findFirst
   */
  export type buildingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for buildings.
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * building findFirstOrThrow
   */
  export type buildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for buildings.
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * building findMany
   */
  export type buildingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which buildings to fetch.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing buildings.
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * building create
   */
  export type buildingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * The data needed to create a building.
     */
    data: XOR<buildingCreateInput, buildingUncheckedCreateInput>
  }

  /**
   * building createMany
   */
  export type buildingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many buildings.
     */
    data: buildingCreateManyInput | buildingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * building update
   */
  export type buildingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * The data needed to update a building.
     */
    data: XOR<buildingUpdateInput, buildingUncheckedUpdateInput>
    /**
     * Choose, which building to update.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building updateMany
   */
  export type buildingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update buildings.
     */
    data: XOR<buildingUpdateManyMutationInput, buildingUncheckedUpdateManyInput>
    /**
     * Filter which buildings to update
     */
    where?: buildingWhereInput
    /**
     * Limit how many buildings to update.
     */
    limit?: number
  }

  /**
   * building upsert
   */
  export type buildingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * The filter to search for the building to update in case it exists.
     */
    where: buildingWhereUniqueInput
    /**
     * In case the building found by the `where` argument doesn't exist, create a new building with this data.
     */
    create: XOR<buildingCreateInput, buildingUncheckedCreateInput>
    /**
     * In case the building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<buildingUpdateInput, buildingUncheckedUpdateInput>
  }

  /**
   * building delete
   */
  export type buildingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter which building to delete.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building deleteMany
   */
  export type buildingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which buildings to delete
     */
    where?: buildingWhereInput
    /**
     * Limit how many buildings to delete.
     */
    limit?: number
  }

  /**
   * building.building_equipment
   */
  export type building$building_equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    where?: building_equipmentWhereInput
    orderBy?: building_equipmentOrderByWithRelationInput | building_equipmentOrderByWithRelationInput[]
    cursor?: building_equipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Building_equipmentScalarFieldEnum | Building_equipmentScalarFieldEnum[]
  }

  /**
   * building.room
   */
  export type building$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    where?: roomWhereInput
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    cursor?: roomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * building without action
   */
  export type buildingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
  }


  /**
   * Model building_equipment
   */

  export type AggregateBuilding_equipment = {
    _count: Building_equipmentCountAggregateOutputType | null
    _avg: Building_equipmentAvgAggregateOutputType | null
    _sum: Building_equipmentSumAggregateOutputType | null
    _min: Building_equipmentMinAggregateOutputType | null
    _max: Building_equipmentMaxAggregateOutputType | null
  }

  export type Building_equipmentAvgAggregateOutputType = {
    quantity: number | null
  }

  export type Building_equipmentSumAggregateOutputType = {
    quantity: number | null
  }

  export type Building_equipmentMinAggregateOutputType = {
    building_id: string | null
    equipment_id: string | null
    quantity: number | null
  }

  export type Building_equipmentMaxAggregateOutputType = {
    building_id: string | null
    equipment_id: string | null
    quantity: number | null
  }

  export type Building_equipmentCountAggregateOutputType = {
    building_id: number
    equipment_id: number
    quantity: number
    _all: number
  }


  export type Building_equipmentAvgAggregateInputType = {
    quantity?: true
  }

  export type Building_equipmentSumAggregateInputType = {
    quantity?: true
  }

  export type Building_equipmentMinAggregateInputType = {
    building_id?: true
    equipment_id?: true
    quantity?: true
  }

  export type Building_equipmentMaxAggregateInputType = {
    building_id?: true
    equipment_id?: true
    quantity?: true
  }

  export type Building_equipmentCountAggregateInputType = {
    building_id?: true
    equipment_id?: true
    quantity?: true
    _all?: true
  }

  export type Building_equipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which building_equipment to aggregate.
     */
    where?: building_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of building_equipments to fetch.
     */
    orderBy?: building_equipmentOrderByWithRelationInput | building_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: building_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` building_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` building_equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned building_equipments
    **/
    _count?: true | Building_equipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Building_equipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Building_equipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Building_equipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Building_equipmentMaxAggregateInputType
  }

  export type GetBuilding_equipmentAggregateType<T extends Building_equipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding_equipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding_equipment[P]>
      : GetScalarType<T[P], AggregateBuilding_equipment[P]>
  }




  export type building_equipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: building_equipmentWhereInput
    orderBy?: building_equipmentOrderByWithAggregationInput | building_equipmentOrderByWithAggregationInput[]
    by: Building_equipmentScalarFieldEnum[] | Building_equipmentScalarFieldEnum
    having?: building_equipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Building_equipmentCountAggregateInputType | true
    _avg?: Building_equipmentAvgAggregateInputType
    _sum?: Building_equipmentSumAggregateInputType
    _min?: Building_equipmentMinAggregateInputType
    _max?: Building_equipmentMaxAggregateInputType
  }

  export type Building_equipmentGroupByOutputType = {
    building_id: string
    equipment_id: string
    quantity: number
    _count: Building_equipmentCountAggregateOutputType | null
    _avg: Building_equipmentAvgAggregateOutputType | null
    _sum: Building_equipmentSumAggregateOutputType | null
    _min: Building_equipmentMinAggregateOutputType | null
    _max: Building_equipmentMaxAggregateOutputType | null
  }

  type GetBuilding_equipmentGroupByPayload<T extends building_equipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Building_equipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Building_equipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Building_equipmentGroupByOutputType[P]>
            : GetScalarType<T[P], Building_equipmentGroupByOutputType[P]>
        }
      >
    >


  export type building_equipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    building_id?: boolean
    equipment_id?: boolean
    quantity?: boolean
    building?: boolean | buildingDefaultArgs<ExtArgs>
    large_equipment?: boolean | large_equipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building_equipment"]>



  export type building_equipmentSelectScalar = {
    building_id?: boolean
    equipment_id?: boolean
    quantity?: boolean
  }

  export type building_equipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"building_id" | "equipment_id" | "quantity", ExtArgs["result"]["building_equipment"]>
  export type building_equipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | buildingDefaultArgs<ExtArgs>
    large_equipment?: boolean | large_equipmentDefaultArgs<ExtArgs>
  }

  export type $building_equipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "building_equipment"
    objects: {
      building: Prisma.$buildingPayload<ExtArgs>
      large_equipment: Prisma.$large_equipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      building_id: string
      equipment_id: string
      quantity: number
    }, ExtArgs["result"]["building_equipment"]>
    composites: {}
  }

  type building_equipmentGetPayload<S extends boolean | null | undefined | building_equipmentDefaultArgs> = $Result.GetResult<Prisma.$building_equipmentPayload, S>

  type building_equipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<building_equipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Building_equipmentCountAggregateInputType | true
    }

  export interface building_equipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['building_equipment'], meta: { name: 'building_equipment' } }
    /**
     * Find zero or one Building_equipment that matches the filter.
     * @param {building_equipmentFindUniqueArgs} args - Arguments to find a Building_equipment
     * @example
     * // Get one Building_equipment
     * const building_equipment = await prisma.building_equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends building_equipmentFindUniqueArgs>(args: SelectSubset<T, building_equipmentFindUniqueArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Building_equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {building_equipmentFindUniqueOrThrowArgs} args - Arguments to find a Building_equipment
     * @example
     * // Get one Building_equipment
     * const building_equipment = await prisma.building_equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends building_equipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, building_equipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building_equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {building_equipmentFindFirstArgs} args - Arguments to find a Building_equipment
     * @example
     * // Get one Building_equipment
     * const building_equipment = await prisma.building_equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends building_equipmentFindFirstArgs>(args?: SelectSubset<T, building_equipmentFindFirstArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building_equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {building_equipmentFindFirstOrThrowArgs} args - Arguments to find a Building_equipment
     * @example
     * // Get one Building_equipment
     * const building_equipment = await prisma.building_equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends building_equipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, building_equipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Building_equipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {building_equipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Building_equipments
     * const building_equipments = await prisma.building_equipment.findMany()
     * 
     * // Get first 10 Building_equipments
     * const building_equipments = await prisma.building_equipment.findMany({ take: 10 })
     * 
     * // Only select the `building_id`
     * const building_equipmentWithBuilding_idOnly = await prisma.building_equipment.findMany({ select: { building_id: true } })
     * 
     */
    findMany<T extends building_equipmentFindManyArgs>(args?: SelectSubset<T, building_equipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Building_equipment.
     * @param {building_equipmentCreateArgs} args - Arguments to create a Building_equipment.
     * @example
     * // Create one Building_equipment
     * const Building_equipment = await prisma.building_equipment.create({
     *   data: {
     *     // ... data to create a Building_equipment
     *   }
     * })
     * 
     */
    create<T extends building_equipmentCreateArgs>(args: SelectSubset<T, building_equipmentCreateArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Building_equipments.
     * @param {building_equipmentCreateManyArgs} args - Arguments to create many Building_equipments.
     * @example
     * // Create many Building_equipments
     * const building_equipment = await prisma.building_equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends building_equipmentCreateManyArgs>(args?: SelectSubset<T, building_equipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Building_equipment.
     * @param {building_equipmentDeleteArgs} args - Arguments to delete one Building_equipment.
     * @example
     * // Delete one Building_equipment
     * const Building_equipment = await prisma.building_equipment.delete({
     *   where: {
     *     // ... filter to delete one Building_equipment
     *   }
     * })
     * 
     */
    delete<T extends building_equipmentDeleteArgs>(args: SelectSubset<T, building_equipmentDeleteArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Building_equipment.
     * @param {building_equipmentUpdateArgs} args - Arguments to update one Building_equipment.
     * @example
     * // Update one Building_equipment
     * const building_equipment = await prisma.building_equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends building_equipmentUpdateArgs>(args: SelectSubset<T, building_equipmentUpdateArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Building_equipments.
     * @param {building_equipmentDeleteManyArgs} args - Arguments to filter Building_equipments to delete.
     * @example
     * // Delete a few Building_equipments
     * const { count } = await prisma.building_equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends building_equipmentDeleteManyArgs>(args?: SelectSubset<T, building_equipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Building_equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {building_equipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Building_equipments
     * const building_equipment = await prisma.building_equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends building_equipmentUpdateManyArgs>(args: SelectSubset<T, building_equipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Building_equipment.
     * @param {building_equipmentUpsertArgs} args - Arguments to update or create a Building_equipment.
     * @example
     * // Update or create a Building_equipment
     * const building_equipment = await prisma.building_equipment.upsert({
     *   create: {
     *     // ... data to create a Building_equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building_equipment we want to update
     *   }
     * })
     */
    upsert<T extends building_equipmentUpsertArgs>(args: SelectSubset<T, building_equipmentUpsertArgs<ExtArgs>>): Prisma__building_equipmentClient<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Building_equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {building_equipmentCountArgs} args - Arguments to filter Building_equipments to count.
     * @example
     * // Count the number of Building_equipments
     * const count = await prisma.building_equipment.count({
     *   where: {
     *     // ... the filter for the Building_equipments we want to count
     *   }
     * })
    **/
    count<T extends building_equipmentCountArgs>(
      args?: Subset<T, building_equipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Building_equipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building_equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Building_equipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Building_equipmentAggregateArgs>(args: Subset<T, Building_equipmentAggregateArgs>): Prisma.PrismaPromise<GetBuilding_equipmentAggregateType<T>>

    /**
     * Group by Building_equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {building_equipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends building_equipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: building_equipmentGroupByArgs['orderBy'] }
        : { orderBy?: building_equipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, building_equipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuilding_equipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the building_equipment model
   */
  readonly fields: building_equipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for building_equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__building_equipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building<T extends buildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, buildingDefaultArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    large_equipment<T extends large_equipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, large_equipmentDefaultArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the building_equipment model
   */
  interface building_equipmentFieldRefs {
    readonly building_id: FieldRef<"building_equipment", 'String'>
    readonly equipment_id: FieldRef<"building_equipment", 'String'>
    readonly quantity: FieldRef<"building_equipment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * building_equipment findUnique
   */
  export type building_equipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which building_equipment to fetch.
     */
    where: building_equipmentWhereUniqueInput
  }

  /**
   * building_equipment findUniqueOrThrow
   */
  export type building_equipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which building_equipment to fetch.
     */
    where: building_equipmentWhereUniqueInput
  }

  /**
   * building_equipment findFirst
   */
  export type building_equipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which building_equipment to fetch.
     */
    where?: building_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of building_equipments to fetch.
     */
    orderBy?: building_equipmentOrderByWithRelationInput | building_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for building_equipments.
     */
    cursor?: building_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` building_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` building_equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of building_equipments.
     */
    distinct?: Building_equipmentScalarFieldEnum | Building_equipmentScalarFieldEnum[]
  }

  /**
   * building_equipment findFirstOrThrow
   */
  export type building_equipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which building_equipment to fetch.
     */
    where?: building_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of building_equipments to fetch.
     */
    orderBy?: building_equipmentOrderByWithRelationInput | building_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for building_equipments.
     */
    cursor?: building_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` building_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` building_equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of building_equipments.
     */
    distinct?: Building_equipmentScalarFieldEnum | Building_equipmentScalarFieldEnum[]
  }

  /**
   * building_equipment findMany
   */
  export type building_equipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which building_equipments to fetch.
     */
    where?: building_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of building_equipments to fetch.
     */
    orderBy?: building_equipmentOrderByWithRelationInput | building_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing building_equipments.
     */
    cursor?: building_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` building_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` building_equipments.
     */
    skip?: number
    distinct?: Building_equipmentScalarFieldEnum | Building_equipmentScalarFieldEnum[]
  }

  /**
   * building_equipment create
   */
  export type building_equipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a building_equipment.
     */
    data: XOR<building_equipmentCreateInput, building_equipmentUncheckedCreateInput>
  }

  /**
   * building_equipment createMany
   */
  export type building_equipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many building_equipments.
     */
    data: building_equipmentCreateManyInput | building_equipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * building_equipment update
   */
  export type building_equipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a building_equipment.
     */
    data: XOR<building_equipmentUpdateInput, building_equipmentUncheckedUpdateInput>
    /**
     * Choose, which building_equipment to update.
     */
    where: building_equipmentWhereUniqueInput
  }

  /**
   * building_equipment updateMany
   */
  export type building_equipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update building_equipments.
     */
    data: XOR<building_equipmentUpdateManyMutationInput, building_equipmentUncheckedUpdateManyInput>
    /**
     * Filter which building_equipments to update
     */
    where?: building_equipmentWhereInput
    /**
     * Limit how many building_equipments to update.
     */
    limit?: number
  }

  /**
   * building_equipment upsert
   */
  export type building_equipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the building_equipment to update in case it exists.
     */
    where: building_equipmentWhereUniqueInput
    /**
     * In case the building_equipment found by the `where` argument doesn't exist, create a new building_equipment with this data.
     */
    create: XOR<building_equipmentCreateInput, building_equipmentUncheckedCreateInput>
    /**
     * In case the building_equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<building_equipmentUpdateInput, building_equipmentUncheckedUpdateInput>
  }

  /**
   * building_equipment delete
   */
  export type building_equipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    /**
     * Filter which building_equipment to delete.
     */
    where: building_equipmentWhereUniqueInput
  }

  /**
   * building_equipment deleteMany
   */
  export type building_equipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which building_equipments to delete
     */
    where?: building_equipmentWhereInput
    /**
     * Limit how many building_equipments to delete.
     */
    limit?: number
  }

  /**
   * building_equipment without action
   */
  export type building_equipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
  }


  /**
   * Model disciplinaryAction
   */

  export type AggregateDisciplinaryAction = {
    _count: DisciplinaryActionCountAggregateOutputType | null
    _min: DisciplinaryActionMinAggregateOutputType | null
    _max: DisciplinaryActionMaxAggregateOutputType | null
  }

  export type DisciplinaryActionMinAggregateOutputType = {
    actionId: string | null
    actionType: string | null
    reason: string | null
    decisionDate: Date | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    severityLevel: string | null
    status: string | null
  }

  export type DisciplinaryActionMaxAggregateOutputType = {
    actionId: string | null
    actionType: string | null
    reason: string | null
    decisionDate: Date | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    severityLevel: string | null
    status: string | null
  }

  export type DisciplinaryActionCountAggregateOutputType = {
    actionId: number
    actionType: number
    reason: number
    decisionDate: number
    effectiveFrom: number
    effectiveTo: number
    severityLevel: number
    status: number
    _all: number
  }


  export type DisciplinaryActionMinAggregateInputType = {
    actionId?: true
    actionType?: true
    reason?: true
    decisionDate?: true
    effectiveFrom?: true
    effectiveTo?: true
    severityLevel?: true
    status?: true
  }

  export type DisciplinaryActionMaxAggregateInputType = {
    actionId?: true
    actionType?: true
    reason?: true
    decisionDate?: true
    effectiveFrom?: true
    effectiveTo?: true
    severityLevel?: true
    status?: true
  }

  export type DisciplinaryActionCountAggregateInputType = {
    actionId?: true
    actionType?: true
    reason?: true
    decisionDate?: true
    effectiveFrom?: true
    effectiveTo?: true
    severityLevel?: true
    status?: true
    _all?: true
  }

  export type DisciplinaryActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disciplinaryAction to aggregate.
     */
    where?: disciplinaryActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplinaryActions to fetch.
     */
    orderBy?: disciplinaryActionOrderByWithRelationInput | disciplinaryActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: disciplinaryActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplinaryActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplinaryActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned disciplinaryActions
    **/
    _count?: true | DisciplinaryActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisciplinaryActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisciplinaryActionMaxAggregateInputType
  }

  export type GetDisciplinaryActionAggregateType<T extends DisciplinaryActionAggregateArgs> = {
        [P in keyof T & keyof AggregateDisciplinaryAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisciplinaryAction[P]>
      : GetScalarType<T[P], AggregateDisciplinaryAction[P]>
  }




  export type disciplinaryActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disciplinaryActionWhereInput
    orderBy?: disciplinaryActionOrderByWithAggregationInput | disciplinaryActionOrderByWithAggregationInput[]
    by: DisciplinaryActionScalarFieldEnum[] | DisciplinaryActionScalarFieldEnum
    having?: disciplinaryActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisciplinaryActionCountAggregateInputType | true
    _min?: DisciplinaryActionMinAggregateInputType
    _max?: DisciplinaryActionMaxAggregateInputType
  }

  export type DisciplinaryActionGroupByOutputType = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date
    effectiveFrom: Date
    effectiveTo: Date | null
    severityLevel: string | null
    status: string | null
    _count: DisciplinaryActionCountAggregateOutputType | null
    _min: DisciplinaryActionMinAggregateOutputType | null
    _max: DisciplinaryActionMaxAggregateOutputType | null
  }

  type GetDisciplinaryActionGroupByPayload<T extends disciplinaryActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisciplinaryActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisciplinaryActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisciplinaryActionGroupByOutputType[P]>
            : GetScalarType<T[P], DisciplinaryActionGroupByOutputType[P]>
        }
      >
    >


  export type disciplinaryActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    actionId?: boolean
    actionType?: boolean
    reason?: boolean
    decisionDate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    severityLevel?: boolean
    status?: boolean
    disciplineStaff?: boolean | disciplinaryAction$disciplineStaffArgs<ExtArgs>
    studentDiscipline?: boolean | disciplinaryAction$studentDisciplineArgs<ExtArgs>
    _count?: boolean | DisciplinaryActionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disciplinaryAction"]>



  export type disciplinaryActionSelectScalar = {
    actionId?: boolean
    actionType?: boolean
    reason?: boolean
    decisionDate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    severityLevel?: boolean
    status?: boolean
  }

  export type disciplinaryActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"actionId" | "actionType" | "reason" | "decisionDate" | "effectiveFrom" | "effectiveTo" | "severityLevel" | "status", ExtArgs["result"]["disciplinaryAction"]>
  export type disciplinaryActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplineStaff?: boolean | disciplinaryAction$disciplineStaffArgs<ExtArgs>
    studentDiscipline?: boolean | disciplinaryAction$studentDisciplineArgs<ExtArgs>
    _count?: boolean | DisciplinaryActionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $disciplinaryActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "disciplinaryAction"
    objects: {
      disciplineStaff: Prisma.$disciplineStaffPayload<ExtArgs>[]
      studentDiscipline: Prisma.$studentDisciplinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      actionId: string
      actionType: string
      reason: string
      decisionDate: Date
      effectiveFrom: Date
      effectiveTo: Date | null
      severityLevel: string | null
      status: string | null
    }, ExtArgs["result"]["disciplinaryAction"]>
    composites: {}
  }

  type disciplinaryActionGetPayload<S extends boolean | null | undefined | disciplinaryActionDefaultArgs> = $Result.GetResult<Prisma.$disciplinaryActionPayload, S>

  type disciplinaryActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<disciplinaryActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisciplinaryActionCountAggregateInputType | true
    }

  export interface disciplinaryActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['disciplinaryAction'], meta: { name: 'disciplinaryAction' } }
    /**
     * Find zero or one DisciplinaryAction that matches the filter.
     * @param {disciplinaryActionFindUniqueArgs} args - Arguments to find a DisciplinaryAction
     * @example
     * // Get one DisciplinaryAction
     * const disciplinaryAction = await prisma.disciplinaryAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends disciplinaryActionFindUniqueArgs>(args: SelectSubset<T, disciplinaryActionFindUniqueArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisciplinaryAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {disciplinaryActionFindUniqueOrThrowArgs} args - Arguments to find a DisciplinaryAction
     * @example
     * // Get one DisciplinaryAction
     * const disciplinaryAction = await prisma.disciplinaryAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends disciplinaryActionFindUniqueOrThrowArgs>(args: SelectSubset<T, disciplinaryActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplinaryAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinaryActionFindFirstArgs} args - Arguments to find a DisciplinaryAction
     * @example
     * // Get one DisciplinaryAction
     * const disciplinaryAction = await prisma.disciplinaryAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends disciplinaryActionFindFirstArgs>(args?: SelectSubset<T, disciplinaryActionFindFirstArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplinaryAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinaryActionFindFirstOrThrowArgs} args - Arguments to find a DisciplinaryAction
     * @example
     * // Get one DisciplinaryAction
     * const disciplinaryAction = await prisma.disciplinaryAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends disciplinaryActionFindFirstOrThrowArgs>(args?: SelectSubset<T, disciplinaryActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisciplinaryActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinaryActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisciplinaryActions
     * const disciplinaryActions = await prisma.disciplinaryAction.findMany()
     * 
     * // Get first 10 DisciplinaryActions
     * const disciplinaryActions = await prisma.disciplinaryAction.findMany({ take: 10 })
     * 
     * // Only select the `actionId`
     * const disciplinaryActionWithActionIdOnly = await prisma.disciplinaryAction.findMany({ select: { actionId: true } })
     * 
     */
    findMany<T extends disciplinaryActionFindManyArgs>(args?: SelectSubset<T, disciplinaryActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisciplinaryAction.
     * @param {disciplinaryActionCreateArgs} args - Arguments to create a DisciplinaryAction.
     * @example
     * // Create one DisciplinaryAction
     * const DisciplinaryAction = await prisma.disciplinaryAction.create({
     *   data: {
     *     // ... data to create a DisciplinaryAction
     *   }
     * })
     * 
     */
    create<T extends disciplinaryActionCreateArgs>(args: SelectSubset<T, disciplinaryActionCreateArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisciplinaryActions.
     * @param {disciplinaryActionCreateManyArgs} args - Arguments to create many DisciplinaryActions.
     * @example
     * // Create many DisciplinaryActions
     * const disciplinaryAction = await prisma.disciplinaryAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends disciplinaryActionCreateManyArgs>(args?: SelectSubset<T, disciplinaryActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DisciplinaryAction.
     * @param {disciplinaryActionDeleteArgs} args - Arguments to delete one DisciplinaryAction.
     * @example
     * // Delete one DisciplinaryAction
     * const DisciplinaryAction = await prisma.disciplinaryAction.delete({
     *   where: {
     *     // ... filter to delete one DisciplinaryAction
     *   }
     * })
     * 
     */
    delete<T extends disciplinaryActionDeleteArgs>(args: SelectSubset<T, disciplinaryActionDeleteArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisciplinaryAction.
     * @param {disciplinaryActionUpdateArgs} args - Arguments to update one DisciplinaryAction.
     * @example
     * // Update one DisciplinaryAction
     * const disciplinaryAction = await prisma.disciplinaryAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends disciplinaryActionUpdateArgs>(args: SelectSubset<T, disciplinaryActionUpdateArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisciplinaryActions.
     * @param {disciplinaryActionDeleteManyArgs} args - Arguments to filter DisciplinaryActions to delete.
     * @example
     * // Delete a few DisciplinaryActions
     * const { count } = await prisma.disciplinaryAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends disciplinaryActionDeleteManyArgs>(args?: SelectSubset<T, disciplinaryActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisciplinaryActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinaryActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisciplinaryActions
     * const disciplinaryAction = await prisma.disciplinaryAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends disciplinaryActionUpdateManyArgs>(args: SelectSubset<T, disciplinaryActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisciplinaryAction.
     * @param {disciplinaryActionUpsertArgs} args - Arguments to update or create a DisciplinaryAction.
     * @example
     * // Update or create a DisciplinaryAction
     * const disciplinaryAction = await prisma.disciplinaryAction.upsert({
     *   create: {
     *     // ... data to create a DisciplinaryAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisciplinaryAction we want to update
     *   }
     * })
     */
    upsert<T extends disciplinaryActionUpsertArgs>(args: SelectSubset<T, disciplinaryActionUpsertArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisciplinaryActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinaryActionCountArgs} args - Arguments to filter DisciplinaryActions to count.
     * @example
     * // Count the number of DisciplinaryActions
     * const count = await prisma.disciplinaryAction.count({
     *   where: {
     *     // ... the filter for the DisciplinaryActions we want to count
     *   }
     * })
    **/
    count<T extends disciplinaryActionCountArgs>(
      args?: Subset<T, disciplinaryActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisciplinaryActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisciplinaryAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisciplinaryActionAggregateArgs>(args: Subset<T, DisciplinaryActionAggregateArgs>): Prisma.PrismaPromise<GetDisciplinaryActionAggregateType<T>>

    /**
     * Group by DisciplinaryAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinaryActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends disciplinaryActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: disciplinaryActionGroupByArgs['orderBy'] }
        : { orderBy?: disciplinaryActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, disciplinaryActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisciplinaryActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the disciplinaryAction model
   */
  readonly fields: disciplinaryActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for disciplinaryAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__disciplinaryActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    disciplineStaff<T extends disciplinaryAction$disciplineStaffArgs<ExtArgs> = {}>(args?: Subset<T, disciplinaryAction$disciplineStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentDiscipline<T extends disciplinaryAction$studentDisciplineArgs<ExtArgs> = {}>(args?: Subset<T, disciplinaryAction$studentDisciplineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the disciplinaryAction model
   */
  interface disciplinaryActionFieldRefs {
    readonly actionId: FieldRef<"disciplinaryAction", 'String'>
    readonly actionType: FieldRef<"disciplinaryAction", 'String'>
    readonly reason: FieldRef<"disciplinaryAction", 'String'>
    readonly decisionDate: FieldRef<"disciplinaryAction", 'DateTime'>
    readonly effectiveFrom: FieldRef<"disciplinaryAction", 'DateTime'>
    readonly effectiveTo: FieldRef<"disciplinaryAction", 'DateTime'>
    readonly severityLevel: FieldRef<"disciplinaryAction", 'String'>
    readonly status: FieldRef<"disciplinaryAction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * disciplinaryAction findUnique
   */
  export type disciplinaryActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * Filter, which disciplinaryAction to fetch.
     */
    where: disciplinaryActionWhereUniqueInput
  }

  /**
   * disciplinaryAction findUniqueOrThrow
   */
  export type disciplinaryActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * Filter, which disciplinaryAction to fetch.
     */
    where: disciplinaryActionWhereUniqueInput
  }

  /**
   * disciplinaryAction findFirst
   */
  export type disciplinaryActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * Filter, which disciplinaryAction to fetch.
     */
    where?: disciplinaryActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplinaryActions to fetch.
     */
    orderBy?: disciplinaryActionOrderByWithRelationInput | disciplinaryActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disciplinaryActions.
     */
    cursor?: disciplinaryActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplinaryActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplinaryActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disciplinaryActions.
     */
    distinct?: DisciplinaryActionScalarFieldEnum | DisciplinaryActionScalarFieldEnum[]
  }

  /**
   * disciplinaryAction findFirstOrThrow
   */
  export type disciplinaryActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * Filter, which disciplinaryAction to fetch.
     */
    where?: disciplinaryActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplinaryActions to fetch.
     */
    orderBy?: disciplinaryActionOrderByWithRelationInput | disciplinaryActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disciplinaryActions.
     */
    cursor?: disciplinaryActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplinaryActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplinaryActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disciplinaryActions.
     */
    distinct?: DisciplinaryActionScalarFieldEnum | DisciplinaryActionScalarFieldEnum[]
  }

  /**
   * disciplinaryAction findMany
   */
  export type disciplinaryActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * Filter, which disciplinaryActions to fetch.
     */
    where?: disciplinaryActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplinaryActions to fetch.
     */
    orderBy?: disciplinaryActionOrderByWithRelationInput | disciplinaryActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing disciplinaryActions.
     */
    cursor?: disciplinaryActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplinaryActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplinaryActions.
     */
    skip?: number
    distinct?: DisciplinaryActionScalarFieldEnum | DisciplinaryActionScalarFieldEnum[]
  }

  /**
   * disciplinaryAction create
   */
  export type disciplinaryActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * The data needed to create a disciplinaryAction.
     */
    data: XOR<disciplinaryActionCreateInput, disciplinaryActionUncheckedCreateInput>
  }

  /**
   * disciplinaryAction createMany
   */
  export type disciplinaryActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many disciplinaryActions.
     */
    data: disciplinaryActionCreateManyInput | disciplinaryActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * disciplinaryAction update
   */
  export type disciplinaryActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * The data needed to update a disciplinaryAction.
     */
    data: XOR<disciplinaryActionUpdateInput, disciplinaryActionUncheckedUpdateInput>
    /**
     * Choose, which disciplinaryAction to update.
     */
    where: disciplinaryActionWhereUniqueInput
  }

  /**
   * disciplinaryAction updateMany
   */
  export type disciplinaryActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update disciplinaryActions.
     */
    data: XOR<disciplinaryActionUpdateManyMutationInput, disciplinaryActionUncheckedUpdateManyInput>
    /**
     * Filter which disciplinaryActions to update
     */
    where?: disciplinaryActionWhereInput
    /**
     * Limit how many disciplinaryActions to update.
     */
    limit?: number
  }

  /**
   * disciplinaryAction upsert
   */
  export type disciplinaryActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * The filter to search for the disciplinaryAction to update in case it exists.
     */
    where: disciplinaryActionWhereUniqueInput
    /**
     * In case the disciplinaryAction found by the `where` argument doesn't exist, create a new disciplinaryAction with this data.
     */
    create: XOR<disciplinaryActionCreateInput, disciplinaryActionUncheckedCreateInput>
    /**
     * In case the disciplinaryAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<disciplinaryActionUpdateInput, disciplinaryActionUncheckedUpdateInput>
  }

  /**
   * disciplinaryAction delete
   */
  export type disciplinaryActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
    /**
     * Filter which disciplinaryAction to delete.
     */
    where: disciplinaryActionWhereUniqueInput
  }

  /**
   * disciplinaryAction deleteMany
   */
  export type disciplinaryActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disciplinaryActions to delete
     */
    where?: disciplinaryActionWhereInput
    /**
     * Limit how many disciplinaryActions to delete.
     */
    limit?: number
  }

  /**
   * disciplinaryAction.disciplineStaff
   */
  export type disciplinaryAction$disciplineStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    where?: disciplineStaffWhereInput
    orderBy?: disciplineStaffOrderByWithRelationInput | disciplineStaffOrderByWithRelationInput[]
    cursor?: disciplineStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisciplineStaffScalarFieldEnum | DisciplineStaffScalarFieldEnum[]
  }

  /**
   * disciplinaryAction.studentDiscipline
   */
  export type disciplinaryAction$studentDisciplineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    where?: studentDisciplineWhereInput
    orderBy?: studentDisciplineOrderByWithRelationInput | studentDisciplineOrderByWithRelationInput[]
    cursor?: studentDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentDisciplineScalarFieldEnum | StudentDisciplineScalarFieldEnum[]
  }

  /**
   * disciplinaryAction without action
   */
  export type disciplinaryActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplinaryAction
     */
    select?: disciplinaryActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplinaryAction
     */
    omit?: disciplinaryActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinaryActionInclude<ExtArgs> | null
  }


  /**
   * Model disciplineStaff
   */

  export type AggregateDisciplineStaff = {
    _count: DisciplineStaffCountAggregateOutputType | null
    _min: DisciplineStaffMinAggregateOutputType | null
    _max: DisciplineStaffMaxAggregateOutputType | null
  }

  export type DisciplineStaffMinAggregateOutputType = {
    actionId: string | null
    essn: string | null
  }

  export type DisciplineStaffMaxAggregateOutputType = {
    actionId: string | null
    essn: string | null
  }

  export type DisciplineStaffCountAggregateOutputType = {
    actionId: number
    essn: number
    _all: number
  }


  export type DisciplineStaffMinAggregateInputType = {
    actionId?: true
    essn?: true
  }

  export type DisciplineStaffMaxAggregateInputType = {
    actionId?: true
    essn?: true
  }

  export type DisciplineStaffCountAggregateInputType = {
    actionId?: true
    essn?: true
    _all?: true
  }

  export type DisciplineStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disciplineStaff to aggregate.
     */
    where?: disciplineStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplineStaffs to fetch.
     */
    orderBy?: disciplineStaffOrderByWithRelationInput | disciplineStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: disciplineStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplineStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplineStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned disciplineStaffs
    **/
    _count?: true | DisciplineStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisciplineStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisciplineStaffMaxAggregateInputType
  }

  export type GetDisciplineStaffAggregateType<T extends DisciplineStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateDisciplineStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisciplineStaff[P]>
      : GetScalarType<T[P], AggregateDisciplineStaff[P]>
  }




  export type disciplineStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disciplineStaffWhereInput
    orderBy?: disciplineStaffOrderByWithAggregationInput | disciplineStaffOrderByWithAggregationInput[]
    by: DisciplineStaffScalarFieldEnum[] | DisciplineStaffScalarFieldEnum
    having?: disciplineStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisciplineStaffCountAggregateInputType | true
    _min?: DisciplineStaffMinAggregateInputType
    _max?: DisciplineStaffMaxAggregateInputType
  }

  export type DisciplineStaffGroupByOutputType = {
    actionId: string
    essn: string
    _count: DisciplineStaffCountAggregateOutputType | null
    _min: DisciplineStaffMinAggregateOutputType | null
    _max: DisciplineStaffMaxAggregateOutputType | null
  }

  type GetDisciplineStaffGroupByPayload<T extends disciplineStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisciplineStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisciplineStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisciplineStaffGroupByOutputType[P]>
            : GetScalarType<T[P], DisciplineStaffGroupByOutputType[P]>
        }
      >
    >


  export type disciplineStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    actionId?: boolean
    essn?: boolean
    disciplinaryAction?: boolean | disciplinaryActionDefaultArgs<ExtArgs>
    manager_employee?: boolean | manager_employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disciplineStaff"]>



  export type disciplineStaffSelectScalar = {
    actionId?: boolean
    essn?: boolean
  }

  export type disciplineStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"actionId" | "essn", ExtArgs["result"]["disciplineStaff"]>
  export type disciplineStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplinaryAction?: boolean | disciplinaryActionDefaultArgs<ExtArgs>
    manager_employee?: boolean | manager_employeeDefaultArgs<ExtArgs>
  }

  export type $disciplineStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "disciplineStaff"
    objects: {
      disciplinaryAction: Prisma.$disciplinaryActionPayload<ExtArgs>
      manager_employee: Prisma.$manager_employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      actionId: string
      essn: string
    }, ExtArgs["result"]["disciplineStaff"]>
    composites: {}
  }

  type disciplineStaffGetPayload<S extends boolean | null | undefined | disciplineStaffDefaultArgs> = $Result.GetResult<Prisma.$disciplineStaffPayload, S>

  type disciplineStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<disciplineStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisciplineStaffCountAggregateInputType | true
    }

  export interface disciplineStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['disciplineStaff'], meta: { name: 'disciplineStaff' } }
    /**
     * Find zero or one DisciplineStaff that matches the filter.
     * @param {disciplineStaffFindUniqueArgs} args - Arguments to find a DisciplineStaff
     * @example
     * // Get one DisciplineStaff
     * const disciplineStaff = await prisma.disciplineStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends disciplineStaffFindUniqueArgs>(args: SelectSubset<T, disciplineStaffFindUniqueArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisciplineStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {disciplineStaffFindUniqueOrThrowArgs} args - Arguments to find a DisciplineStaff
     * @example
     * // Get one DisciplineStaff
     * const disciplineStaff = await prisma.disciplineStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends disciplineStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, disciplineStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplineStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplineStaffFindFirstArgs} args - Arguments to find a DisciplineStaff
     * @example
     * // Get one DisciplineStaff
     * const disciplineStaff = await prisma.disciplineStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends disciplineStaffFindFirstArgs>(args?: SelectSubset<T, disciplineStaffFindFirstArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplineStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplineStaffFindFirstOrThrowArgs} args - Arguments to find a DisciplineStaff
     * @example
     * // Get one DisciplineStaff
     * const disciplineStaff = await prisma.disciplineStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends disciplineStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, disciplineStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisciplineStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplineStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisciplineStaffs
     * const disciplineStaffs = await prisma.disciplineStaff.findMany()
     * 
     * // Get first 10 DisciplineStaffs
     * const disciplineStaffs = await prisma.disciplineStaff.findMany({ take: 10 })
     * 
     * // Only select the `actionId`
     * const disciplineStaffWithActionIdOnly = await prisma.disciplineStaff.findMany({ select: { actionId: true } })
     * 
     */
    findMany<T extends disciplineStaffFindManyArgs>(args?: SelectSubset<T, disciplineStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisciplineStaff.
     * @param {disciplineStaffCreateArgs} args - Arguments to create a DisciplineStaff.
     * @example
     * // Create one DisciplineStaff
     * const DisciplineStaff = await prisma.disciplineStaff.create({
     *   data: {
     *     // ... data to create a DisciplineStaff
     *   }
     * })
     * 
     */
    create<T extends disciplineStaffCreateArgs>(args: SelectSubset<T, disciplineStaffCreateArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisciplineStaffs.
     * @param {disciplineStaffCreateManyArgs} args - Arguments to create many DisciplineStaffs.
     * @example
     * // Create many DisciplineStaffs
     * const disciplineStaff = await prisma.disciplineStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends disciplineStaffCreateManyArgs>(args?: SelectSubset<T, disciplineStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DisciplineStaff.
     * @param {disciplineStaffDeleteArgs} args - Arguments to delete one DisciplineStaff.
     * @example
     * // Delete one DisciplineStaff
     * const DisciplineStaff = await prisma.disciplineStaff.delete({
     *   where: {
     *     // ... filter to delete one DisciplineStaff
     *   }
     * })
     * 
     */
    delete<T extends disciplineStaffDeleteArgs>(args: SelectSubset<T, disciplineStaffDeleteArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisciplineStaff.
     * @param {disciplineStaffUpdateArgs} args - Arguments to update one DisciplineStaff.
     * @example
     * // Update one DisciplineStaff
     * const disciplineStaff = await prisma.disciplineStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends disciplineStaffUpdateArgs>(args: SelectSubset<T, disciplineStaffUpdateArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisciplineStaffs.
     * @param {disciplineStaffDeleteManyArgs} args - Arguments to filter DisciplineStaffs to delete.
     * @example
     * // Delete a few DisciplineStaffs
     * const { count } = await prisma.disciplineStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends disciplineStaffDeleteManyArgs>(args?: SelectSubset<T, disciplineStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisciplineStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplineStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisciplineStaffs
     * const disciplineStaff = await prisma.disciplineStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends disciplineStaffUpdateManyArgs>(args: SelectSubset<T, disciplineStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisciplineStaff.
     * @param {disciplineStaffUpsertArgs} args - Arguments to update or create a DisciplineStaff.
     * @example
     * // Update or create a DisciplineStaff
     * const disciplineStaff = await prisma.disciplineStaff.upsert({
     *   create: {
     *     // ... data to create a DisciplineStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisciplineStaff we want to update
     *   }
     * })
     */
    upsert<T extends disciplineStaffUpsertArgs>(args: SelectSubset<T, disciplineStaffUpsertArgs<ExtArgs>>): Prisma__disciplineStaffClient<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisciplineStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplineStaffCountArgs} args - Arguments to filter DisciplineStaffs to count.
     * @example
     * // Count the number of DisciplineStaffs
     * const count = await prisma.disciplineStaff.count({
     *   where: {
     *     // ... the filter for the DisciplineStaffs we want to count
     *   }
     * })
    **/
    count<T extends disciplineStaffCountArgs>(
      args?: Subset<T, disciplineStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisciplineStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisciplineStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisciplineStaffAggregateArgs>(args: Subset<T, DisciplineStaffAggregateArgs>): Prisma.PrismaPromise<GetDisciplineStaffAggregateType<T>>

    /**
     * Group by DisciplineStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplineStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends disciplineStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: disciplineStaffGroupByArgs['orderBy'] }
        : { orderBy?: disciplineStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, disciplineStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisciplineStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the disciplineStaff model
   */
  readonly fields: disciplineStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for disciplineStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__disciplineStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    disciplinaryAction<T extends disciplinaryActionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, disciplinaryActionDefaultArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager_employee<T extends manager_employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, manager_employeeDefaultArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the disciplineStaff model
   */
  interface disciplineStaffFieldRefs {
    readonly actionId: FieldRef<"disciplineStaff", 'String'>
    readonly essn: FieldRef<"disciplineStaff", 'String'>
  }
    

  // Custom InputTypes
  /**
   * disciplineStaff findUnique
   */
  export type disciplineStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * Filter, which disciplineStaff to fetch.
     */
    where: disciplineStaffWhereUniqueInput
  }

  /**
   * disciplineStaff findUniqueOrThrow
   */
  export type disciplineStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * Filter, which disciplineStaff to fetch.
     */
    where: disciplineStaffWhereUniqueInput
  }

  /**
   * disciplineStaff findFirst
   */
  export type disciplineStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * Filter, which disciplineStaff to fetch.
     */
    where?: disciplineStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplineStaffs to fetch.
     */
    orderBy?: disciplineStaffOrderByWithRelationInput | disciplineStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disciplineStaffs.
     */
    cursor?: disciplineStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplineStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplineStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disciplineStaffs.
     */
    distinct?: DisciplineStaffScalarFieldEnum | DisciplineStaffScalarFieldEnum[]
  }

  /**
   * disciplineStaff findFirstOrThrow
   */
  export type disciplineStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * Filter, which disciplineStaff to fetch.
     */
    where?: disciplineStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplineStaffs to fetch.
     */
    orderBy?: disciplineStaffOrderByWithRelationInput | disciplineStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disciplineStaffs.
     */
    cursor?: disciplineStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplineStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplineStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disciplineStaffs.
     */
    distinct?: DisciplineStaffScalarFieldEnum | DisciplineStaffScalarFieldEnum[]
  }

  /**
   * disciplineStaff findMany
   */
  export type disciplineStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * Filter, which disciplineStaffs to fetch.
     */
    where?: disciplineStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplineStaffs to fetch.
     */
    orderBy?: disciplineStaffOrderByWithRelationInput | disciplineStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing disciplineStaffs.
     */
    cursor?: disciplineStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplineStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplineStaffs.
     */
    skip?: number
    distinct?: DisciplineStaffScalarFieldEnum | DisciplineStaffScalarFieldEnum[]
  }

  /**
   * disciplineStaff create
   */
  export type disciplineStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a disciplineStaff.
     */
    data: XOR<disciplineStaffCreateInput, disciplineStaffUncheckedCreateInput>
  }

  /**
   * disciplineStaff createMany
   */
  export type disciplineStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many disciplineStaffs.
     */
    data: disciplineStaffCreateManyInput | disciplineStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * disciplineStaff update
   */
  export type disciplineStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a disciplineStaff.
     */
    data: XOR<disciplineStaffUpdateInput, disciplineStaffUncheckedUpdateInput>
    /**
     * Choose, which disciplineStaff to update.
     */
    where: disciplineStaffWhereUniqueInput
  }

  /**
   * disciplineStaff updateMany
   */
  export type disciplineStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update disciplineStaffs.
     */
    data: XOR<disciplineStaffUpdateManyMutationInput, disciplineStaffUncheckedUpdateManyInput>
    /**
     * Filter which disciplineStaffs to update
     */
    where?: disciplineStaffWhereInput
    /**
     * Limit how many disciplineStaffs to update.
     */
    limit?: number
  }

  /**
   * disciplineStaff upsert
   */
  export type disciplineStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the disciplineStaff to update in case it exists.
     */
    where: disciplineStaffWhereUniqueInput
    /**
     * In case the disciplineStaff found by the `where` argument doesn't exist, create a new disciplineStaff with this data.
     */
    create: XOR<disciplineStaffCreateInput, disciplineStaffUncheckedCreateInput>
    /**
     * In case the disciplineStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<disciplineStaffUpdateInput, disciplineStaffUncheckedUpdateInput>
  }

  /**
   * disciplineStaff delete
   */
  export type disciplineStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    /**
     * Filter which disciplineStaff to delete.
     */
    where: disciplineStaffWhereUniqueInput
  }

  /**
   * disciplineStaff deleteMany
   */
  export type disciplineStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disciplineStaffs to delete
     */
    where?: disciplineStaffWhereInput
    /**
     * Limit how many disciplineStaffs to delete.
     */
    limit?: number
  }

  /**
   * disciplineStaff without action
   */
  export type disciplineStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
  }


  /**
   * Model employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    salary: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    salary: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    essn: string | null
    salary: Decimal | null
    empId: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    essn: string | null
    salary: Decimal | null
    empId: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    essn: number
    salary: number
    empId: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    salary?: true
  }

  export type EmployeeSumAggregateInputType = {
    salary?: true
  }

  export type EmployeeMinAggregateInputType = {
    essn?: true
    salary?: true
    empId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    essn?: true
    salary?: true
    empId?: true
  }

  export type EmployeeCountAggregateInputType = {
    essn?: true
    salary?: true
    empId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee to aggregate.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithAggregationInput | employeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    essn: string
    salary: Decimal | null
    empId: string | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    essn?: boolean
    salary?: boolean
    empId?: boolean
    Employee_Card?: boolean | employee$Employee_CardArgs<ExtArgs>
    People?: boolean | PeopleDefaultArgs<ExtArgs>
    manager_employee?: boolean | employee$manager_employeeArgs<ExtArgs>
    medical_employee?: boolean | employee$medical_employeeArgs<ExtArgs>
    other_employee?: boolean | employee$other_employeeArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type employeeSelectScalar = {
    essn?: boolean
    salary?: boolean
    empId?: boolean
  }

  export type employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"essn" | "salary" | "empId", ExtArgs["result"]["employee"]>
  export type employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee_Card?: boolean | employee$Employee_CardArgs<ExtArgs>
    People?: boolean | PeopleDefaultArgs<ExtArgs>
    manager_employee?: boolean | employee$manager_employeeArgs<ExtArgs>
    medical_employee?: boolean | employee$medical_employeeArgs<ExtArgs>
    other_employee?: boolean | employee$other_employeeArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee"
    objects: {
      Employee_Card: Prisma.$Employee_CardPayload<ExtArgs>[]
      People: Prisma.$PeoplePayload<ExtArgs>
      manager_employee: Prisma.$manager_employeePayload<ExtArgs> | null
      medical_employee: Prisma.$medical_employeePayload<ExtArgs> | null
      other_employee: Prisma.$other_employeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      essn: string
      salary: Prisma.Decimal | null
      empId: string | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type employeeGetPayload<S extends boolean | null | undefined | employeeDefaultArgs> = $Result.GetResult<Prisma.$employeePayload, S>

  type employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee'], meta: { name: 'employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {employeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeFindUniqueArgs>(args: SelectSubset<T, employeeFindUniqueArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeFindFirstArgs>(args?: SelectSubset<T, employeeFindFirstArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `essn`
     * const employeeWithEssnOnly = await prisma.employee.findMany({ select: { essn: true } })
     * 
     */
    findMany<T extends employeeFindManyArgs>(args?: SelectSubset<T, employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {employeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends employeeCreateArgs>(args: SelectSubset<T, employeeCreateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeCreateManyArgs>(args?: SelectSubset<T, employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {employeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends employeeDeleteArgs>(args: SelectSubset<T, employeeDeleteArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {employeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeUpdateArgs>(args: SelectSubset<T, employeeUpdateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeDeleteManyArgs>(args?: SelectSubset<T, employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeUpdateManyArgs>(args: SelectSubset<T, employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {employeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends employeeUpsertArgs>(args: SelectSubset<T, employeeUpsertArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeeCountArgs>(
      args?: Subset<T, employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeGroupByArgs['orderBy'] }
        : { orderBy?: employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee model
   */
  readonly fields: employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee_Card<T extends employee$Employee_CardArgs<ExtArgs> = {}>(args?: Subset<T, employee$Employee_CardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Employee_CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    People<T extends PeopleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeopleDefaultArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager_employee<T extends employee$manager_employeeArgs<ExtArgs> = {}>(args?: Subset<T, employee$manager_employeeArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    medical_employee<T extends employee$medical_employeeArgs<ExtArgs> = {}>(args?: Subset<T, employee$medical_employeeArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_employee<T extends employee$other_employeeArgs<ExtArgs> = {}>(args?: Subset<T, employee$other_employeeArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee model
   */
  interface employeeFieldRefs {
    readonly essn: FieldRef<"employee", 'String'>
    readonly salary: FieldRef<"employee", 'Decimal'>
    readonly empId: FieldRef<"employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * employee findUnique
   */
  export type employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findUniqueOrThrow
   */
  export type employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findFirst
   */
  export type employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findFirstOrThrow
   */
  export type employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findMany
   */
  export type employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee create
   */
  export type employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a employee.
     */
    data: XOR<employeeCreateInput, employeeUncheckedCreateInput>
  }

  /**
   * employee createMany
   */
  export type employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee update
   */
  export type employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a employee.
     */
    data: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
    /**
     * Choose, which employee to update.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee updateMany
   */
  export type employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employee upsert
   */
  export type employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the employee to update in case it exists.
     */
    where: employeeWhereUniqueInput
    /**
     * In case the employee found by the `where` argument doesn't exist, create a new employee with this data.
     */
    create: XOR<employeeCreateInput, employeeUncheckedCreateInput>
    /**
     * In case the employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
  }

  /**
   * employee delete
   */
  export type employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter which employee to delete.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee deleteMany
   */
  export type employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employee.Employee_Card
   */
  export type employee$Employee_CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee_Card
     */
    select?: Employee_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee_Card
     */
    omit?: Employee_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Employee_CardInclude<ExtArgs> | null
    where?: Employee_CardWhereInput
    orderBy?: Employee_CardOrderByWithRelationInput | Employee_CardOrderByWithRelationInput[]
    cursor?: Employee_CardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_CardScalarFieldEnum | Employee_CardScalarFieldEnum[]
  }

  /**
   * employee.manager_employee
   */
  export type employee$manager_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    where?: manager_employeeWhereInput
  }

  /**
   * employee.medical_employee
   */
  export type employee$medical_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    where?: medical_employeeWhereInput
  }

  /**
   * employee.other_employee
   */
  export type employee$other_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    where?: other_employeeWhereInput
  }

  /**
   * employee without action
   */
  export type employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
  }


  /**
   * Model health_room
   */

  export type AggregateHealth_room = {
    _count: Health_roomCountAggregateOutputType | null
    _avg: Health_roomAvgAggregateOutputType | null
    _sum: Health_roomSumAggregateOutputType | null
    _min: Health_roomMinAggregateOutputType | null
    _max: Health_roomMaxAggregateOutputType | null
  }

  export type Health_roomAvgAggregateOutputType = {
    num_of_staff: number | null
  }

  export type Health_roomSumAggregateOutputType = {
    num_of_staff: number | null
  }

  export type Health_roomMinAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    num_of_staff: number | null
    start_time: Date | null
    end_time: Date | null
    equipment_status: $Enums.health_room_equipment_status | null
  }

  export type Health_roomMaxAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    num_of_staff: number | null
    start_time: Date | null
    end_time: Date | null
    equipment_status: $Enums.health_room_equipment_status | null
  }

  export type Health_roomCountAggregateOutputType = {
    building_id: number
    room_id: number
    num_of_staff: number
    start_time: number
    end_time: number
    equipment_status: number
    _all: number
  }


  export type Health_roomAvgAggregateInputType = {
    num_of_staff?: true
  }

  export type Health_roomSumAggregateInputType = {
    num_of_staff?: true
  }

  export type Health_roomMinAggregateInputType = {
    building_id?: true
    room_id?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
    equipment_status?: true
  }

  export type Health_roomMaxAggregateInputType = {
    building_id?: true
    room_id?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
    equipment_status?: true
  }

  export type Health_roomCountAggregateInputType = {
    building_id?: true
    room_id?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
    equipment_status?: true
    _all?: true
  }

  export type Health_roomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which health_room to aggregate.
     */
    where?: health_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_rooms to fetch.
     */
    orderBy?: health_roomOrderByWithRelationInput | health_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: health_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned health_rooms
    **/
    _count?: true | Health_roomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Health_roomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Health_roomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Health_roomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Health_roomMaxAggregateInputType
  }

  export type GetHealth_roomAggregateType<T extends Health_roomAggregateArgs> = {
        [P in keyof T & keyof AggregateHealth_room]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealth_room[P]>
      : GetScalarType<T[P], AggregateHealth_room[P]>
  }




  export type health_roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: health_roomWhereInput
    orderBy?: health_roomOrderByWithAggregationInput | health_roomOrderByWithAggregationInput[]
    by: Health_roomScalarFieldEnum[] | Health_roomScalarFieldEnum
    having?: health_roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Health_roomCountAggregateInputType | true
    _avg?: Health_roomAvgAggregateInputType
    _sum?: Health_roomSumAggregateInputType
    _min?: Health_roomMinAggregateInputType
    _max?: Health_roomMaxAggregateInputType
  }

  export type Health_roomGroupByOutputType = {
    building_id: string
    room_id: string
    num_of_staff: number
    start_time: Date
    end_time: Date
    equipment_status: $Enums.health_room_equipment_status
    _count: Health_roomCountAggregateOutputType | null
    _avg: Health_roomAvgAggregateOutputType | null
    _sum: Health_roomSumAggregateOutputType | null
    _min: Health_roomMinAggregateOutputType | null
    _max: Health_roomMaxAggregateOutputType | null
  }

  type GetHealth_roomGroupByPayload<T extends health_roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Health_roomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Health_roomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Health_roomGroupByOutputType[P]>
            : GetScalarType<T[P], Health_roomGroupByOutputType[P]>
        }
      >
    >


  export type health_roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    building_id?: boolean
    room_id?: boolean
    num_of_staff?: boolean
    start_time?: boolean
    end_time?: boolean
    equipment_status?: boolean
    room?: boolean | roomDefaultArgs<ExtArgs>
    medical_employee?: boolean | health_room$medical_employeeArgs<ExtArgs>
    _count?: boolean | Health_roomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["health_room"]>



  export type health_roomSelectScalar = {
    building_id?: boolean
    room_id?: boolean
    num_of_staff?: boolean
    start_time?: boolean
    end_time?: boolean
    equipment_status?: boolean
  }

  export type health_roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"building_id" | "room_id" | "num_of_staff" | "start_time" | "end_time" | "equipment_status", ExtArgs["result"]["health_room"]>
  export type health_roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | roomDefaultArgs<ExtArgs>
    medical_employee?: boolean | health_room$medical_employeeArgs<ExtArgs>
    _count?: boolean | Health_roomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $health_roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "health_room"
    objects: {
      room: Prisma.$roomPayload<ExtArgs>
      medical_employee: Prisma.$medical_employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      building_id: string
      room_id: string
      num_of_staff: number
      start_time: Date
      end_time: Date
      equipment_status: $Enums.health_room_equipment_status
    }, ExtArgs["result"]["health_room"]>
    composites: {}
  }

  type health_roomGetPayload<S extends boolean | null | undefined | health_roomDefaultArgs> = $Result.GetResult<Prisma.$health_roomPayload, S>

  type health_roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<health_roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Health_roomCountAggregateInputType | true
    }

  export interface health_roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['health_room'], meta: { name: 'health_room' } }
    /**
     * Find zero or one Health_room that matches the filter.
     * @param {health_roomFindUniqueArgs} args - Arguments to find a Health_room
     * @example
     * // Get one Health_room
     * const health_room = await prisma.health_room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends health_roomFindUniqueArgs>(args: SelectSubset<T, health_roomFindUniqueArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Health_room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {health_roomFindUniqueOrThrowArgs} args - Arguments to find a Health_room
     * @example
     * // Get one Health_room
     * const health_room = await prisma.health_room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends health_roomFindUniqueOrThrowArgs>(args: SelectSubset<T, health_roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Health_room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_roomFindFirstArgs} args - Arguments to find a Health_room
     * @example
     * // Get one Health_room
     * const health_room = await prisma.health_room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends health_roomFindFirstArgs>(args?: SelectSubset<T, health_roomFindFirstArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Health_room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_roomFindFirstOrThrowArgs} args - Arguments to find a Health_room
     * @example
     * // Get one Health_room
     * const health_room = await prisma.health_room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends health_roomFindFirstOrThrowArgs>(args?: SelectSubset<T, health_roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Health_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Health_rooms
     * const health_rooms = await prisma.health_room.findMany()
     * 
     * // Get first 10 Health_rooms
     * const health_rooms = await prisma.health_room.findMany({ take: 10 })
     * 
     * // Only select the `building_id`
     * const health_roomWithBuilding_idOnly = await prisma.health_room.findMany({ select: { building_id: true } })
     * 
     */
    findMany<T extends health_roomFindManyArgs>(args?: SelectSubset<T, health_roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Health_room.
     * @param {health_roomCreateArgs} args - Arguments to create a Health_room.
     * @example
     * // Create one Health_room
     * const Health_room = await prisma.health_room.create({
     *   data: {
     *     // ... data to create a Health_room
     *   }
     * })
     * 
     */
    create<T extends health_roomCreateArgs>(args: SelectSubset<T, health_roomCreateArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Health_rooms.
     * @param {health_roomCreateManyArgs} args - Arguments to create many Health_rooms.
     * @example
     * // Create many Health_rooms
     * const health_room = await prisma.health_room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends health_roomCreateManyArgs>(args?: SelectSubset<T, health_roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Health_room.
     * @param {health_roomDeleteArgs} args - Arguments to delete one Health_room.
     * @example
     * // Delete one Health_room
     * const Health_room = await prisma.health_room.delete({
     *   where: {
     *     // ... filter to delete one Health_room
     *   }
     * })
     * 
     */
    delete<T extends health_roomDeleteArgs>(args: SelectSubset<T, health_roomDeleteArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Health_room.
     * @param {health_roomUpdateArgs} args - Arguments to update one Health_room.
     * @example
     * // Update one Health_room
     * const health_room = await prisma.health_room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends health_roomUpdateArgs>(args: SelectSubset<T, health_roomUpdateArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Health_rooms.
     * @param {health_roomDeleteManyArgs} args - Arguments to filter Health_rooms to delete.
     * @example
     * // Delete a few Health_rooms
     * const { count } = await prisma.health_room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends health_roomDeleteManyArgs>(args?: SelectSubset<T, health_roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Health_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Health_rooms
     * const health_room = await prisma.health_room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends health_roomUpdateManyArgs>(args: SelectSubset<T, health_roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Health_room.
     * @param {health_roomUpsertArgs} args - Arguments to update or create a Health_room.
     * @example
     * // Update or create a Health_room
     * const health_room = await prisma.health_room.upsert({
     *   create: {
     *     // ... data to create a Health_room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Health_room we want to update
     *   }
     * })
     */
    upsert<T extends health_roomUpsertArgs>(args: SelectSubset<T, health_roomUpsertArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Health_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_roomCountArgs} args - Arguments to filter Health_rooms to count.
     * @example
     * // Count the number of Health_rooms
     * const count = await prisma.health_room.count({
     *   where: {
     *     // ... the filter for the Health_rooms we want to count
     *   }
     * })
    **/
    count<T extends health_roomCountArgs>(
      args?: Subset<T, health_roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Health_roomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Health_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Health_roomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Health_roomAggregateArgs>(args: Subset<T, Health_roomAggregateArgs>): Prisma.PrismaPromise<GetHealth_roomAggregateType<T>>

    /**
     * Group by Health_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends health_roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: health_roomGroupByArgs['orderBy'] }
        : { orderBy?: health_roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, health_roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealth_roomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the health_room model
   */
  readonly fields: health_roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for health_room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__health_roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roomDefaultArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medical_employee<T extends health_room$medical_employeeArgs<ExtArgs> = {}>(args?: Subset<T, health_room$medical_employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the health_room model
   */
  interface health_roomFieldRefs {
    readonly building_id: FieldRef<"health_room", 'String'>
    readonly room_id: FieldRef<"health_room", 'String'>
    readonly num_of_staff: FieldRef<"health_room", 'Int'>
    readonly start_time: FieldRef<"health_room", 'DateTime'>
    readonly end_time: FieldRef<"health_room", 'DateTime'>
    readonly equipment_status: FieldRef<"health_room", 'health_room_equipment_status'>
  }
    

  // Custom InputTypes
  /**
   * health_room findUnique
   */
  export type health_roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * Filter, which health_room to fetch.
     */
    where: health_roomWhereUniqueInput
  }

  /**
   * health_room findUniqueOrThrow
   */
  export type health_roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * Filter, which health_room to fetch.
     */
    where: health_roomWhereUniqueInput
  }

  /**
   * health_room findFirst
   */
  export type health_roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * Filter, which health_room to fetch.
     */
    where?: health_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_rooms to fetch.
     */
    orderBy?: health_roomOrderByWithRelationInput | health_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for health_rooms.
     */
    cursor?: health_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of health_rooms.
     */
    distinct?: Health_roomScalarFieldEnum | Health_roomScalarFieldEnum[]
  }

  /**
   * health_room findFirstOrThrow
   */
  export type health_roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * Filter, which health_room to fetch.
     */
    where?: health_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_rooms to fetch.
     */
    orderBy?: health_roomOrderByWithRelationInput | health_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for health_rooms.
     */
    cursor?: health_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of health_rooms.
     */
    distinct?: Health_roomScalarFieldEnum | Health_roomScalarFieldEnum[]
  }

  /**
   * health_room findMany
   */
  export type health_roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * Filter, which health_rooms to fetch.
     */
    where?: health_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_rooms to fetch.
     */
    orderBy?: health_roomOrderByWithRelationInput | health_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing health_rooms.
     */
    cursor?: health_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_rooms.
     */
    skip?: number
    distinct?: Health_roomScalarFieldEnum | Health_roomScalarFieldEnum[]
  }

  /**
   * health_room create
   */
  export type health_roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * The data needed to create a health_room.
     */
    data: XOR<health_roomCreateInput, health_roomUncheckedCreateInput>
  }

  /**
   * health_room createMany
   */
  export type health_roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many health_rooms.
     */
    data: health_roomCreateManyInput | health_roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * health_room update
   */
  export type health_roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * The data needed to update a health_room.
     */
    data: XOR<health_roomUpdateInput, health_roomUncheckedUpdateInput>
    /**
     * Choose, which health_room to update.
     */
    where: health_roomWhereUniqueInput
  }

  /**
   * health_room updateMany
   */
  export type health_roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update health_rooms.
     */
    data: XOR<health_roomUpdateManyMutationInput, health_roomUncheckedUpdateManyInput>
    /**
     * Filter which health_rooms to update
     */
    where?: health_roomWhereInput
    /**
     * Limit how many health_rooms to update.
     */
    limit?: number
  }

  /**
   * health_room upsert
   */
  export type health_roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * The filter to search for the health_room to update in case it exists.
     */
    where: health_roomWhereUniqueInput
    /**
     * In case the health_room found by the `where` argument doesn't exist, create a new health_room with this data.
     */
    create: XOR<health_roomCreateInput, health_roomUncheckedCreateInput>
    /**
     * In case the health_room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<health_roomUpdateInput, health_roomUncheckedUpdateInput>
  }

  /**
   * health_room delete
   */
  export type health_roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    /**
     * Filter which health_room to delete.
     */
    where: health_roomWhereUniqueInput
  }

  /**
   * health_room deleteMany
   */
  export type health_roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which health_rooms to delete
     */
    where?: health_roomWhereInput
    /**
     * Limit how many health_rooms to delete.
     */
    limit?: number
  }

  /**
   * health_room.medical_employee
   */
  export type health_room$medical_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    where?: medical_employeeWhereInput
    orderBy?: medical_employeeOrderByWithRelationInput | medical_employeeOrderByWithRelationInput[]
    cursor?: medical_employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medical_employeeScalarFieldEnum | Medical_employeeScalarFieldEnum[]
  }

  /**
   * health_room without action
   */
  export type health_roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
  }


  /**
   * Model large_equipment
   */

  export type AggregateLarge_equipment = {
    _count: Large_equipmentCountAggregateOutputType | null
    _min: Large_equipmentMinAggregateOutputType | null
    _max: Large_equipmentMaxAggregateOutputType | null
  }

  export type Large_equipmentMinAggregateOutputType = {
    equipment_id: string | null
    equipment_name: string | null
    equipment_type: string | null
    equipment_status: $Enums.large_equipment_equipment_status | null
    purchase_date: Date | null
    purchase_location: string | null
  }

  export type Large_equipmentMaxAggregateOutputType = {
    equipment_id: string | null
    equipment_name: string | null
    equipment_type: string | null
    equipment_status: $Enums.large_equipment_equipment_status | null
    purchase_date: Date | null
    purchase_location: string | null
  }

  export type Large_equipmentCountAggregateOutputType = {
    equipment_id: number
    equipment_name: number
    equipment_type: number
    equipment_status: number
    purchase_date: number
    purchase_location: number
    _all: number
  }


  export type Large_equipmentMinAggregateInputType = {
    equipment_id?: true
    equipment_name?: true
    equipment_type?: true
    equipment_status?: true
    purchase_date?: true
    purchase_location?: true
  }

  export type Large_equipmentMaxAggregateInputType = {
    equipment_id?: true
    equipment_name?: true
    equipment_type?: true
    equipment_status?: true
    purchase_date?: true
    purchase_location?: true
  }

  export type Large_equipmentCountAggregateInputType = {
    equipment_id?: true
    equipment_name?: true
    equipment_type?: true
    equipment_status?: true
    purchase_date?: true
    purchase_location?: true
    _all?: true
  }

  export type Large_equipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which large_equipment to aggregate.
     */
    where?: large_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of large_equipments to fetch.
     */
    orderBy?: large_equipmentOrderByWithRelationInput | large_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: large_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` large_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` large_equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned large_equipments
    **/
    _count?: true | Large_equipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Large_equipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Large_equipmentMaxAggregateInputType
  }

  export type GetLarge_equipmentAggregateType<T extends Large_equipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateLarge_equipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLarge_equipment[P]>
      : GetScalarType<T[P], AggregateLarge_equipment[P]>
  }




  export type large_equipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: large_equipmentWhereInput
    orderBy?: large_equipmentOrderByWithAggregationInput | large_equipmentOrderByWithAggregationInput[]
    by: Large_equipmentScalarFieldEnum[] | Large_equipmentScalarFieldEnum
    having?: large_equipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Large_equipmentCountAggregateInputType | true
    _min?: Large_equipmentMinAggregateInputType
    _max?: Large_equipmentMaxAggregateInputType
  }

  export type Large_equipmentGroupByOutputType = {
    equipment_id: string
    equipment_name: string
    equipment_type: string
    equipment_status: $Enums.large_equipment_equipment_status
    purchase_date: Date
    purchase_location: string | null
    _count: Large_equipmentCountAggregateOutputType | null
    _min: Large_equipmentMinAggregateOutputType | null
    _max: Large_equipmentMaxAggregateOutputType | null
  }

  type GetLarge_equipmentGroupByPayload<T extends large_equipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Large_equipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Large_equipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Large_equipmentGroupByOutputType[P]>
            : GetScalarType<T[P], Large_equipmentGroupByOutputType[P]>
        }
      >
    >


  export type large_equipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipment_id?: boolean
    equipment_name?: boolean
    equipment_type?: boolean
    equipment_status?: boolean
    purchase_date?: boolean
    purchase_location?: boolean
    building_equipment?: boolean | large_equipment$building_equipmentArgs<ExtArgs>
    _count?: boolean | Large_equipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["large_equipment"]>



  export type large_equipmentSelectScalar = {
    equipment_id?: boolean
    equipment_name?: boolean
    equipment_type?: boolean
    equipment_status?: boolean
    purchase_date?: boolean
    purchase_location?: boolean
  }

  export type large_equipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"equipment_id" | "equipment_name" | "equipment_type" | "equipment_status" | "purchase_date" | "purchase_location", ExtArgs["result"]["large_equipment"]>
  export type large_equipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building_equipment?: boolean | large_equipment$building_equipmentArgs<ExtArgs>
    _count?: boolean | Large_equipmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $large_equipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "large_equipment"
    objects: {
      building_equipment: Prisma.$building_equipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      equipment_id: string
      equipment_name: string
      equipment_type: string
      equipment_status: $Enums.large_equipment_equipment_status
      purchase_date: Date
      purchase_location: string | null
    }, ExtArgs["result"]["large_equipment"]>
    composites: {}
  }

  type large_equipmentGetPayload<S extends boolean | null | undefined | large_equipmentDefaultArgs> = $Result.GetResult<Prisma.$large_equipmentPayload, S>

  type large_equipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<large_equipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Large_equipmentCountAggregateInputType | true
    }

  export interface large_equipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['large_equipment'], meta: { name: 'large_equipment' } }
    /**
     * Find zero or one Large_equipment that matches the filter.
     * @param {large_equipmentFindUniqueArgs} args - Arguments to find a Large_equipment
     * @example
     * // Get one Large_equipment
     * const large_equipment = await prisma.large_equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends large_equipmentFindUniqueArgs>(args: SelectSubset<T, large_equipmentFindUniqueArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Large_equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {large_equipmentFindUniqueOrThrowArgs} args - Arguments to find a Large_equipment
     * @example
     * // Get one Large_equipment
     * const large_equipment = await prisma.large_equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends large_equipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, large_equipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Large_equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {large_equipmentFindFirstArgs} args - Arguments to find a Large_equipment
     * @example
     * // Get one Large_equipment
     * const large_equipment = await prisma.large_equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends large_equipmentFindFirstArgs>(args?: SelectSubset<T, large_equipmentFindFirstArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Large_equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {large_equipmentFindFirstOrThrowArgs} args - Arguments to find a Large_equipment
     * @example
     * // Get one Large_equipment
     * const large_equipment = await prisma.large_equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends large_equipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, large_equipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Large_equipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {large_equipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Large_equipments
     * const large_equipments = await prisma.large_equipment.findMany()
     * 
     * // Get first 10 Large_equipments
     * const large_equipments = await prisma.large_equipment.findMany({ take: 10 })
     * 
     * // Only select the `equipment_id`
     * const large_equipmentWithEquipment_idOnly = await prisma.large_equipment.findMany({ select: { equipment_id: true } })
     * 
     */
    findMany<T extends large_equipmentFindManyArgs>(args?: SelectSubset<T, large_equipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Large_equipment.
     * @param {large_equipmentCreateArgs} args - Arguments to create a Large_equipment.
     * @example
     * // Create one Large_equipment
     * const Large_equipment = await prisma.large_equipment.create({
     *   data: {
     *     // ... data to create a Large_equipment
     *   }
     * })
     * 
     */
    create<T extends large_equipmentCreateArgs>(args: SelectSubset<T, large_equipmentCreateArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Large_equipments.
     * @param {large_equipmentCreateManyArgs} args - Arguments to create many Large_equipments.
     * @example
     * // Create many Large_equipments
     * const large_equipment = await prisma.large_equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends large_equipmentCreateManyArgs>(args?: SelectSubset<T, large_equipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Large_equipment.
     * @param {large_equipmentDeleteArgs} args - Arguments to delete one Large_equipment.
     * @example
     * // Delete one Large_equipment
     * const Large_equipment = await prisma.large_equipment.delete({
     *   where: {
     *     // ... filter to delete one Large_equipment
     *   }
     * })
     * 
     */
    delete<T extends large_equipmentDeleteArgs>(args: SelectSubset<T, large_equipmentDeleteArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Large_equipment.
     * @param {large_equipmentUpdateArgs} args - Arguments to update one Large_equipment.
     * @example
     * // Update one Large_equipment
     * const large_equipment = await prisma.large_equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends large_equipmentUpdateArgs>(args: SelectSubset<T, large_equipmentUpdateArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Large_equipments.
     * @param {large_equipmentDeleteManyArgs} args - Arguments to filter Large_equipments to delete.
     * @example
     * // Delete a few Large_equipments
     * const { count } = await prisma.large_equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends large_equipmentDeleteManyArgs>(args?: SelectSubset<T, large_equipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Large_equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {large_equipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Large_equipments
     * const large_equipment = await prisma.large_equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends large_equipmentUpdateManyArgs>(args: SelectSubset<T, large_equipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Large_equipment.
     * @param {large_equipmentUpsertArgs} args - Arguments to update or create a Large_equipment.
     * @example
     * // Update or create a Large_equipment
     * const large_equipment = await prisma.large_equipment.upsert({
     *   create: {
     *     // ... data to create a Large_equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Large_equipment we want to update
     *   }
     * })
     */
    upsert<T extends large_equipmentUpsertArgs>(args: SelectSubset<T, large_equipmentUpsertArgs<ExtArgs>>): Prisma__large_equipmentClient<$Result.GetResult<Prisma.$large_equipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Large_equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {large_equipmentCountArgs} args - Arguments to filter Large_equipments to count.
     * @example
     * // Count the number of Large_equipments
     * const count = await prisma.large_equipment.count({
     *   where: {
     *     // ... the filter for the Large_equipments we want to count
     *   }
     * })
    **/
    count<T extends large_equipmentCountArgs>(
      args?: Subset<T, large_equipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Large_equipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Large_equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Large_equipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Large_equipmentAggregateArgs>(args: Subset<T, Large_equipmentAggregateArgs>): Prisma.PrismaPromise<GetLarge_equipmentAggregateType<T>>

    /**
     * Group by Large_equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {large_equipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends large_equipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: large_equipmentGroupByArgs['orderBy'] }
        : { orderBy?: large_equipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, large_equipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLarge_equipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the large_equipment model
   */
  readonly fields: large_equipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for large_equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__large_equipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building_equipment<T extends large_equipment$building_equipmentArgs<ExtArgs> = {}>(args?: Subset<T, large_equipment$building_equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$building_equipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the large_equipment model
   */
  interface large_equipmentFieldRefs {
    readonly equipment_id: FieldRef<"large_equipment", 'String'>
    readonly equipment_name: FieldRef<"large_equipment", 'String'>
    readonly equipment_type: FieldRef<"large_equipment", 'String'>
    readonly equipment_status: FieldRef<"large_equipment", 'large_equipment_equipment_status'>
    readonly purchase_date: FieldRef<"large_equipment", 'DateTime'>
    readonly purchase_location: FieldRef<"large_equipment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * large_equipment findUnique
   */
  export type large_equipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which large_equipment to fetch.
     */
    where: large_equipmentWhereUniqueInput
  }

  /**
   * large_equipment findUniqueOrThrow
   */
  export type large_equipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which large_equipment to fetch.
     */
    where: large_equipmentWhereUniqueInput
  }

  /**
   * large_equipment findFirst
   */
  export type large_equipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which large_equipment to fetch.
     */
    where?: large_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of large_equipments to fetch.
     */
    orderBy?: large_equipmentOrderByWithRelationInput | large_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for large_equipments.
     */
    cursor?: large_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` large_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` large_equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of large_equipments.
     */
    distinct?: Large_equipmentScalarFieldEnum | Large_equipmentScalarFieldEnum[]
  }

  /**
   * large_equipment findFirstOrThrow
   */
  export type large_equipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which large_equipment to fetch.
     */
    where?: large_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of large_equipments to fetch.
     */
    orderBy?: large_equipmentOrderByWithRelationInput | large_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for large_equipments.
     */
    cursor?: large_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` large_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` large_equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of large_equipments.
     */
    distinct?: Large_equipmentScalarFieldEnum | Large_equipmentScalarFieldEnum[]
  }

  /**
   * large_equipment findMany
   */
  export type large_equipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * Filter, which large_equipments to fetch.
     */
    where?: large_equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of large_equipments to fetch.
     */
    orderBy?: large_equipmentOrderByWithRelationInput | large_equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing large_equipments.
     */
    cursor?: large_equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` large_equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` large_equipments.
     */
    skip?: number
    distinct?: Large_equipmentScalarFieldEnum | Large_equipmentScalarFieldEnum[]
  }

  /**
   * large_equipment create
   */
  export type large_equipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a large_equipment.
     */
    data: XOR<large_equipmentCreateInput, large_equipmentUncheckedCreateInput>
  }

  /**
   * large_equipment createMany
   */
  export type large_equipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many large_equipments.
     */
    data: large_equipmentCreateManyInput | large_equipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * large_equipment update
   */
  export type large_equipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a large_equipment.
     */
    data: XOR<large_equipmentUpdateInput, large_equipmentUncheckedUpdateInput>
    /**
     * Choose, which large_equipment to update.
     */
    where: large_equipmentWhereUniqueInput
  }

  /**
   * large_equipment updateMany
   */
  export type large_equipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update large_equipments.
     */
    data: XOR<large_equipmentUpdateManyMutationInput, large_equipmentUncheckedUpdateManyInput>
    /**
     * Filter which large_equipments to update
     */
    where?: large_equipmentWhereInput
    /**
     * Limit how many large_equipments to update.
     */
    limit?: number
  }

  /**
   * large_equipment upsert
   */
  export type large_equipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the large_equipment to update in case it exists.
     */
    where: large_equipmentWhereUniqueInput
    /**
     * In case the large_equipment found by the `where` argument doesn't exist, create a new large_equipment with this data.
     */
    create: XOR<large_equipmentCreateInput, large_equipmentUncheckedCreateInput>
    /**
     * In case the large_equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<large_equipmentUpdateInput, large_equipmentUncheckedUpdateInput>
  }

  /**
   * large_equipment delete
   */
  export type large_equipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
    /**
     * Filter which large_equipment to delete.
     */
    where: large_equipmentWhereUniqueInput
  }

  /**
   * large_equipment deleteMany
   */
  export type large_equipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which large_equipments to delete
     */
    where?: large_equipmentWhereInput
    /**
     * Limit how many large_equipments to delete.
     */
    limit?: number
  }

  /**
   * large_equipment.building_equipment
   */
  export type large_equipment$building_equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building_equipment
     */
    select?: building_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building_equipment
     */
    omit?: building_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: building_equipmentInclude<ExtArgs> | null
    where?: building_equipmentWhereInput
    orderBy?: building_equipmentOrderByWithRelationInput | building_equipmentOrderByWithRelationInput[]
    cursor?: building_equipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Building_equipmentScalarFieldEnum | Building_equipmentScalarFieldEnum[]
  }

  /**
   * large_equipment without action
   */
  export type large_equipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the large_equipment
     */
    select?: large_equipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the large_equipment
     */
    omit?: large_equipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: large_equipmentInclude<ExtArgs> | null
  }


  /**
   * Model living_room
   */

  export type AggregateLiving_room = {
    _count: Living_roomCountAggregateOutputType | null
    _avg: Living_roomAvgAggregateOutputType | null
    _sum: Living_roomSumAggregateOutputType | null
    _min: Living_roomMinAggregateOutputType | null
    _max: Living_roomMaxAggregateOutputType | null
  }

  export type Living_roomAvgAggregateOutputType = {
    max_num_of_students: number | null
    current_num_of_students: number | null
    rental_price: Decimal | null
    occupancy_rate: Decimal | null
  }

  export type Living_roomSumAggregateOutputType = {
    max_num_of_students: number | null
    current_num_of_students: number | null
    rental_price: Decimal | null
    occupancy_rate: Decimal | null
  }

  export type Living_roomMinAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    max_num_of_students: number | null
    current_num_of_students: number | null
    rental_price: Decimal | null
    occupancy_rate: Decimal | null
  }

  export type Living_roomMaxAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    max_num_of_students: number | null
    current_num_of_students: number | null
    rental_price: Decimal | null
    occupancy_rate: Decimal | null
  }

  export type Living_roomCountAggregateOutputType = {
    building_id: number
    room_id: number
    max_num_of_students: number
    current_num_of_students: number
    rental_price: number
    occupancy_rate: number
    _all: number
  }


  export type Living_roomAvgAggregateInputType = {
    max_num_of_students?: true
    current_num_of_students?: true
    rental_price?: true
    occupancy_rate?: true
  }

  export type Living_roomSumAggregateInputType = {
    max_num_of_students?: true
    current_num_of_students?: true
    rental_price?: true
    occupancy_rate?: true
  }

  export type Living_roomMinAggregateInputType = {
    building_id?: true
    room_id?: true
    max_num_of_students?: true
    current_num_of_students?: true
    rental_price?: true
    occupancy_rate?: true
  }

  export type Living_roomMaxAggregateInputType = {
    building_id?: true
    room_id?: true
    max_num_of_students?: true
    current_num_of_students?: true
    rental_price?: true
    occupancy_rate?: true
  }

  export type Living_roomCountAggregateInputType = {
    building_id?: true
    room_id?: true
    max_num_of_students?: true
    current_num_of_students?: true
    rental_price?: true
    occupancy_rate?: true
    _all?: true
  }

  export type Living_roomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which living_room to aggregate.
     */
    where?: living_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of living_rooms to fetch.
     */
    orderBy?: living_roomOrderByWithRelationInput | living_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: living_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` living_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` living_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned living_rooms
    **/
    _count?: true | Living_roomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Living_roomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Living_roomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Living_roomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Living_roomMaxAggregateInputType
  }

  export type GetLiving_roomAggregateType<T extends Living_roomAggregateArgs> = {
        [P in keyof T & keyof AggregateLiving_room]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiving_room[P]>
      : GetScalarType<T[P], AggregateLiving_room[P]>
  }




  export type living_roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: living_roomWhereInput
    orderBy?: living_roomOrderByWithAggregationInput | living_roomOrderByWithAggregationInput[]
    by: Living_roomScalarFieldEnum[] | Living_roomScalarFieldEnum
    having?: living_roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Living_roomCountAggregateInputType | true
    _avg?: Living_roomAvgAggregateInputType
    _sum?: Living_roomSumAggregateInputType
    _min?: Living_roomMinAggregateInputType
    _max?: Living_roomMaxAggregateInputType
  }

  export type Living_roomGroupByOutputType = {
    building_id: string
    room_id: string
    max_num_of_students: number
    current_num_of_students: number
    rental_price: Decimal
    occupancy_rate: Decimal
    _count: Living_roomCountAggregateOutputType | null
    _avg: Living_roomAvgAggregateOutputType | null
    _sum: Living_roomSumAggregateOutputType | null
    _min: Living_roomMinAggregateOutputType | null
    _max: Living_roomMaxAggregateOutputType | null
  }

  type GetLiving_roomGroupByPayload<T extends living_roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Living_roomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Living_roomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Living_roomGroupByOutputType[P]>
            : GetScalarType<T[P], Living_roomGroupByOutputType[P]>
        }
      >
    >


  export type living_roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    building_id?: boolean
    room_id?: boolean
    max_num_of_students?: boolean
    current_num_of_students?: boolean
    rental_price?: boolean
    occupancy_rate?: boolean
    student?: boolean | living_room$studentArgs<ExtArgs>
    _count?: boolean | Living_roomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["living_room"]>



  export type living_roomSelectScalar = {
    building_id?: boolean
    room_id?: boolean
    max_num_of_students?: boolean
    current_num_of_students?: boolean
    rental_price?: boolean
    occupancy_rate?: boolean
  }

  export type living_roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"building_id" | "room_id" | "max_num_of_students" | "current_num_of_students" | "rental_price" | "occupancy_rate", ExtArgs["result"]["living_room"]>
  export type living_roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | living_room$studentArgs<ExtArgs>
    _count?: boolean | Living_roomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $living_roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "living_room"
    objects: {
      student: Prisma.$studentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      building_id: string
      room_id: string
      max_num_of_students: number
      current_num_of_students: number
      rental_price: Prisma.Decimal
      occupancy_rate: Prisma.Decimal
    }, ExtArgs["result"]["living_room"]>
    composites: {}
  }

  type living_roomGetPayload<S extends boolean | null | undefined | living_roomDefaultArgs> = $Result.GetResult<Prisma.$living_roomPayload, S>

  type living_roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<living_roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Living_roomCountAggregateInputType | true
    }

  export interface living_roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['living_room'], meta: { name: 'living_room' } }
    /**
     * Find zero or one Living_room that matches the filter.
     * @param {living_roomFindUniqueArgs} args - Arguments to find a Living_room
     * @example
     * // Get one Living_room
     * const living_room = await prisma.living_room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends living_roomFindUniqueArgs>(args: SelectSubset<T, living_roomFindUniqueArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Living_room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {living_roomFindUniqueOrThrowArgs} args - Arguments to find a Living_room
     * @example
     * // Get one Living_room
     * const living_room = await prisma.living_room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends living_roomFindUniqueOrThrowArgs>(args: SelectSubset<T, living_roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Living_room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {living_roomFindFirstArgs} args - Arguments to find a Living_room
     * @example
     * // Get one Living_room
     * const living_room = await prisma.living_room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends living_roomFindFirstArgs>(args?: SelectSubset<T, living_roomFindFirstArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Living_room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {living_roomFindFirstOrThrowArgs} args - Arguments to find a Living_room
     * @example
     * // Get one Living_room
     * const living_room = await prisma.living_room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends living_roomFindFirstOrThrowArgs>(args?: SelectSubset<T, living_roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Living_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {living_roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Living_rooms
     * const living_rooms = await prisma.living_room.findMany()
     * 
     * // Get first 10 Living_rooms
     * const living_rooms = await prisma.living_room.findMany({ take: 10 })
     * 
     * // Only select the `building_id`
     * const living_roomWithBuilding_idOnly = await prisma.living_room.findMany({ select: { building_id: true } })
     * 
     */
    findMany<T extends living_roomFindManyArgs>(args?: SelectSubset<T, living_roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Living_room.
     * @param {living_roomCreateArgs} args - Arguments to create a Living_room.
     * @example
     * // Create one Living_room
     * const Living_room = await prisma.living_room.create({
     *   data: {
     *     // ... data to create a Living_room
     *   }
     * })
     * 
     */
    create<T extends living_roomCreateArgs>(args: SelectSubset<T, living_roomCreateArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Living_rooms.
     * @param {living_roomCreateManyArgs} args - Arguments to create many Living_rooms.
     * @example
     * // Create many Living_rooms
     * const living_room = await prisma.living_room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends living_roomCreateManyArgs>(args?: SelectSubset<T, living_roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Living_room.
     * @param {living_roomDeleteArgs} args - Arguments to delete one Living_room.
     * @example
     * // Delete one Living_room
     * const Living_room = await prisma.living_room.delete({
     *   where: {
     *     // ... filter to delete one Living_room
     *   }
     * })
     * 
     */
    delete<T extends living_roomDeleteArgs>(args: SelectSubset<T, living_roomDeleteArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Living_room.
     * @param {living_roomUpdateArgs} args - Arguments to update one Living_room.
     * @example
     * // Update one Living_room
     * const living_room = await prisma.living_room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends living_roomUpdateArgs>(args: SelectSubset<T, living_roomUpdateArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Living_rooms.
     * @param {living_roomDeleteManyArgs} args - Arguments to filter Living_rooms to delete.
     * @example
     * // Delete a few Living_rooms
     * const { count } = await prisma.living_room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends living_roomDeleteManyArgs>(args?: SelectSubset<T, living_roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Living_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {living_roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Living_rooms
     * const living_room = await prisma.living_room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends living_roomUpdateManyArgs>(args: SelectSubset<T, living_roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Living_room.
     * @param {living_roomUpsertArgs} args - Arguments to update or create a Living_room.
     * @example
     * // Update or create a Living_room
     * const living_room = await prisma.living_room.upsert({
     *   create: {
     *     // ... data to create a Living_room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Living_room we want to update
     *   }
     * })
     */
    upsert<T extends living_roomUpsertArgs>(args: SelectSubset<T, living_roomUpsertArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Living_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {living_roomCountArgs} args - Arguments to filter Living_rooms to count.
     * @example
     * // Count the number of Living_rooms
     * const count = await prisma.living_room.count({
     *   where: {
     *     // ... the filter for the Living_rooms we want to count
     *   }
     * })
    **/
    count<T extends living_roomCountArgs>(
      args?: Subset<T, living_roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Living_roomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Living_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Living_roomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Living_roomAggregateArgs>(args: Subset<T, Living_roomAggregateArgs>): Prisma.PrismaPromise<GetLiving_roomAggregateType<T>>

    /**
     * Group by Living_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {living_roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends living_roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: living_roomGroupByArgs['orderBy'] }
        : { orderBy?: living_roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, living_roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiving_roomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the living_room model
   */
  readonly fields: living_roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for living_room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__living_roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends living_room$studentArgs<ExtArgs> = {}>(args?: Subset<T, living_room$studentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the living_room model
   */
  interface living_roomFieldRefs {
    readonly building_id: FieldRef<"living_room", 'String'>
    readonly room_id: FieldRef<"living_room", 'String'>
    readonly max_num_of_students: FieldRef<"living_room", 'Int'>
    readonly current_num_of_students: FieldRef<"living_room", 'Int'>
    readonly rental_price: FieldRef<"living_room", 'Decimal'>
    readonly occupancy_rate: FieldRef<"living_room", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * living_room findUnique
   */
  export type living_roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * Filter, which living_room to fetch.
     */
    where: living_roomWhereUniqueInput
  }

  /**
   * living_room findUniqueOrThrow
   */
  export type living_roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * Filter, which living_room to fetch.
     */
    where: living_roomWhereUniqueInput
  }

  /**
   * living_room findFirst
   */
  export type living_roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * Filter, which living_room to fetch.
     */
    where?: living_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of living_rooms to fetch.
     */
    orderBy?: living_roomOrderByWithRelationInput | living_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for living_rooms.
     */
    cursor?: living_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` living_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` living_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of living_rooms.
     */
    distinct?: Living_roomScalarFieldEnum | Living_roomScalarFieldEnum[]
  }

  /**
   * living_room findFirstOrThrow
   */
  export type living_roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * Filter, which living_room to fetch.
     */
    where?: living_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of living_rooms to fetch.
     */
    orderBy?: living_roomOrderByWithRelationInput | living_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for living_rooms.
     */
    cursor?: living_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` living_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` living_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of living_rooms.
     */
    distinct?: Living_roomScalarFieldEnum | Living_roomScalarFieldEnum[]
  }

  /**
   * living_room findMany
   */
  export type living_roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * Filter, which living_rooms to fetch.
     */
    where?: living_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of living_rooms to fetch.
     */
    orderBy?: living_roomOrderByWithRelationInput | living_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing living_rooms.
     */
    cursor?: living_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` living_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` living_rooms.
     */
    skip?: number
    distinct?: Living_roomScalarFieldEnum | Living_roomScalarFieldEnum[]
  }

  /**
   * living_room create
   */
  export type living_roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * The data needed to create a living_room.
     */
    data: XOR<living_roomCreateInput, living_roomUncheckedCreateInput>
  }

  /**
   * living_room createMany
   */
  export type living_roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many living_rooms.
     */
    data: living_roomCreateManyInput | living_roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * living_room update
   */
  export type living_roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * The data needed to update a living_room.
     */
    data: XOR<living_roomUpdateInput, living_roomUncheckedUpdateInput>
    /**
     * Choose, which living_room to update.
     */
    where: living_roomWhereUniqueInput
  }

  /**
   * living_room updateMany
   */
  export type living_roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update living_rooms.
     */
    data: XOR<living_roomUpdateManyMutationInput, living_roomUncheckedUpdateManyInput>
    /**
     * Filter which living_rooms to update
     */
    where?: living_roomWhereInput
    /**
     * Limit how many living_rooms to update.
     */
    limit?: number
  }

  /**
   * living_room upsert
   */
  export type living_roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * The filter to search for the living_room to update in case it exists.
     */
    where: living_roomWhereUniqueInput
    /**
     * In case the living_room found by the `where` argument doesn't exist, create a new living_room with this data.
     */
    create: XOR<living_roomCreateInput, living_roomUncheckedCreateInput>
    /**
     * In case the living_room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<living_roomUpdateInput, living_roomUncheckedUpdateInput>
  }

  /**
   * living_room delete
   */
  export type living_roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    /**
     * Filter which living_room to delete.
     */
    where: living_roomWhereUniqueInput
  }

  /**
   * living_room deleteMany
   */
  export type living_roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which living_rooms to delete
     */
    where?: living_roomWhereInput
    /**
     * Limit how many living_rooms to delete.
     */
    limit?: number
  }

  /**
   * living_room.student
   */
  export type living_room$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    cursor?: studentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * living_room without action
   */
  export type living_roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
  }


  /**
   * Model management_room
   */

  export type AggregateManagement_room = {
    _count: Management_roomCountAggregateOutputType | null
    _avg: Management_roomAvgAggregateOutputType | null
    _sum: Management_roomSumAggregateOutputType | null
    _min: Management_roomMinAggregateOutputType | null
    _max: Management_roomMaxAggregateOutputType | null
  }

  export type Management_roomAvgAggregateOutputType = {
    num_of_staff: number | null
  }

  export type Management_roomSumAggregateOutputType = {
    num_of_staff: number | null
  }

  export type Management_roomMinAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    num_of_staff: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Management_roomMaxAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    num_of_staff: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Management_roomCountAggregateOutputType = {
    building_id: number
    room_id: number
    num_of_staff: number
    start_time: number
    end_time: number
    _all: number
  }


  export type Management_roomAvgAggregateInputType = {
    num_of_staff?: true
  }

  export type Management_roomSumAggregateInputType = {
    num_of_staff?: true
  }

  export type Management_roomMinAggregateInputType = {
    building_id?: true
    room_id?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
  }

  export type Management_roomMaxAggregateInputType = {
    building_id?: true
    room_id?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
  }

  export type Management_roomCountAggregateInputType = {
    building_id?: true
    room_id?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type Management_roomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which management_room to aggregate.
     */
    where?: management_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of management_rooms to fetch.
     */
    orderBy?: management_roomOrderByWithRelationInput | management_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: management_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` management_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` management_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned management_rooms
    **/
    _count?: true | Management_roomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Management_roomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Management_roomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Management_roomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Management_roomMaxAggregateInputType
  }

  export type GetManagement_roomAggregateType<T extends Management_roomAggregateArgs> = {
        [P in keyof T & keyof AggregateManagement_room]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManagement_room[P]>
      : GetScalarType<T[P], AggregateManagement_room[P]>
  }




  export type management_roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: management_roomWhereInput
    orderBy?: management_roomOrderByWithAggregationInput | management_roomOrderByWithAggregationInput[]
    by: Management_roomScalarFieldEnum[] | Management_roomScalarFieldEnum
    having?: management_roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Management_roomCountAggregateInputType | true
    _avg?: Management_roomAvgAggregateInputType
    _sum?: Management_roomSumAggregateInputType
    _min?: Management_roomMinAggregateInputType
    _max?: Management_roomMaxAggregateInputType
  }

  export type Management_roomGroupByOutputType = {
    building_id: string
    room_id: string
    num_of_staff: number
    start_time: Date
    end_time: Date
    _count: Management_roomCountAggregateOutputType | null
    _avg: Management_roomAvgAggregateOutputType | null
    _sum: Management_roomSumAggregateOutputType | null
    _min: Management_roomMinAggregateOutputType | null
    _max: Management_roomMaxAggregateOutputType | null
  }

  type GetManagement_roomGroupByPayload<T extends management_roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Management_roomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Management_roomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Management_roomGroupByOutputType[P]>
            : GetScalarType<T[P], Management_roomGroupByOutputType[P]>
        }
      >
    >


  export type management_roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    building_id?: boolean
    room_id?: boolean
    num_of_staff?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean | roomDefaultArgs<ExtArgs>
    manager_employee?: boolean | management_room$manager_employeeArgs<ExtArgs>
    _count?: boolean | Management_roomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["management_room"]>



  export type management_roomSelectScalar = {
    building_id?: boolean
    room_id?: boolean
    num_of_staff?: boolean
    start_time?: boolean
    end_time?: boolean
  }

  export type management_roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"building_id" | "room_id" | "num_of_staff" | "start_time" | "end_time", ExtArgs["result"]["management_room"]>
  export type management_roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | roomDefaultArgs<ExtArgs>
    manager_employee?: boolean | management_room$manager_employeeArgs<ExtArgs>
    _count?: boolean | Management_roomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $management_roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "management_room"
    objects: {
      room: Prisma.$roomPayload<ExtArgs>
      manager_employee: Prisma.$manager_employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      building_id: string
      room_id: string
      num_of_staff: number
      start_time: Date
      end_time: Date
    }, ExtArgs["result"]["management_room"]>
    composites: {}
  }

  type management_roomGetPayload<S extends boolean | null | undefined | management_roomDefaultArgs> = $Result.GetResult<Prisma.$management_roomPayload, S>

  type management_roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<management_roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Management_roomCountAggregateInputType | true
    }

  export interface management_roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['management_room'], meta: { name: 'management_room' } }
    /**
     * Find zero or one Management_room that matches the filter.
     * @param {management_roomFindUniqueArgs} args - Arguments to find a Management_room
     * @example
     * // Get one Management_room
     * const management_room = await prisma.management_room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends management_roomFindUniqueArgs>(args: SelectSubset<T, management_roomFindUniqueArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Management_room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {management_roomFindUniqueOrThrowArgs} args - Arguments to find a Management_room
     * @example
     * // Get one Management_room
     * const management_room = await prisma.management_room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends management_roomFindUniqueOrThrowArgs>(args: SelectSubset<T, management_roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Management_room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {management_roomFindFirstArgs} args - Arguments to find a Management_room
     * @example
     * // Get one Management_room
     * const management_room = await prisma.management_room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends management_roomFindFirstArgs>(args?: SelectSubset<T, management_roomFindFirstArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Management_room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {management_roomFindFirstOrThrowArgs} args - Arguments to find a Management_room
     * @example
     * // Get one Management_room
     * const management_room = await prisma.management_room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends management_roomFindFirstOrThrowArgs>(args?: SelectSubset<T, management_roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Management_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {management_roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Management_rooms
     * const management_rooms = await prisma.management_room.findMany()
     * 
     * // Get first 10 Management_rooms
     * const management_rooms = await prisma.management_room.findMany({ take: 10 })
     * 
     * // Only select the `building_id`
     * const management_roomWithBuilding_idOnly = await prisma.management_room.findMany({ select: { building_id: true } })
     * 
     */
    findMany<T extends management_roomFindManyArgs>(args?: SelectSubset<T, management_roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Management_room.
     * @param {management_roomCreateArgs} args - Arguments to create a Management_room.
     * @example
     * // Create one Management_room
     * const Management_room = await prisma.management_room.create({
     *   data: {
     *     // ... data to create a Management_room
     *   }
     * })
     * 
     */
    create<T extends management_roomCreateArgs>(args: SelectSubset<T, management_roomCreateArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Management_rooms.
     * @param {management_roomCreateManyArgs} args - Arguments to create many Management_rooms.
     * @example
     * // Create many Management_rooms
     * const management_room = await prisma.management_room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends management_roomCreateManyArgs>(args?: SelectSubset<T, management_roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Management_room.
     * @param {management_roomDeleteArgs} args - Arguments to delete one Management_room.
     * @example
     * // Delete one Management_room
     * const Management_room = await prisma.management_room.delete({
     *   where: {
     *     // ... filter to delete one Management_room
     *   }
     * })
     * 
     */
    delete<T extends management_roomDeleteArgs>(args: SelectSubset<T, management_roomDeleteArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Management_room.
     * @param {management_roomUpdateArgs} args - Arguments to update one Management_room.
     * @example
     * // Update one Management_room
     * const management_room = await prisma.management_room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends management_roomUpdateArgs>(args: SelectSubset<T, management_roomUpdateArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Management_rooms.
     * @param {management_roomDeleteManyArgs} args - Arguments to filter Management_rooms to delete.
     * @example
     * // Delete a few Management_rooms
     * const { count } = await prisma.management_room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends management_roomDeleteManyArgs>(args?: SelectSubset<T, management_roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Management_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {management_roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Management_rooms
     * const management_room = await prisma.management_room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends management_roomUpdateManyArgs>(args: SelectSubset<T, management_roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Management_room.
     * @param {management_roomUpsertArgs} args - Arguments to update or create a Management_room.
     * @example
     * // Update or create a Management_room
     * const management_room = await prisma.management_room.upsert({
     *   create: {
     *     // ... data to create a Management_room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Management_room we want to update
     *   }
     * })
     */
    upsert<T extends management_roomUpsertArgs>(args: SelectSubset<T, management_roomUpsertArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Management_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {management_roomCountArgs} args - Arguments to filter Management_rooms to count.
     * @example
     * // Count the number of Management_rooms
     * const count = await prisma.management_room.count({
     *   where: {
     *     // ... the filter for the Management_rooms we want to count
     *   }
     * })
    **/
    count<T extends management_roomCountArgs>(
      args?: Subset<T, management_roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Management_roomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Management_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Management_roomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Management_roomAggregateArgs>(args: Subset<T, Management_roomAggregateArgs>): Prisma.PrismaPromise<GetManagement_roomAggregateType<T>>

    /**
     * Group by Management_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {management_roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends management_roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: management_roomGroupByArgs['orderBy'] }
        : { orderBy?: management_roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, management_roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagement_roomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the management_room model
   */
  readonly fields: management_roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for management_room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__management_roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roomDefaultArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager_employee<T extends management_room$manager_employeeArgs<ExtArgs> = {}>(args?: Subset<T, management_room$manager_employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the management_room model
   */
  interface management_roomFieldRefs {
    readonly building_id: FieldRef<"management_room", 'String'>
    readonly room_id: FieldRef<"management_room", 'String'>
    readonly num_of_staff: FieldRef<"management_room", 'Int'>
    readonly start_time: FieldRef<"management_room", 'DateTime'>
    readonly end_time: FieldRef<"management_room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * management_room findUnique
   */
  export type management_roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * Filter, which management_room to fetch.
     */
    where: management_roomWhereUniqueInput
  }

  /**
   * management_room findUniqueOrThrow
   */
  export type management_roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * Filter, which management_room to fetch.
     */
    where: management_roomWhereUniqueInput
  }

  /**
   * management_room findFirst
   */
  export type management_roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * Filter, which management_room to fetch.
     */
    where?: management_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of management_rooms to fetch.
     */
    orderBy?: management_roomOrderByWithRelationInput | management_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for management_rooms.
     */
    cursor?: management_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` management_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` management_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of management_rooms.
     */
    distinct?: Management_roomScalarFieldEnum | Management_roomScalarFieldEnum[]
  }

  /**
   * management_room findFirstOrThrow
   */
  export type management_roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * Filter, which management_room to fetch.
     */
    where?: management_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of management_rooms to fetch.
     */
    orderBy?: management_roomOrderByWithRelationInput | management_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for management_rooms.
     */
    cursor?: management_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` management_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` management_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of management_rooms.
     */
    distinct?: Management_roomScalarFieldEnum | Management_roomScalarFieldEnum[]
  }

  /**
   * management_room findMany
   */
  export type management_roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * Filter, which management_rooms to fetch.
     */
    where?: management_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of management_rooms to fetch.
     */
    orderBy?: management_roomOrderByWithRelationInput | management_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing management_rooms.
     */
    cursor?: management_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` management_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` management_rooms.
     */
    skip?: number
    distinct?: Management_roomScalarFieldEnum | Management_roomScalarFieldEnum[]
  }

  /**
   * management_room create
   */
  export type management_roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * The data needed to create a management_room.
     */
    data: XOR<management_roomCreateInput, management_roomUncheckedCreateInput>
  }

  /**
   * management_room createMany
   */
  export type management_roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many management_rooms.
     */
    data: management_roomCreateManyInput | management_roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * management_room update
   */
  export type management_roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * The data needed to update a management_room.
     */
    data: XOR<management_roomUpdateInput, management_roomUncheckedUpdateInput>
    /**
     * Choose, which management_room to update.
     */
    where: management_roomWhereUniqueInput
  }

  /**
   * management_room updateMany
   */
  export type management_roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update management_rooms.
     */
    data: XOR<management_roomUpdateManyMutationInput, management_roomUncheckedUpdateManyInput>
    /**
     * Filter which management_rooms to update
     */
    where?: management_roomWhereInput
    /**
     * Limit how many management_rooms to update.
     */
    limit?: number
  }

  /**
   * management_room upsert
   */
  export type management_roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * The filter to search for the management_room to update in case it exists.
     */
    where: management_roomWhereUniqueInput
    /**
     * In case the management_room found by the `where` argument doesn't exist, create a new management_room with this data.
     */
    create: XOR<management_roomCreateInput, management_roomUncheckedCreateInput>
    /**
     * In case the management_room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<management_roomUpdateInput, management_roomUncheckedUpdateInput>
  }

  /**
   * management_room delete
   */
  export type management_roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    /**
     * Filter which management_room to delete.
     */
    where: management_roomWhereUniqueInput
  }

  /**
   * management_room deleteMany
   */
  export type management_roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which management_rooms to delete
     */
    where?: management_roomWhereInput
    /**
     * Limit how many management_rooms to delete.
     */
    limit?: number
  }

  /**
   * management_room.manager_employee
   */
  export type management_room$manager_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    where?: manager_employeeWhereInput
    orderBy?: manager_employeeOrderByWithRelationInput | manager_employeeOrderByWithRelationInput[]
    cursor?: manager_employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Manager_employeeScalarFieldEnum | Manager_employeeScalarFieldEnum[]
  }

  /**
   * management_room without action
   */
  export type management_roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
  }


  /**
   * Model managerDorm
   */

  export type AggregateManagerDorm = {
    _count: ManagerDormCountAggregateOutputType | null
    _min: ManagerDormMinAggregateOutputType | null
    _max: ManagerDormMaxAggregateOutputType | null
  }

  export type ManagerDormMinAggregateOutputType = {
    user_name: string | null
    password: string | null
  }

  export type ManagerDormMaxAggregateOutputType = {
    user_name: string | null
    password: string | null
  }

  export type ManagerDormCountAggregateOutputType = {
    user_name: number
    password: number
    _all: number
  }


  export type ManagerDormMinAggregateInputType = {
    user_name?: true
    password?: true
  }

  export type ManagerDormMaxAggregateInputType = {
    user_name?: true
    password?: true
  }

  export type ManagerDormCountAggregateInputType = {
    user_name?: true
    password?: true
    _all?: true
  }

  export type ManagerDormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which managerDorm to aggregate.
     */
    where?: managerDormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of managerDorms to fetch.
     */
    orderBy?: managerDormOrderByWithRelationInput | managerDormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: managerDormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` managerDorms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` managerDorms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned managerDorms
    **/
    _count?: true | ManagerDormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerDormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerDormMaxAggregateInputType
  }

  export type GetManagerDormAggregateType<T extends ManagerDormAggregateArgs> = {
        [P in keyof T & keyof AggregateManagerDorm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManagerDorm[P]>
      : GetScalarType<T[P], AggregateManagerDorm[P]>
  }




  export type managerDormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: managerDormWhereInput
    orderBy?: managerDormOrderByWithAggregationInput | managerDormOrderByWithAggregationInput[]
    by: ManagerDormScalarFieldEnum[] | ManagerDormScalarFieldEnum
    having?: managerDormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerDormCountAggregateInputType | true
    _min?: ManagerDormMinAggregateInputType
    _max?: ManagerDormMaxAggregateInputType
  }

  export type ManagerDormGroupByOutputType = {
    user_name: string
    password: string
    _count: ManagerDormCountAggregateOutputType | null
    _min: ManagerDormMinAggregateOutputType | null
    _max: ManagerDormMaxAggregateOutputType | null
  }

  type GetManagerDormGroupByPayload<T extends managerDormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerDormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerDormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerDormGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerDormGroupByOutputType[P]>
        }
      >
    >


  export type managerDormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_name?: boolean
    password?: boolean
  }, ExtArgs["result"]["managerDorm"]>



  export type managerDormSelectScalar = {
    user_name?: boolean
    password?: boolean
  }

  export type managerDormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_name" | "password", ExtArgs["result"]["managerDorm"]>

  export type $managerDormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "managerDorm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_name: string
      password: string
    }, ExtArgs["result"]["managerDorm"]>
    composites: {}
  }

  type managerDormGetPayload<S extends boolean | null | undefined | managerDormDefaultArgs> = $Result.GetResult<Prisma.$managerDormPayload, S>

  type managerDormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<managerDormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManagerDormCountAggregateInputType | true
    }

  export interface managerDormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['managerDorm'], meta: { name: 'managerDorm' } }
    /**
     * Find zero or one ManagerDorm that matches the filter.
     * @param {managerDormFindUniqueArgs} args - Arguments to find a ManagerDorm
     * @example
     * // Get one ManagerDorm
     * const managerDorm = await prisma.managerDorm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends managerDormFindUniqueArgs>(args: SelectSubset<T, managerDormFindUniqueArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManagerDorm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {managerDormFindUniqueOrThrowArgs} args - Arguments to find a ManagerDorm
     * @example
     * // Get one ManagerDorm
     * const managerDorm = await prisma.managerDorm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends managerDormFindUniqueOrThrowArgs>(args: SelectSubset<T, managerDormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManagerDorm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {managerDormFindFirstArgs} args - Arguments to find a ManagerDorm
     * @example
     * // Get one ManagerDorm
     * const managerDorm = await prisma.managerDorm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends managerDormFindFirstArgs>(args?: SelectSubset<T, managerDormFindFirstArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManagerDorm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {managerDormFindFirstOrThrowArgs} args - Arguments to find a ManagerDorm
     * @example
     * // Get one ManagerDorm
     * const managerDorm = await prisma.managerDorm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends managerDormFindFirstOrThrowArgs>(args?: SelectSubset<T, managerDormFindFirstOrThrowArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManagerDorms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {managerDormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManagerDorms
     * const managerDorms = await prisma.managerDorm.findMany()
     * 
     * // Get first 10 ManagerDorms
     * const managerDorms = await prisma.managerDorm.findMany({ take: 10 })
     * 
     * // Only select the `user_name`
     * const managerDormWithUser_nameOnly = await prisma.managerDorm.findMany({ select: { user_name: true } })
     * 
     */
    findMany<T extends managerDormFindManyArgs>(args?: SelectSubset<T, managerDormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManagerDorm.
     * @param {managerDormCreateArgs} args - Arguments to create a ManagerDorm.
     * @example
     * // Create one ManagerDorm
     * const ManagerDorm = await prisma.managerDorm.create({
     *   data: {
     *     // ... data to create a ManagerDorm
     *   }
     * })
     * 
     */
    create<T extends managerDormCreateArgs>(args: SelectSubset<T, managerDormCreateArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManagerDorms.
     * @param {managerDormCreateManyArgs} args - Arguments to create many ManagerDorms.
     * @example
     * // Create many ManagerDorms
     * const managerDorm = await prisma.managerDorm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends managerDormCreateManyArgs>(args?: SelectSubset<T, managerDormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ManagerDorm.
     * @param {managerDormDeleteArgs} args - Arguments to delete one ManagerDorm.
     * @example
     * // Delete one ManagerDorm
     * const ManagerDorm = await prisma.managerDorm.delete({
     *   where: {
     *     // ... filter to delete one ManagerDorm
     *   }
     * })
     * 
     */
    delete<T extends managerDormDeleteArgs>(args: SelectSubset<T, managerDormDeleteArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManagerDorm.
     * @param {managerDormUpdateArgs} args - Arguments to update one ManagerDorm.
     * @example
     * // Update one ManagerDorm
     * const managerDorm = await prisma.managerDorm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends managerDormUpdateArgs>(args: SelectSubset<T, managerDormUpdateArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManagerDorms.
     * @param {managerDormDeleteManyArgs} args - Arguments to filter ManagerDorms to delete.
     * @example
     * // Delete a few ManagerDorms
     * const { count } = await prisma.managerDorm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends managerDormDeleteManyArgs>(args?: SelectSubset<T, managerDormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManagerDorms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {managerDormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManagerDorms
     * const managerDorm = await prisma.managerDorm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends managerDormUpdateManyArgs>(args: SelectSubset<T, managerDormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ManagerDorm.
     * @param {managerDormUpsertArgs} args - Arguments to update or create a ManagerDorm.
     * @example
     * // Update or create a ManagerDorm
     * const managerDorm = await prisma.managerDorm.upsert({
     *   create: {
     *     // ... data to create a ManagerDorm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManagerDorm we want to update
     *   }
     * })
     */
    upsert<T extends managerDormUpsertArgs>(args: SelectSubset<T, managerDormUpsertArgs<ExtArgs>>): Prisma__managerDormClient<$Result.GetResult<Prisma.$managerDormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManagerDorms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {managerDormCountArgs} args - Arguments to filter ManagerDorms to count.
     * @example
     * // Count the number of ManagerDorms
     * const count = await prisma.managerDorm.count({
     *   where: {
     *     // ... the filter for the ManagerDorms we want to count
     *   }
     * })
    **/
    count<T extends managerDormCountArgs>(
      args?: Subset<T, managerDormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerDormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManagerDorm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerDormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerDormAggregateArgs>(args: Subset<T, ManagerDormAggregateArgs>): Prisma.PrismaPromise<GetManagerDormAggregateType<T>>

    /**
     * Group by ManagerDorm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {managerDormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends managerDormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: managerDormGroupByArgs['orderBy'] }
        : { orderBy?: managerDormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, managerDormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerDormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the managerDorm model
   */
  readonly fields: managerDormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for managerDorm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__managerDormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the managerDorm model
   */
  interface managerDormFieldRefs {
    readonly user_name: FieldRef<"managerDorm", 'String'>
    readonly password: FieldRef<"managerDorm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * managerDorm findUnique
   */
  export type managerDormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * Filter, which managerDorm to fetch.
     */
    where: managerDormWhereUniqueInput
  }

  /**
   * managerDorm findUniqueOrThrow
   */
  export type managerDormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * Filter, which managerDorm to fetch.
     */
    where: managerDormWhereUniqueInput
  }

  /**
   * managerDorm findFirst
   */
  export type managerDormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * Filter, which managerDorm to fetch.
     */
    where?: managerDormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of managerDorms to fetch.
     */
    orderBy?: managerDormOrderByWithRelationInput | managerDormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for managerDorms.
     */
    cursor?: managerDormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` managerDorms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` managerDorms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of managerDorms.
     */
    distinct?: ManagerDormScalarFieldEnum | ManagerDormScalarFieldEnum[]
  }

  /**
   * managerDorm findFirstOrThrow
   */
  export type managerDormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * Filter, which managerDorm to fetch.
     */
    where?: managerDormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of managerDorms to fetch.
     */
    orderBy?: managerDormOrderByWithRelationInput | managerDormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for managerDorms.
     */
    cursor?: managerDormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` managerDorms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` managerDorms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of managerDorms.
     */
    distinct?: ManagerDormScalarFieldEnum | ManagerDormScalarFieldEnum[]
  }

  /**
   * managerDorm findMany
   */
  export type managerDormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * Filter, which managerDorms to fetch.
     */
    where?: managerDormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of managerDorms to fetch.
     */
    orderBy?: managerDormOrderByWithRelationInput | managerDormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing managerDorms.
     */
    cursor?: managerDormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` managerDorms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` managerDorms.
     */
    skip?: number
    distinct?: ManagerDormScalarFieldEnum | ManagerDormScalarFieldEnum[]
  }

  /**
   * managerDorm create
   */
  export type managerDormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * The data needed to create a managerDorm.
     */
    data: XOR<managerDormCreateInput, managerDormUncheckedCreateInput>
  }

  /**
   * managerDorm createMany
   */
  export type managerDormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many managerDorms.
     */
    data: managerDormCreateManyInput | managerDormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * managerDorm update
   */
  export type managerDormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * The data needed to update a managerDorm.
     */
    data: XOR<managerDormUpdateInput, managerDormUncheckedUpdateInput>
    /**
     * Choose, which managerDorm to update.
     */
    where: managerDormWhereUniqueInput
  }

  /**
   * managerDorm updateMany
   */
  export type managerDormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update managerDorms.
     */
    data: XOR<managerDormUpdateManyMutationInput, managerDormUncheckedUpdateManyInput>
    /**
     * Filter which managerDorms to update
     */
    where?: managerDormWhereInput
    /**
     * Limit how many managerDorms to update.
     */
    limit?: number
  }

  /**
   * managerDorm upsert
   */
  export type managerDormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * The filter to search for the managerDorm to update in case it exists.
     */
    where: managerDormWhereUniqueInput
    /**
     * In case the managerDorm found by the `where` argument doesn't exist, create a new managerDorm with this data.
     */
    create: XOR<managerDormCreateInput, managerDormUncheckedCreateInput>
    /**
     * In case the managerDorm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<managerDormUpdateInput, managerDormUncheckedUpdateInput>
  }

  /**
   * managerDorm delete
   */
  export type managerDormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
    /**
     * Filter which managerDorm to delete.
     */
    where: managerDormWhereUniqueInput
  }

  /**
   * managerDorm deleteMany
   */
  export type managerDormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which managerDorms to delete
     */
    where?: managerDormWhereInput
    /**
     * Limit how many managerDorms to delete.
     */
    limit?: number
  }

  /**
   * managerDorm without action
   */
  export type managerDormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the managerDorm
     */
    select?: managerDormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the managerDorm
     */
    omit?: managerDormOmit<ExtArgs> | null
  }


  /**
   * Model manager_degree
   */

  export type AggregateManager_degree = {
    _count: Manager_degreeCountAggregateOutputType | null
    _min: Manager_degreeMinAggregateOutputType | null
    _max: Manager_degreeMaxAggregateOutputType | null
  }

  export type Manager_degreeMinAggregateOutputType = {
    essn: string | null
    degree: string | null
  }

  export type Manager_degreeMaxAggregateOutputType = {
    essn: string | null
    degree: string | null
  }

  export type Manager_degreeCountAggregateOutputType = {
    essn: number
    degree: number
    _all: number
  }


  export type Manager_degreeMinAggregateInputType = {
    essn?: true
    degree?: true
  }

  export type Manager_degreeMaxAggregateInputType = {
    essn?: true
    degree?: true
  }

  export type Manager_degreeCountAggregateInputType = {
    essn?: true
    degree?: true
    _all?: true
  }

  export type Manager_degreeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manager_degree to aggregate.
     */
    where?: manager_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_degrees to fetch.
     */
    orderBy?: manager_degreeOrderByWithRelationInput | manager_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manager_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_degrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manager_degrees
    **/
    _count?: true | Manager_degreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Manager_degreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Manager_degreeMaxAggregateInputType
  }

  export type GetManager_degreeAggregateType<T extends Manager_degreeAggregateArgs> = {
        [P in keyof T & keyof AggregateManager_degree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager_degree[P]>
      : GetScalarType<T[P], AggregateManager_degree[P]>
  }




  export type manager_degreeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manager_degreeWhereInput
    orderBy?: manager_degreeOrderByWithAggregationInput | manager_degreeOrderByWithAggregationInput[]
    by: Manager_degreeScalarFieldEnum[] | Manager_degreeScalarFieldEnum
    having?: manager_degreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Manager_degreeCountAggregateInputType | true
    _min?: Manager_degreeMinAggregateInputType
    _max?: Manager_degreeMaxAggregateInputType
  }

  export type Manager_degreeGroupByOutputType = {
    essn: string
    degree: string
    _count: Manager_degreeCountAggregateOutputType | null
    _min: Manager_degreeMinAggregateOutputType | null
    _max: Manager_degreeMaxAggregateOutputType | null
  }

  type GetManager_degreeGroupByPayload<T extends manager_degreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Manager_degreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Manager_degreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Manager_degreeGroupByOutputType[P]>
            : GetScalarType<T[P], Manager_degreeGroupByOutputType[P]>
        }
      >
    >


  export type manager_degreeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    essn?: boolean
    degree?: boolean
    manager_employee?: boolean | manager_employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager_degree"]>



  export type manager_degreeSelectScalar = {
    essn?: boolean
    degree?: boolean
  }

  export type manager_degreeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"essn" | "degree", ExtArgs["result"]["manager_degree"]>
  export type manager_degreeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager_employee?: boolean | manager_employeeDefaultArgs<ExtArgs>
  }

  export type $manager_degreePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "manager_degree"
    objects: {
      manager_employee: Prisma.$manager_employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      essn: string
      degree: string
    }, ExtArgs["result"]["manager_degree"]>
    composites: {}
  }

  type manager_degreeGetPayload<S extends boolean | null | undefined | manager_degreeDefaultArgs> = $Result.GetResult<Prisma.$manager_degreePayload, S>

  type manager_degreeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<manager_degreeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Manager_degreeCountAggregateInputType | true
    }

  export interface manager_degreeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['manager_degree'], meta: { name: 'manager_degree' } }
    /**
     * Find zero or one Manager_degree that matches the filter.
     * @param {manager_degreeFindUniqueArgs} args - Arguments to find a Manager_degree
     * @example
     * // Get one Manager_degree
     * const manager_degree = await prisma.manager_degree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends manager_degreeFindUniqueArgs>(args: SelectSubset<T, manager_degreeFindUniqueArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager_degree that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {manager_degreeFindUniqueOrThrowArgs} args - Arguments to find a Manager_degree
     * @example
     * // Get one Manager_degree
     * const manager_degree = await prisma.manager_degree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends manager_degreeFindUniqueOrThrowArgs>(args: SelectSubset<T, manager_degreeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager_degree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_degreeFindFirstArgs} args - Arguments to find a Manager_degree
     * @example
     * // Get one Manager_degree
     * const manager_degree = await prisma.manager_degree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends manager_degreeFindFirstArgs>(args?: SelectSubset<T, manager_degreeFindFirstArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager_degree that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_degreeFindFirstOrThrowArgs} args - Arguments to find a Manager_degree
     * @example
     * // Get one Manager_degree
     * const manager_degree = await prisma.manager_degree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends manager_degreeFindFirstOrThrowArgs>(args?: SelectSubset<T, manager_degreeFindFirstOrThrowArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manager_degrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_degreeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manager_degrees
     * const manager_degrees = await prisma.manager_degree.findMany()
     * 
     * // Get first 10 Manager_degrees
     * const manager_degrees = await prisma.manager_degree.findMany({ take: 10 })
     * 
     * // Only select the `essn`
     * const manager_degreeWithEssnOnly = await prisma.manager_degree.findMany({ select: { essn: true } })
     * 
     */
    findMany<T extends manager_degreeFindManyArgs>(args?: SelectSubset<T, manager_degreeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager_degree.
     * @param {manager_degreeCreateArgs} args - Arguments to create a Manager_degree.
     * @example
     * // Create one Manager_degree
     * const Manager_degree = await prisma.manager_degree.create({
     *   data: {
     *     // ... data to create a Manager_degree
     *   }
     * })
     * 
     */
    create<T extends manager_degreeCreateArgs>(args: SelectSubset<T, manager_degreeCreateArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manager_degrees.
     * @param {manager_degreeCreateManyArgs} args - Arguments to create many Manager_degrees.
     * @example
     * // Create many Manager_degrees
     * const manager_degree = await prisma.manager_degree.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends manager_degreeCreateManyArgs>(args?: SelectSubset<T, manager_degreeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manager_degree.
     * @param {manager_degreeDeleteArgs} args - Arguments to delete one Manager_degree.
     * @example
     * // Delete one Manager_degree
     * const Manager_degree = await prisma.manager_degree.delete({
     *   where: {
     *     // ... filter to delete one Manager_degree
     *   }
     * })
     * 
     */
    delete<T extends manager_degreeDeleteArgs>(args: SelectSubset<T, manager_degreeDeleteArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager_degree.
     * @param {manager_degreeUpdateArgs} args - Arguments to update one Manager_degree.
     * @example
     * // Update one Manager_degree
     * const manager_degree = await prisma.manager_degree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends manager_degreeUpdateArgs>(args: SelectSubset<T, manager_degreeUpdateArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manager_degrees.
     * @param {manager_degreeDeleteManyArgs} args - Arguments to filter Manager_degrees to delete.
     * @example
     * // Delete a few Manager_degrees
     * const { count } = await prisma.manager_degree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends manager_degreeDeleteManyArgs>(args?: SelectSubset<T, manager_degreeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manager_degrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_degreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manager_degrees
     * const manager_degree = await prisma.manager_degree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends manager_degreeUpdateManyArgs>(args: SelectSubset<T, manager_degreeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager_degree.
     * @param {manager_degreeUpsertArgs} args - Arguments to update or create a Manager_degree.
     * @example
     * // Update or create a Manager_degree
     * const manager_degree = await prisma.manager_degree.upsert({
     *   create: {
     *     // ... data to create a Manager_degree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager_degree we want to update
     *   }
     * })
     */
    upsert<T extends manager_degreeUpsertArgs>(args: SelectSubset<T, manager_degreeUpsertArgs<ExtArgs>>): Prisma__manager_degreeClient<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manager_degrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_degreeCountArgs} args - Arguments to filter Manager_degrees to count.
     * @example
     * // Count the number of Manager_degrees
     * const count = await prisma.manager_degree.count({
     *   where: {
     *     // ... the filter for the Manager_degrees we want to count
     *   }
     * })
    **/
    count<T extends manager_degreeCountArgs>(
      args?: Subset<T, manager_degreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Manager_degreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager_degree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Manager_degreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Manager_degreeAggregateArgs>(args: Subset<T, Manager_degreeAggregateArgs>): Prisma.PrismaPromise<GetManager_degreeAggregateType<T>>

    /**
     * Group by Manager_degree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_degreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends manager_degreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: manager_degreeGroupByArgs['orderBy'] }
        : { orderBy?: manager_degreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, manager_degreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManager_degreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the manager_degree model
   */
  readonly fields: manager_degreeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for manager_degree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__manager_degreeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager_employee<T extends manager_employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, manager_employeeDefaultArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the manager_degree model
   */
  interface manager_degreeFieldRefs {
    readonly essn: FieldRef<"manager_degree", 'String'>
    readonly degree: FieldRef<"manager_degree", 'String'>
  }
    

  // Custom InputTypes
  /**
   * manager_degree findUnique
   */
  export type manager_degreeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * Filter, which manager_degree to fetch.
     */
    where: manager_degreeWhereUniqueInput
  }

  /**
   * manager_degree findUniqueOrThrow
   */
  export type manager_degreeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * Filter, which manager_degree to fetch.
     */
    where: manager_degreeWhereUniqueInput
  }

  /**
   * manager_degree findFirst
   */
  export type manager_degreeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * Filter, which manager_degree to fetch.
     */
    where?: manager_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_degrees to fetch.
     */
    orderBy?: manager_degreeOrderByWithRelationInput | manager_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manager_degrees.
     */
    cursor?: manager_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_degrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manager_degrees.
     */
    distinct?: Manager_degreeScalarFieldEnum | Manager_degreeScalarFieldEnum[]
  }

  /**
   * manager_degree findFirstOrThrow
   */
  export type manager_degreeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * Filter, which manager_degree to fetch.
     */
    where?: manager_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_degrees to fetch.
     */
    orderBy?: manager_degreeOrderByWithRelationInput | manager_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manager_degrees.
     */
    cursor?: manager_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_degrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manager_degrees.
     */
    distinct?: Manager_degreeScalarFieldEnum | Manager_degreeScalarFieldEnum[]
  }

  /**
   * manager_degree findMany
   */
  export type manager_degreeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * Filter, which manager_degrees to fetch.
     */
    where?: manager_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_degrees to fetch.
     */
    orderBy?: manager_degreeOrderByWithRelationInput | manager_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manager_degrees.
     */
    cursor?: manager_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_degrees.
     */
    skip?: number
    distinct?: Manager_degreeScalarFieldEnum | Manager_degreeScalarFieldEnum[]
  }

  /**
   * manager_degree create
   */
  export type manager_degreeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * The data needed to create a manager_degree.
     */
    data: XOR<manager_degreeCreateInput, manager_degreeUncheckedCreateInput>
  }

  /**
   * manager_degree createMany
   */
  export type manager_degreeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many manager_degrees.
     */
    data: manager_degreeCreateManyInput | manager_degreeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * manager_degree update
   */
  export type manager_degreeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * The data needed to update a manager_degree.
     */
    data: XOR<manager_degreeUpdateInput, manager_degreeUncheckedUpdateInput>
    /**
     * Choose, which manager_degree to update.
     */
    where: manager_degreeWhereUniqueInput
  }

  /**
   * manager_degree updateMany
   */
  export type manager_degreeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update manager_degrees.
     */
    data: XOR<manager_degreeUpdateManyMutationInput, manager_degreeUncheckedUpdateManyInput>
    /**
     * Filter which manager_degrees to update
     */
    where?: manager_degreeWhereInput
    /**
     * Limit how many manager_degrees to update.
     */
    limit?: number
  }

  /**
   * manager_degree upsert
   */
  export type manager_degreeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * The filter to search for the manager_degree to update in case it exists.
     */
    where: manager_degreeWhereUniqueInput
    /**
     * In case the manager_degree found by the `where` argument doesn't exist, create a new manager_degree with this data.
     */
    create: XOR<manager_degreeCreateInput, manager_degreeUncheckedCreateInput>
    /**
     * In case the manager_degree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manager_degreeUpdateInput, manager_degreeUncheckedUpdateInput>
  }

  /**
   * manager_degree delete
   */
  export type manager_degreeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    /**
     * Filter which manager_degree to delete.
     */
    where: manager_degreeWhereUniqueInput
  }

  /**
   * manager_degree deleteMany
   */
  export type manager_degreeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manager_degrees to delete
     */
    where?: manager_degreeWhereInput
    /**
     * Limit how many manager_degrees to delete.
     */
    limit?: number
  }

  /**
   * manager_degree without action
   */
  export type manager_degreeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
  }


  /**
   * Model manager_employee
   */

  export type AggregateManager_employee = {
    _count: Manager_employeeCountAggregateOutputType | null
    _avg: Manager_employeeAvgAggregateOutputType | null
    _sum: Manager_employeeSumAggregateOutputType | null
    _min: Manager_employeeMinAggregateOutputType | null
    _max: Manager_employeeMaxAggregateOutputType | null
  }

  export type Manager_employeeAvgAggregateOutputType = {
    experience: Decimal | null
  }

  export type Manager_employeeSumAggregateOutputType = {
    experience: Decimal | null
  }

  export type Manager_employeeMinAggregateOutputType = {
    essn: string | null
    room_id: string | null
    building_id: string | null
    experience: Decimal | null
  }

  export type Manager_employeeMaxAggregateOutputType = {
    essn: string | null
    room_id: string | null
    building_id: string | null
    experience: Decimal | null
  }

  export type Manager_employeeCountAggregateOutputType = {
    essn: number
    room_id: number
    building_id: number
    experience: number
    _all: number
  }


  export type Manager_employeeAvgAggregateInputType = {
    experience?: true
  }

  export type Manager_employeeSumAggregateInputType = {
    experience?: true
  }

  export type Manager_employeeMinAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    experience?: true
  }

  export type Manager_employeeMaxAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    experience?: true
  }

  export type Manager_employeeCountAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    experience?: true
    _all?: true
  }

  export type Manager_employeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manager_employee to aggregate.
     */
    where?: manager_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_employees to fetch.
     */
    orderBy?: manager_employeeOrderByWithRelationInput | manager_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manager_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manager_employees
    **/
    _count?: true | Manager_employeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Manager_employeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Manager_employeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Manager_employeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Manager_employeeMaxAggregateInputType
  }

  export type GetManager_employeeAggregateType<T extends Manager_employeeAggregateArgs> = {
        [P in keyof T & keyof AggregateManager_employee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager_employee[P]>
      : GetScalarType<T[P], AggregateManager_employee[P]>
  }




  export type manager_employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manager_employeeWhereInput
    orderBy?: manager_employeeOrderByWithAggregationInput | manager_employeeOrderByWithAggregationInput[]
    by: Manager_employeeScalarFieldEnum[] | Manager_employeeScalarFieldEnum
    having?: manager_employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Manager_employeeCountAggregateInputType | true
    _avg?: Manager_employeeAvgAggregateInputType
    _sum?: Manager_employeeSumAggregateInputType
    _min?: Manager_employeeMinAggregateInputType
    _max?: Manager_employeeMaxAggregateInputType
  }

  export type Manager_employeeGroupByOutputType = {
    essn: string
    room_id: string | null
    building_id: string | null
    experience: Decimal | null
    _count: Manager_employeeCountAggregateOutputType | null
    _avg: Manager_employeeAvgAggregateOutputType | null
    _sum: Manager_employeeSumAggregateOutputType | null
    _min: Manager_employeeMinAggregateOutputType | null
    _max: Manager_employeeMaxAggregateOutputType | null
  }

  type GetManager_employeeGroupByPayload<T extends manager_employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Manager_employeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Manager_employeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Manager_employeeGroupByOutputType[P]>
            : GetScalarType<T[P], Manager_employeeGroupByOutputType[P]>
        }
      >
    >


  export type manager_employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    essn?: boolean
    room_id?: boolean
    building_id?: boolean
    experience?: boolean
    disciplineStaff?: boolean | manager_employee$disciplineStaffArgs<ExtArgs>
    manager_degree?: boolean | manager_employee$manager_degreeArgs<ExtArgs>
    management_room?: boolean | manager_employee$management_roomArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    _count?: boolean | Manager_employeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager_employee"]>



  export type manager_employeeSelectScalar = {
    essn?: boolean
    room_id?: boolean
    building_id?: boolean
    experience?: boolean
  }

  export type manager_employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"essn" | "room_id" | "building_id" | "experience", ExtArgs["result"]["manager_employee"]>
  export type manager_employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplineStaff?: boolean | manager_employee$disciplineStaffArgs<ExtArgs>
    manager_degree?: boolean | manager_employee$manager_degreeArgs<ExtArgs>
    management_room?: boolean | manager_employee$management_roomArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    _count?: boolean | Manager_employeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $manager_employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "manager_employee"
    objects: {
      disciplineStaff: Prisma.$disciplineStaffPayload<ExtArgs>[]
      manager_degree: Prisma.$manager_degreePayload<ExtArgs>[]
      management_room: Prisma.$management_roomPayload<ExtArgs> | null
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      essn: string
      room_id: string | null
      building_id: string | null
      experience: Prisma.Decimal | null
    }, ExtArgs["result"]["manager_employee"]>
    composites: {}
  }

  type manager_employeeGetPayload<S extends boolean | null | undefined | manager_employeeDefaultArgs> = $Result.GetResult<Prisma.$manager_employeePayload, S>

  type manager_employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<manager_employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Manager_employeeCountAggregateInputType | true
    }

  export interface manager_employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['manager_employee'], meta: { name: 'manager_employee' } }
    /**
     * Find zero or one Manager_employee that matches the filter.
     * @param {manager_employeeFindUniqueArgs} args - Arguments to find a Manager_employee
     * @example
     * // Get one Manager_employee
     * const manager_employee = await prisma.manager_employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends manager_employeeFindUniqueArgs>(args: SelectSubset<T, manager_employeeFindUniqueArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager_employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {manager_employeeFindUniqueOrThrowArgs} args - Arguments to find a Manager_employee
     * @example
     * // Get one Manager_employee
     * const manager_employee = await prisma.manager_employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends manager_employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, manager_employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager_employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_employeeFindFirstArgs} args - Arguments to find a Manager_employee
     * @example
     * // Get one Manager_employee
     * const manager_employee = await prisma.manager_employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends manager_employeeFindFirstArgs>(args?: SelectSubset<T, manager_employeeFindFirstArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager_employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_employeeFindFirstOrThrowArgs} args - Arguments to find a Manager_employee
     * @example
     * // Get one Manager_employee
     * const manager_employee = await prisma.manager_employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends manager_employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, manager_employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manager_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manager_employees
     * const manager_employees = await prisma.manager_employee.findMany()
     * 
     * // Get first 10 Manager_employees
     * const manager_employees = await prisma.manager_employee.findMany({ take: 10 })
     * 
     * // Only select the `essn`
     * const manager_employeeWithEssnOnly = await prisma.manager_employee.findMany({ select: { essn: true } })
     * 
     */
    findMany<T extends manager_employeeFindManyArgs>(args?: SelectSubset<T, manager_employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager_employee.
     * @param {manager_employeeCreateArgs} args - Arguments to create a Manager_employee.
     * @example
     * // Create one Manager_employee
     * const Manager_employee = await prisma.manager_employee.create({
     *   data: {
     *     // ... data to create a Manager_employee
     *   }
     * })
     * 
     */
    create<T extends manager_employeeCreateArgs>(args: SelectSubset<T, manager_employeeCreateArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manager_employees.
     * @param {manager_employeeCreateManyArgs} args - Arguments to create many Manager_employees.
     * @example
     * // Create many Manager_employees
     * const manager_employee = await prisma.manager_employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends manager_employeeCreateManyArgs>(args?: SelectSubset<T, manager_employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manager_employee.
     * @param {manager_employeeDeleteArgs} args - Arguments to delete one Manager_employee.
     * @example
     * // Delete one Manager_employee
     * const Manager_employee = await prisma.manager_employee.delete({
     *   where: {
     *     // ... filter to delete one Manager_employee
     *   }
     * })
     * 
     */
    delete<T extends manager_employeeDeleteArgs>(args: SelectSubset<T, manager_employeeDeleteArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager_employee.
     * @param {manager_employeeUpdateArgs} args - Arguments to update one Manager_employee.
     * @example
     * // Update one Manager_employee
     * const manager_employee = await prisma.manager_employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends manager_employeeUpdateArgs>(args: SelectSubset<T, manager_employeeUpdateArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manager_employees.
     * @param {manager_employeeDeleteManyArgs} args - Arguments to filter Manager_employees to delete.
     * @example
     * // Delete a few Manager_employees
     * const { count } = await prisma.manager_employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends manager_employeeDeleteManyArgs>(args?: SelectSubset<T, manager_employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manager_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manager_employees
     * const manager_employee = await prisma.manager_employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends manager_employeeUpdateManyArgs>(args: SelectSubset<T, manager_employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager_employee.
     * @param {manager_employeeUpsertArgs} args - Arguments to update or create a Manager_employee.
     * @example
     * // Update or create a Manager_employee
     * const manager_employee = await prisma.manager_employee.upsert({
     *   create: {
     *     // ... data to create a Manager_employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager_employee we want to update
     *   }
     * })
     */
    upsert<T extends manager_employeeUpsertArgs>(args: SelectSubset<T, manager_employeeUpsertArgs<ExtArgs>>): Prisma__manager_employeeClient<$Result.GetResult<Prisma.$manager_employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manager_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_employeeCountArgs} args - Arguments to filter Manager_employees to count.
     * @example
     * // Count the number of Manager_employees
     * const count = await prisma.manager_employee.count({
     *   where: {
     *     // ... the filter for the Manager_employees we want to count
     *   }
     * })
    **/
    count<T extends manager_employeeCountArgs>(
      args?: Subset<T, manager_employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Manager_employeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Manager_employeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Manager_employeeAggregateArgs>(args: Subset<T, Manager_employeeAggregateArgs>): Prisma.PrismaPromise<GetManager_employeeAggregateType<T>>

    /**
     * Group by Manager_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manager_employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends manager_employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: manager_employeeGroupByArgs['orderBy'] }
        : { orderBy?: manager_employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, manager_employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManager_employeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the manager_employee model
   */
  readonly fields: manager_employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for manager_employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__manager_employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    disciplineStaff<T extends manager_employee$disciplineStaffArgs<ExtArgs> = {}>(args?: Subset<T, manager_employee$disciplineStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disciplineStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager_degree<T extends manager_employee$manager_degreeArgs<ExtArgs> = {}>(args?: Subset<T, manager_employee$manager_degreeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manager_degreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    management_room<T extends manager_employee$management_roomArgs<ExtArgs> = {}>(args?: Subset<T, manager_employee$management_roomArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the manager_employee model
   */
  interface manager_employeeFieldRefs {
    readonly essn: FieldRef<"manager_employee", 'String'>
    readonly room_id: FieldRef<"manager_employee", 'String'>
    readonly building_id: FieldRef<"manager_employee", 'String'>
    readonly experience: FieldRef<"manager_employee", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * manager_employee findUnique
   */
  export type manager_employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * Filter, which manager_employee to fetch.
     */
    where: manager_employeeWhereUniqueInput
  }

  /**
   * manager_employee findUniqueOrThrow
   */
  export type manager_employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * Filter, which manager_employee to fetch.
     */
    where: manager_employeeWhereUniqueInput
  }

  /**
   * manager_employee findFirst
   */
  export type manager_employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * Filter, which manager_employee to fetch.
     */
    where?: manager_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_employees to fetch.
     */
    orderBy?: manager_employeeOrderByWithRelationInput | manager_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manager_employees.
     */
    cursor?: manager_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manager_employees.
     */
    distinct?: Manager_employeeScalarFieldEnum | Manager_employeeScalarFieldEnum[]
  }

  /**
   * manager_employee findFirstOrThrow
   */
  export type manager_employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * Filter, which manager_employee to fetch.
     */
    where?: manager_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_employees to fetch.
     */
    orderBy?: manager_employeeOrderByWithRelationInput | manager_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manager_employees.
     */
    cursor?: manager_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manager_employees.
     */
    distinct?: Manager_employeeScalarFieldEnum | Manager_employeeScalarFieldEnum[]
  }

  /**
   * manager_employee findMany
   */
  export type manager_employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * Filter, which manager_employees to fetch.
     */
    where?: manager_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manager_employees to fetch.
     */
    orderBy?: manager_employeeOrderByWithRelationInput | manager_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manager_employees.
     */
    cursor?: manager_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manager_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manager_employees.
     */
    skip?: number
    distinct?: Manager_employeeScalarFieldEnum | Manager_employeeScalarFieldEnum[]
  }

  /**
   * manager_employee create
   */
  export type manager_employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a manager_employee.
     */
    data: XOR<manager_employeeCreateInput, manager_employeeUncheckedCreateInput>
  }

  /**
   * manager_employee createMany
   */
  export type manager_employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many manager_employees.
     */
    data: manager_employeeCreateManyInput | manager_employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * manager_employee update
   */
  export type manager_employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a manager_employee.
     */
    data: XOR<manager_employeeUpdateInput, manager_employeeUncheckedUpdateInput>
    /**
     * Choose, which manager_employee to update.
     */
    where: manager_employeeWhereUniqueInput
  }

  /**
   * manager_employee updateMany
   */
  export type manager_employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update manager_employees.
     */
    data: XOR<manager_employeeUpdateManyMutationInput, manager_employeeUncheckedUpdateManyInput>
    /**
     * Filter which manager_employees to update
     */
    where?: manager_employeeWhereInput
    /**
     * Limit how many manager_employees to update.
     */
    limit?: number
  }

  /**
   * manager_employee upsert
   */
  export type manager_employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the manager_employee to update in case it exists.
     */
    where: manager_employeeWhereUniqueInput
    /**
     * In case the manager_employee found by the `where` argument doesn't exist, create a new manager_employee with this data.
     */
    create: XOR<manager_employeeCreateInput, manager_employeeUncheckedCreateInput>
    /**
     * In case the manager_employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manager_employeeUpdateInput, manager_employeeUncheckedUpdateInput>
  }

  /**
   * manager_employee delete
   */
  export type manager_employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
    /**
     * Filter which manager_employee to delete.
     */
    where: manager_employeeWhereUniqueInput
  }

  /**
   * manager_employee deleteMany
   */
  export type manager_employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manager_employees to delete
     */
    where?: manager_employeeWhereInput
    /**
     * Limit how many manager_employees to delete.
     */
    limit?: number
  }

  /**
   * manager_employee.disciplineStaff
   */
  export type manager_employee$disciplineStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplineStaff
     */
    select?: disciplineStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplineStaff
     */
    omit?: disciplineStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplineStaffInclude<ExtArgs> | null
    where?: disciplineStaffWhereInput
    orderBy?: disciplineStaffOrderByWithRelationInput | disciplineStaffOrderByWithRelationInput[]
    cursor?: disciplineStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisciplineStaffScalarFieldEnum | DisciplineStaffScalarFieldEnum[]
  }

  /**
   * manager_employee.manager_degree
   */
  export type manager_employee$manager_degreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_degree
     */
    select?: manager_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_degree
     */
    omit?: manager_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_degreeInclude<ExtArgs> | null
    where?: manager_degreeWhereInput
    orderBy?: manager_degreeOrderByWithRelationInput | manager_degreeOrderByWithRelationInput[]
    cursor?: manager_degreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Manager_degreeScalarFieldEnum | Manager_degreeScalarFieldEnum[]
  }

  /**
   * manager_employee.management_room
   */
  export type manager_employee$management_roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    where?: management_roomWhereInput
  }

  /**
   * manager_employee without action
   */
  export type manager_employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manager_employee
     */
    select?: manager_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manager_employee
     */
    omit?: manager_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manager_employeeInclude<ExtArgs> | null
  }


  /**
   * Model medical_degree
   */

  export type AggregateMedical_degree = {
    _count: Medical_degreeCountAggregateOutputType | null
    _min: Medical_degreeMinAggregateOutputType | null
    _max: Medical_degreeMaxAggregateOutputType | null
  }

  export type Medical_degreeMinAggregateOutputType = {
    essn: string | null
    degree: string | null
  }

  export type Medical_degreeMaxAggregateOutputType = {
    essn: string | null
    degree: string | null
  }

  export type Medical_degreeCountAggregateOutputType = {
    essn: number
    degree: number
    _all: number
  }


  export type Medical_degreeMinAggregateInputType = {
    essn?: true
    degree?: true
  }

  export type Medical_degreeMaxAggregateInputType = {
    essn?: true
    degree?: true
  }

  export type Medical_degreeCountAggregateInputType = {
    essn?: true
    degree?: true
    _all?: true
  }

  export type Medical_degreeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_degree to aggregate.
     */
    where?: medical_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_degrees to fetch.
     */
    orderBy?: medical_degreeOrderByWithRelationInput | medical_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medical_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_degrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medical_degrees
    **/
    _count?: true | Medical_degreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Medical_degreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Medical_degreeMaxAggregateInputType
  }

  export type GetMedical_degreeAggregateType<T extends Medical_degreeAggregateArgs> = {
        [P in keyof T & keyof AggregateMedical_degree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedical_degree[P]>
      : GetScalarType<T[P], AggregateMedical_degree[P]>
  }




  export type medical_degreeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_degreeWhereInput
    orderBy?: medical_degreeOrderByWithAggregationInput | medical_degreeOrderByWithAggregationInput[]
    by: Medical_degreeScalarFieldEnum[] | Medical_degreeScalarFieldEnum
    having?: medical_degreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Medical_degreeCountAggregateInputType | true
    _min?: Medical_degreeMinAggregateInputType
    _max?: Medical_degreeMaxAggregateInputType
  }

  export type Medical_degreeGroupByOutputType = {
    essn: string
    degree: string
    _count: Medical_degreeCountAggregateOutputType | null
    _min: Medical_degreeMinAggregateOutputType | null
    _max: Medical_degreeMaxAggregateOutputType | null
  }

  type GetMedical_degreeGroupByPayload<T extends medical_degreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Medical_degreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Medical_degreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Medical_degreeGroupByOutputType[P]>
            : GetScalarType<T[P], Medical_degreeGroupByOutputType[P]>
        }
      >
    >


  export type medical_degreeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    essn?: boolean
    degree?: boolean
    medical_employee?: boolean | medical_employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medical_degree"]>



  export type medical_degreeSelectScalar = {
    essn?: boolean
    degree?: boolean
  }

  export type medical_degreeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"essn" | "degree", ExtArgs["result"]["medical_degree"]>
  export type medical_degreeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical_employee?: boolean | medical_employeeDefaultArgs<ExtArgs>
  }

  export type $medical_degreePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medical_degree"
    objects: {
      medical_employee: Prisma.$medical_employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      essn: string
      degree: string
    }, ExtArgs["result"]["medical_degree"]>
    composites: {}
  }

  type medical_degreeGetPayload<S extends boolean | null | undefined | medical_degreeDefaultArgs> = $Result.GetResult<Prisma.$medical_degreePayload, S>

  type medical_degreeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<medical_degreeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Medical_degreeCountAggregateInputType | true
    }

  export interface medical_degreeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medical_degree'], meta: { name: 'medical_degree' } }
    /**
     * Find zero or one Medical_degree that matches the filter.
     * @param {medical_degreeFindUniqueArgs} args - Arguments to find a Medical_degree
     * @example
     * // Get one Medical_degree
     * const medical_degree = await prisma.medical_degree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medical_degreeFindUniqueArgs>(args: SelectSubset<T, medical_degreeFindUniqueArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medical_degree that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {medical_degreeFindUniqueOrThrowArgs} args - Arguments to find a Medical_degree
     * @example
     * // Get one Medical_degree
     * const medical_degree = await prisma.medical_degree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medical_degreeFindUniqueOrThrowArgs>(args: SelectSubset<T, medical_degreeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_degree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_degreeFindFirstArgs} args - Arguments to find a Medical_degree
     * @example
     * // Get one Medical_degree
     * const medical_degree = await prisma.medical_degree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medical_degreeFindFirstArgs>(args?: SelectSubset<T, medical_degreeFindFirstArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_degree that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_degreeFindFirstOrThrowArgs} args - Arguments to find a Medical_degree
     * @example
     * // Get one Medical_degree
     * const medical_degree = await prisma.medical_degree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medical_degreeFindFirstOrThrowArgs>(args?: SelectSubset<T, medical_degreeFindFirstOrThrowArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medical_degrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_degreeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medical_degrees
     * const medical_degrees = await prisma.medical_degree.findMany()
     * 
     * // Get first 10 Medical_degrees
     * const medical_degrees = await prisma.medical_degree.findMany({ take: 10 })
     * 
     * // Only select the `essn`
     * const medical_degreeWithEssnOnly = await prisma.medical_degree.findMany({ select: { essn: true } })
     * 
     */
    findMany<T extends medical_degreeFindManyArgs>(args?: SelectSubset<T, medical_degreeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medical_degree.
     * @param {medical_degreeCreateArgs} args - Arguments to create a Medical_degree.
     * @example
     * // Create one Medical_degree
     * const Medical_degree = await prisma.medical_degree.create({
     *   data: {
     *     // ... data to create a Medical_degree
     *   }
     * })
     * 
     */
    create<T extends medical_degreeCreateArgs>(args: SelectSubset<T, medical_degreeCreateArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medical_degrees.
     * @param {medical_degreeCreateManyArgs} args - Arguments to create many Medical_degrees.
     * @example
     * // Create many Medical_degrees
     * const medical_degree = await prisma.medical_degree.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medical_degreeCreateManyArgs>(args?: SelectSubset<T, medical_degreeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medical_degree.
     * @param {medical_degreeDeleteArgs} args - Arguments to delete one Medical_degree.
     * @example
     * // Delete one Medical_degree
     * const Medical_degree = await prisma.medical_degree.delete({
     *   where: {
     *     // ... filter to delete one Medical_degree
     *   }
     * })
     * 
     */
    delete<T extends medical_degreeDeleteArgs>(args: SelectSubset<T, medical_degreeDeleteArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medical_degree.
     * @param {medical_degreeUpdateArgs} args - Arguments to update one Medical_degree.
     * @example
     * // Update one Medical_degree
     * const medical_degree = await prisma.medical_degree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medical_degreeUpdateArgs>(args: SelectSubset<T, medical_degreeUpdateArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medical_degrees.
     * @param {medical_degreeDeleteManyArgs} args - Arguments to filter Medical_degrees to delete.
     * @example
     * // Delete a few Medical_degrees
     * const { count } = await prisma.medical_degree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medical_degreeDeleteManyArgs>(args?: SelectSubset<T, medical_degreeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medical_degrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_degreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medical_degrees
     * const medical_degree = await prisma.medical_degree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medical_degreeUpdateManyArgs>(args: SelectSubset<T, medical_degreeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medical_degree.
     * @param {medical_degreeUpsertArgs} args - Arguments to update or create a Medical_degree.
     * @example
     * // Update or create a Medical_degree
     * const medical_degree = await prisma.medical_degree.upsert({
     *   create: {
     *     // ... data to create a Medical_degree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medical_degree we want to update
     *   }
     * })
     */
    upsert<T extends medical_degreeUpsertArgs>(args: SelectSubset<T, medical_degreeUpsertArgs<ExtArgs>>): Prisma__medical_degreeClient<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medical_degrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_degreeCountArgs} args - Arguments to filter Medical_degrees to count.
     * @example
     * // Count the number of Medical_degrees
     * const count = await prisma.medical_degree.count({
     *   where: {
     *     // ... the filter for the Medical_degrees we want to count
     *   }
     * })
    **/
    count<T extends medical_degreeCountArgs>(
      args?: Subset<T, medical_degreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Medical_degreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medical_degree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_degreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Medical_degreeAggregateArgs>(args: Subset<T, Medical_degreeAggregateArgs>): Prisma.PrismaPromise<GetMedical_degreeAggregateType<T>>

    /**
     * Group by Medical_degree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_degreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medical_degreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medical_degreeGroupByArgs['orderBy'] }
        : { orderBy?: medical_degreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medical_degreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedical_degreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medical_degree model
   */
  readonly fields: medical_degreeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medical_degree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medical_degreeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medical_employee<T extends medical_employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, medical_employeeDefaultArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medical_degree model
   */
  interface medical_degreeFieldRefs {
    readonly essn: FieldRef<"medical_degree", 'String'>
    readonly degree: FieldRef<"medical_degree", 'String'>
  }
    

  // Custom InputTypes
  /**
   * medical_degree findUnique
   */
  export type medical_degreeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * Filter, which medical_degree to fetch.
     */
    where: medical_degreeWhereUniqueInput
  }

  /**
   * medical_degree findUniqueOrThrow
   */
  export type medical_degreeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * Filter, which medical_degree to fetch.
     */
    where: medical_degreeWhereUniqueInput
  }

  /**
   * medical_degree findFirst
   */
  export type medical_degreeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * Filter, which medical_degree to fetch.
     */
    where?: medical_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_degrees to fetch.
     */
    orderBy?: medical_degreeOrderByWithRelationInput | medical_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_degrees.
     */
    cursor?: medical_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_degrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_degrees.
     */
    distinct?: Medical_degreeScalarFieldEnum | Medical_degreeScalarFieldEnum[]
  }

  /**
   * medical_degree findFirstOrThrow
   */
  export type medical_degreeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * Filter, which medical_degree to fetch.
     */
    where?: medical_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_degrees to fetch.
     */
    orderBy?: medical_degreeOrderByWithRelationInput | medical_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_degrees.
     */
    cursor?: medical_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_degrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_degrees.
     */
    distinct?: Medical_degreeScalarFieldEnum | Medical_degreeScalarFieldEnum[]
  }

  /**
   * medical_degree findMany
   */
  export type medical_degreeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * Filter, which medical_degrees to fetch.
     */
    where?: medical_degreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_degrees to fetch.
     */
    orderBy?: medical_degreeOrderByWithRelationInput | medical_degreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medical_degrees.
     */
    cursor?: medical_degreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_degrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_degrees.
     */
    skip?: number
    distinct?: Medical_degreeScalarFieldEnum | Medical_degreeScalarFieldEnum[]
  }

  /**
   * medical_degree create
   */
  export type medical_degreeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * The data needed to create a medical_degree.
     */
    data: XOR<medical_degreeCreateInput, medical_degreeUncheckedCreateInput>
  }

  /**
   * medical_degree createMany
   */
  export type medical_degreeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medical_degrees.
     */
    data: medical_degreeCreateManyInput | medical_degreeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medical_degree update
   */
  export type medical_degreeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * The data needed to update a medical_degree.
     */
    data: XOR<medical_degreeUpdateInput, medical_degreeUncheckedUpdateInput>
    /**
     * Choose, which medical_degree to update.
     */
    where: medical_degreeWhereUniqueInput
  }

  /**
   * medical_degree updateMany
   */
  export type medical_degreeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medical_degrees.
     */
    data: XOR<medical_degreeUpdateManyMutationInput, medical_degreeUncheckedUpdateManyInput>
    /**
     * Filter which medical_degrees to update
     */
    where?: medical_degreeWhereInput
    /**
     * Limit how many medical_degrees to update.
     */
    limit?: number
  }

  /**
   * medical_degree upsert
   */
  export type medical_degreeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * The filter to search for the medical_degree to update in case it exists.
     */
    where: medical_degreeWhereUniqueInput
    /**
     * In case the medical_degree found by the `where` argument doesn't exist, create a new medical_degree with this data.
     */
    create: XOR<medical_degreeCreateInput, medical_degreeUncheckedCreateInput>
    /**
     * In case the medical_degree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medical_degreeUpdateInput, medical_degreeUncheckedUpdateInput>
  }

  /**
   * medical_degree delete
   */
  export type medical_degreeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    /**
     * Filter which medical_degree to delete.
     */
    where: medical_degreeWhereUniqueInput
  }

  /**
   * medical_degree deleteMany
   */
  export type medical_degreeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_degrees to delete
     */
    where?: medical_degreeWhereInput
    /**
     * Limit how many medical_degrees to delete.
     */
    limit?: number
  }

  /**
   * medical_degree without action
   */
  export type medical_degreeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
  }


  /**
   * Model medical_employee
   */

  export type AggregateMedical_employee = {
    _count: Medical_employeeCountAggregateOutputType | null
    _avg: Medical_employeeAvgAggregateOutputType | null
    _sum: Medical_employeeSumAggregateOutputType | null
    _min: Medical_employeeMinAggregateOutputType | null
    _max: Medical_employeeMaxAggregateOutputType | null
  }

  export type Medical_employeeAvgAggregateOutputType = {
    experience: Decimal | null
  }

  export type Medical_employeeSumAggregateOutputType = {
    experience: Decimal | null
  }

  export type Medical_employeeMinAggregateOutputType = {
    essn: string | null
    room_id: string | null
    building_id: string | null
    experience: Decimal | null
  }

  export type Medical_employeeMaxAggregateOutputType = {
    essn: string | null
    room_id: string | null
    building_id: string | null
    experience: Decimal | null
  }

  export type Medical_employeeCountAggregateOutputType = {
    essn: number
    room_id: number
    building_id: number
    experience: number
    _all: number
  }


  export type Medical_employeeAvgAggregateInputType = {
    experience?: true
  }

  export type Medical_employeeSumAggregateInputType = {
    experience?: true
  }

  export type Medical_employeeMinAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    experience?: true
  }

  export type Medical_employeeMaxAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    experience?: true
  }

  export type Medical_employeeCountAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    experience?: true
    _all?: true
  }

  export type Medical_employeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_employee to aggregate.
     */
    where?: medical_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_employees to fetch.
     */
    orderBy?: medical_employeeOrderByWithRelationInput | medical_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medical_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medical_employees
    **/
    _count?: true | Medical_employeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Medical_employeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Medical_employeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Medical_employeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Medical_employeeMaxAggregateInputType
  }

  export type GetMedical_employeeAggregateType<T extends Medical_employeeAggregateArgs> = {
        [P in keyof T & keyof AggregateMedical_employee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedical_employee[P]>
      : GetScalarType<T[P], AggregateMedical_employee[P]>
  }




  export type medical_employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_employeeWhereInput
    orderBy?: medical_employeeOrderByWithAggregationInput | medical_employeeOrderByWithAggregationInput[]
    by: Medical_employeeScalarFieldEnum[] | Medical_employeeScalarFieldEnum
    having?: medical_employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Medical_employeeCountAggregateInputType | true
    _avg?: Medical_employeeAvgAggregateInputType
    _sum?: Medical_employeeSumAggregateInputType
    _min?: Medical_employeeMinAggregateInputType
    _max?: Medical_employeeMaxAggregateInputType
  }

  export type Medical_employeeGroupByOutputType = {
    essn: string
    room_id: string | null
    building_id: string | null
    experience: Decimal | null
    _count: Medical_employeeCountAggregateOutputType | null
    _avg: Medical_employeeAvgAggregateOutputType | null
    _sum: Medical_employeeSumAggregateOutputType | null
    _min: Medical_employeeMinAggregateOutputType | null
    _max: Medical_employeeMaxAggregateOutputType | null
  }

  type GetMedical_employeeGroupByPayload<T extends medical_employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Medical_employeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Medical_employeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Medical_employeeGroupByOutputType[P]>
            : GetScalarType<T[P], Medical_employeeGroupByOutputType[P]>
        }
      >
    >


  export type medical_employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    essn?: boolean
    room_id?: boolean
    building_id?: boolean
    experience?: boolean
    medical_degree?: boolean | medical_employee$medical_degreeArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    health_room?: boolean | medical_employee$health_roomArgs<ExtArgs>
    _count?: boolean | Medical_employeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medical_employee"]>



  export type medical_employeeSelectScalar = {
    essn?: boolean
    room_id?: boolean
    building_id?: boolean
    experience?: boolean
  }

  export type medical_employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"essn" | "room_id" | "building_id" | "experience", ExtArgs["result"]["medical_employee"]>
  export type medical_employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical_degree?: boolean | medical_employee$medical_degreeArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    health_room?: boolean | medical_employee$health_roomArgs<ExtArgs>
    _count?: boolean | Medical_employeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $medical_employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medical_employee"
    objects: {
      medical_degree: Prisma.$medical_degreePayload<ExtArgs>[]
      employee: Prisma.$employeePayload<ExtArgs>
      health_room: Prisma.$health_roomPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      essn: string
      room_id: string | null
      building_id: string | null
      experience: Prisma.Decimal | null
    }, ExtArgs["result"]["medical_employee"]>
    composites: {}
  }

  type medical_employeeGetPayload<S extends boolean | null | undefined | medical_employeeDefaultArgs> = $Result.GetResult<Prisma.$medical_employeePayload, S>

  type medical_employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<medical_employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Medical_employeeCountAggregateInputType | true
    }

  export interface medical_employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medical_employee'], meta: { name: 'medical_employee' } }
    /**
     * Find zero or one Medical_employee that matches the filter.
     * @param {medical_employeeFindUniqueArgs} args - Arguments to find a Medical_employee
     * @example
     * // Get one Medical_employee
     * const medical_employee = await prisma.medical_employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medical_employeeFindUniqueArgs>(args: SelectSubset<T, medical_employeeFindUniqueArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medical_employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {medical_employeeFindUniqueOrThrowArgs} args - Arguments to find a Medical_employee
     * @example
     * // Get one Medical_employee
     * const medical_employee = await prisma.medical_employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medical_employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, medical_employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_employeeFindFirstArgs} args - Arguments to find a Medical_employee
     * @example
     * // Get one Medical_employee
     * const medical_employee = await prisma.medical_employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medical_employeeFindFirstArgs>(args?: SelectSubset<T, medical_employeeFindFirstArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_employeeFindFirstOrThrowArgs} args - Arguments to find a Medical_employee
     * @example
     * // Get one Medical_employee
     * const medical_employee = await prisma.medical_employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medical_employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, medical_employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medical_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medical_employees
     * const medical_employees = await prisma.medical_employee.findMany()
     * 
     * // Get first 10 Medical_employees
     * const medical_employees = await prisma.medical_employee.findMany({ take: 10 })
     * 
     * // Only select the `essn`
     * const medical_employeeWithEssnOnly = await prisma.medical_employee.findMany({ select: { essn: true } })
     * 
     */
    findMany<T extends medical_employeeFindManyArgs>(args?: SelectSubset<T, medical_employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medical_employee.
     * @param {medical_employeeCreateArgs} args - Arguments to create a Medical_employee.
     * @example
     * // Create one Medical_employee
     * const Medical_employee = await prisma.medical_employee.create({
     *   data: {
     *     // ... data to create a Medical_employee
     *   }
     * })
     * 
     */
    create<T extends medical_employeeCreateArgs>(args: SelectSubset<T, medical_employeeCreateArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medical_employees.
     * @param {medical_employeeCreateManyArgs} args - Arguments to create many Medical_employees.
     * @example
     * // Create many Medical_employees
     * const medical_employee = await prisma.medical_employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medical_employeeCreateManyArgs>(args?: SelectSubset<T, medical_employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medical_employee.
     * @param {medical_employeeDeleteArgs} args - Arguments to delete one Medical_employee.
     * @example
     * // Delete one Medical_employee
     * const Medical_employee = await prisma.medical_employee.delete({
     *   where: {
     *     // ... filter to delete one Medical_employee
     *   }
     * })
     * 
     */
    delete<T extends medical_employeeDeleteArgs>(args: SelectSubset<T, medical_employeeDeleteArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medical_employee.
     * @param {medical_employeeUpdateArgs} args - Arguments to update one Medical_employee.
     * @example
     * // Update one Medical_employee
     * const medical_employee = await prisma.medical_employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medical_employeeUpdateArgs>(args: SelectSubset<T, medical_employeeUpdateArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medical_employees.
     * @param {medical_employeeDeleteManyArgs} args - Arguments to filter Medical_employees to delete.
     * @example
     * // Delete a few Medical_employees
     * const { count } = await prisma.medical_employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medical_employeeDeleteManyArgs>(args?: SelectSubset<T, medical_employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medical_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medical_employees
     * const medical_employee = await prisma.medical_employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medical_employeeUpdateManyArgs>(args: SelectSubset<T, medical_employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medical_employee.
     * @param {medical_employeeUpsertArgs} args - Arguments to update or create a Medical_employee.
     * @example
     * // Update or create a Medical_employee
     * const medical_employee = await prisma.medical_employee.upsert({
     *   create: {
     *     // ... data to create a Medical_employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medical_employee we want to update
     *   }
     * })
     */
    upsert<T extends medical_employeeUpsertArgs>(args: SelectSubset<T, medical_employeeUpsertArgs<ExtArgs>>): Prisma__medical_employeeClient<$Result.GetResult<Prisma.$medical_employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medical_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_employeeCountArgs} args - Arguments to filter Medical_employees to count.
     * @example
     * // Count the number of Medical_employees
     * const count = await prisma.medical_employee.count({
     *   where: {
     *     // ... the filter for the Medical_employees we want to count
     *   }
     * })
    **/
    count<T extends medical_employeeCountArgs>(
      args?: Subset<T, medical_employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Medical_employeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medical_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_employeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Medical_employeeAggregateArgs>(args: Subset<T, Medical_employeeAggregateArgs>): Prisma.PrismaPromise<GetMedical_employeeAggregateType<T>>

    /**
     * Group by Medical_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medical_employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medical_employeeGroupByArgs['orderBy'] }
        : { orderBy?: medical_employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medical_employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedical_employeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medical_employee model
   */
  readonly fields: medical_employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medical_employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medical_employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medical_degree<T extends medical_employee$medical_degreeArgs<ExtArgs> = {}>(args?: Subset<T, medical_employee$medical_degreeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_degreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    health_room<T extends medical_employee$health_roomArgs<ExtArgs> = {}>(args?: Subset<T, medical_employee$health_roomArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medical_employee model
   */
  interface medical_employeeFieldRefs {
    readonly essn: FieldRef<"medical_employee", 'String'>
    readonly room_id: FieldRef<"medical_employee", 'String'>
    readonly building_id: FieldRef<"medical_employee", 'String'>
    readonly experience: FieldRef<"medical_employee", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * medical_employee findUnique
   */
  export type medical_employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * Filter, which medical_employee to fetch.
     */
    where: medical_employeeWhereUniqueInput
  }

  /**
   * medical_employee findUniqueOrThrow
   */
  export type medical_employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * Filter, which medical_employee to fetch.
     */
    where: medical_employeeWhereUniqueInput
  }

  /**
   * medical_employee findFirst
   */
  export type medical_employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * Filter, which medical_employee to fetch.
     */
    where?: medical_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_employees to fetch.
     */
    orderBy?: medical_employeeOrderByWithRelationInput | medical_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_employees.
     */
    cursor?: medical_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_employees.
     */
    distinct?: Medical_employeeScalarFieldEnum | Medical_employeeScalarFieldEnum[]
  }

  /**
   * medical_employee findFirstOrThrow
   */
  export type medical_employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * Filter, which medical_employee to fetch.
     */
    where?: medical_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_employees to fetch.
     */
    orderBy?: medical_employeeOrderByWithRelationInput | medical_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_employees.
     */
    cursor?: medical_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_employees.
     */
    distinct?: Medical_employeeScalarFieldEnum | Medical_employeeScalarFieldEnum[]
  }

  /**
   * medical_employee findMany
   */
  export type medical_employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * Filter, which medical_employees to fetch.
     */
    where?: medical_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_employees to fetch.
     */
    orderBy?: medical_employeeOrderByWithRelationInput | medical_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medical_employees.
     */
    cursor?: medical_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_employees.
     */
    skip?: number
    distinct?: Medical_employeeScalarFieldEnum | Medical_employeeScalarFieldEnum[]
  }

  /**
   * medical_employee create
   */
  export type medical_employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a medical_employee.
     */
    data: XOR<medical_employeeCreateInput, medical_employeeUncheckedCreateInput>
  }

  /**
   * medical_employee createMany
   */
  export type medical_employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medical_employees.
     */
    data: medical_employeeCreateManyInput | medical_employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medical_employee update
   */
  export type medical_employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a medical_employee.
     */
    data: XOR<medical_employeeUpdateInput, medical_employeeUncheckedUpdateInput>
    /**
     * Choose, which medical_employee to update.
     */
    where: medical_employeeWhereUniqueInput
  }

  /**
   * medical_employee updateMany
   */
  export type medical_employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medical_employees.
     */
    data: XOR<medical_employeeUpdateManyMutationInput, medical_employeeUncheckedUpdateManyInput>
    /**
     * Filter which medical_employees to update
     */
    where?: medical_employeeWhereInput
    /**
     * Limit how many medical_employees to update.
     */
    limit?: number
  }

  /**
   * medical_employee upsert
   */
  export type medical_employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the medical_employee to update in case it exists.
     */
    where: medical_employeeWhereUniqueInput
    /**
     * In case the medical_employee found by the `where` argument doesn't exist, create a new medical_employee with this data.
     */
    create: XOR<medical_employeeCreateInput, medical_employeeUncheckedCreateInput>
    /**
     * In case the medical_employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medical_employeeUpdateInput, medical_employeeUncheckedUpdateInput>
  }

  /**
   * medical_employee delete
   */
  export type medical_employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
    /**
     * Filter which medical_employee to delete.
     */
    where: medical_employeeWhereUniqueInput
  }

  /**
   * medical_employee deleteMany
   */
  export type medical_employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_employees to delete
     */
    where?: medical_employeeWhereInput
    /**
     * Limit how many medical_employees to delete.
     */
    limit?: number
  }

  /**
   * medical_employee.medical_degree
   */
  export type medical_employee$medical_degreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_degree
     */
    select?: medical_degreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_degree
     */
    omit?: medical_degreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_degreeInclude<ExtArgs> | null
    where?: medical_degreeWhereInput
    orderBy?: medical_degreeOrderByWithRelationInput | medical_degreeOrderByWithRelationInput[]
    cursor?: medical_degreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medical_degreeScalarFieldEnum | Medical_degreeScalarFieldEnum[]
  }

  /**
   * medical_employee.health_room
   */
  export type medical_employee$health_roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    where?: health_roomWhereInput
  }

  /**
   * medical_employee without action
   */
  export type medical_employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_employee
     */
    select?: medical_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_employee
     */
    omit?: medical_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_employeeInclude<ExtArgs> | null
  }


  /**
   * Model other_employee
   */

  export type AggregateOther_employee = {
    _count: Other_employeeCountAggregateOutputType | null
    _min: Other_employeeMinAggregateOutputType | null
    _max: Other_employeeMaxAggregateOutputType | null
  }

  export type Other_employeeMinAggregateOutputType = {
    essn: string | null
    room_id: string | null
    building_id: string | null
    typeWork: string | null
  }

  export type Other_employeeMaxAggregateOutputType = {
    essn: string | null
    room_id: string | null
    building_id: string | null
    typeWork: string | null
  }

  export type Other_employeeCountAggregateOutputType = {
    essn: number
    room_id: number
    building_id: number
    typeWork: number
    _all: number
  }


  export type Other_employeeMinAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    typeWork?: true
  }

  export type Other_employeeMaxAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    typeWork?: true
  }

  export type Other_employeeCountAggregateInputType = {
    essn?: true
    room_id?: true
    building_id?: true
    typeWork?: true
    _all?: true
  }

  export type Other_employeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_employee to aggregate.
     */
    where?: other_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employees to fetch.
     */
    orderBy?: other_employeeOrderByWithRelationInput | other_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: other_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned other_employees
    **/
    _count?: true | Other_employeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Other_employeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Other_employeeMaxAggregateInputType
  }

  export type GetOther_employeeAggregateType<T extends Other_employeeAggregateArgs> = {
        [P in keyof T & keyof AggregateOther_employee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOther_employee[P]>
      : GetScalarType<T[P], AggregateOther_employee[P]>
  }




  export type other_employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: other_employeeWhereInput
    orderBy?: other_employeeOrderByWithAggregationInput | other_employeeOrderByWithAggregationInput[]
    by: Other_employeeScalarFieldEnum[] | Other_employeeScalarFieldEnum
    having?: other_employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Other_employeeCountAggregateInputType | true
    _min?: Other_employeeMinAggregateInputType
    _max?: Other_employeeMaxAggregateInputType
  }

  export type Other_employeeGroupByOutputType = {
    essn: string
    room_id: string | null
    building_id: string | null
    typeWork: string | null
    _count: Other_employeeCountAggregateOutputType | null
    _min: Other_employeeMinAggregateOutputType | null
    _max: Other_employeeMaxAggregateOutputType | null
  }

  type GetOther_employeeGroupByPayload<T extends other_employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Other_employeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Other_employeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Other_employeeGroupByOutputType[P]>
            : GetScalarType<T[P], Other_employeeGroupByOutputType[P]>
        }
      >
    >


  export type other_employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    essn?: boolean
    room_id?: boolean
    building_id?: boolean
    typeWork?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    other_room?: boolean | other_employee$other_roomArgs<ExtArgs>
    other_employee_time_work?: boolean | other_employee$other_employee_time_workArgs<ExtArgs>
    _count?: boolean | Other_employeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["other_employee"]>



  export type other_employeeSelectScalar = {
    essn?: boolean
    room_id?: boolean
    building_id?: boolean
    typeWork?: boolean
  }

  export type other_employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"essn" | "room_id" | "building_id" | "typeWork", ExtArgs["result"]["other_employee"]>
  export type other_employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    other_room?: boolean | other_employee$other_roomArgs<ExtArgs>
    other_employee_time_work?: boolean | other_employee$other_employee_time_workArgs<ExtArgs>
    _count?: boolean | Other_employeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $other_employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "other_employee"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
      other_room: Prisma.$other_roomPayload<ExtArgs> | null
      other_employee_time_work: Prisma.$other_employee_time_workPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      essn: string
      room_id: string | null
      building_id: string | null
      typeWork: string | null
    }, ExtArgs["result"]["other_employee"]>
    composites: {}
  }

  type other_employeeGetPayload<S extends boolean | null | undefined | other_employeeDefaultArgs> = $Result.GetResult<Prisma.$other_employeePayload, S>

  type other_employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<other_employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Other_employeeCountAggregateInputType | true
    }

  export interface other_employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['other_employee'], meta: { name: 'other_employee' } }
    /**
     * Find zero or one Other_employee that matches the filter.
     * @param {other_employeeFindUniqueArgs} args - Arguments to find a Other_employee
     * @example
     * // Get one Other_employee
     * const other_employee = await prisma.other_employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends other_employeeFindUniqueArgs>(args: SelectSubset<T, other_employeeFindUniqueArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Other_employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {other_employeeFindUniqueOrThrowArgs} args - Arguments to find a Other_employee
     * @example
     * // Get one Other_employee
     * const other_employee = await prisma.other_employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends other_employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, other_employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employeeFindFirstArgs} args - Arguments to find a Other_employee
     * @example
     * // Get one Other_employee
     * const other_employee = await prisma.other_employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends other_employeeFindFirstArgs>(args?: SelectSubset<T, other_employeeFindFirstArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employeeFindFirstOrThrowArgs} args - Arguments to find a Other_employee
     * @example
     * // Get one Other_employee
     * const other_employee = await prisma.other_employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends other_employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, other_employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Other_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Other_employees
     * const other_employees = await prisma.other_employee.findMany()
     * 
     * // Get first 10 Other_employees
     * const other_employees = await prisma.other_employee.findMany({ take: 10 })
     * 
     * // Only select the `essn`
     * const other_employeeWithEssnOnly = await prisma.other_employee.findMany({ select: { essn: true } })
     * 
     */
    findMany<T extends other_employeeFindManyArgs>(args?: SelectSubset<T, other_employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Other_employee.
     * @param {other_employeeCreateArgs} args - Arguments to create a Other_employee.
     * @example
     * // Create one Other_employee
     * const Other_employee = await prisma.other_employee.create({
     *   data: {
     *     // ... data to create a Other_employee
     *   }
     * })
     * 
     */
    create<T extends other_employeeCreateArgs>(args: SelectSubset<T, other_employeeCreateArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Other_employees.
     * @param {other_employeeCreateManyArgs} args - Arguments to create many Other_employees.
     * @example
     * // Create many Other_employees
     * const other_employee = await prisma.other_employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends other_employeeCreateManyArgs>(args?: SelectSubset<T, other_employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Other_employee.
     * @param {other_employeeDeleteArgs} args - Arguments to delete one Other_employee.
     * @example
     * // Delete one Other_employee
     * const Other_employee = await prisma.other_employee.delete({
     *   where: {
     *     // ... filter to delete one Other_employee
     *   }
     * })
     * 
     */
    delete<T extends other_employeeDeleteArgs>(args: SelectSubset<T, other_employeeDeleteArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Other_employee.
     * @param {other_employeeUpdateArgs} args - Arguments to update one Other_employee.
     * @example
     * // Update one Other_employee
     * const other_employee = await prisma.other_employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends other_employeeUpdateArgs>(args: SelectSubset<T, other_employeeUpdateArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Other_employees.
     * @param {other_employeeDeleteManyArgs} args - Arguments to filter Other_employees to delete.
     * @example
     * // Delete a few Other_employees
     * const { count } = await prisma.other_employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends other_employeeDeleteManyArgs>(args?: SelectSubset<T, other_employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Other_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Other_employees
     * const other_employee = await prisma.other_employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends other_employeeUpdateManyArgs>(args: SelectSubset<T, other_employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Other_employee.
     * @param {other_employeeUpsertArgs} args - Arguments to update or create a Other_employee.
     * @example
     * // Update or create a Other_employee
     * const other_employee = await prisma.other_employee.upsert({
     *   create: {
     *     // ... data to create a Other_employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Other_employee we want to update
     *   }
     * })
     */
    upsert<T extends other_employeeUpsertArgs>(args: SelectSubset<T, other_employeeUpsertArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Other_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employeeCountArgs} args - Arguments to filter Other_employees to count.
     * @example
     * // Count the number of Other_employees
     * const count = await prisma.other_employee.count({
     *   where: {
     *     // ... the filter for the Other_employees we want to count
     *   }
     * })
    **/
    count<T extends other_employeeCountArgs>(
      args?: Subset<T, other_employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Other_employeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Other_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Other_employeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Other_employeeAggregateArgs>(args: Subset<T, Other_employeeAggregateArgs>): Prisma.PrismaPromise<GetOther_employeeAggregateType<T>>

    /**
     * Group by Other_employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends other_employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: other_employeeGroupByArgs['orderBy'] }
        : { orderBy?: other_employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, other_employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOther_employeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the other_employee model
   */
  readonly fields: other_employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for other_employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__other_employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    other_room<T extends other_employee$other_roomArgs<ExtArgs> = {}>(args?: Subset<T, other_employee$other_roomArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_employee_time_work<T extends other_employee$other_employee_time_workArgs<ExtArgs> = {}>(args?: Subset<T, other_employee$other_employee_time_workArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the other_employee model
   */
  interface other_employeeFieldRefs {
    readonly essn: FieldRef<"other_employee", 'String'>
    readonly room_id: FieldRef<"other_employee", 'String'>
    readonly building_id: FieldRef<"other_employee", 'String'>
    readonly typeWork: FieldRef<"other_employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * other_employee findUnique
   */
  export type other_employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * Filter, which other_employee to fetch.
     */
    where: other_employeeWhereUniqueInput
  }

  /**
   * other_employee findUniqueOrThrow
   */
  export type other_employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * Filter, which other_employee to fetch.
     */
    where: other_employeeWhereUniqueInput
  }

  /**
   * other_employee findFirst
   */
  export type other_employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * Filter, which other_employee to fetch.
     */
    where?: other_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employees to fetch.
     */
    orderBy?: other_employeeOrderByWithRelationInput | other_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_employees.
     */
    cursor?: other_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_employees.
     */
    distinct?: Other_employeeScalarFieldEnum | Other_employeeScalarFieldEnum[]
  }

  /**
   * other_employee findFirstOrThrow
   */
  export type other_employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * Filter, which other_employee to fetch.
     */
    where?: other_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employees to fetch.
     */
    orderBy?: other_employeeOrderByWithRelationInput | other_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_employees.
     */
    cursor?: other_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_employees.
     */
    distinct?: Other_employeeScalarFieldEnum | Other_employeeScalarFieldEnum[]
  }

  /**
   * other_employee findMany
   */
  export type other_employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * Filter, which other_employees to fetch.
     */
    where?: other_employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employees to fetch.
     */
    orderBy?: other_employeeOrderByWithRelationInput | other_employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing other_employees.
     */
    cursor?: other_employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employees.
     */
    skip?: number
    distinct?: Other_employeeScalarFieldEnum | Other_employeeScalarFieldEnum[]
  }

  /**
   * other_employee create
   */
  export type other_employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a other_employee.
     */
    data: XOR<other_employeeCreateInput, other_employeeUncheckedCreateInput>
  }

  /**
   * other_employee createMany
   */
  export type other_employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many other_employees.
     */
    data: other_employeeCreateManyInput | other_employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * other_employee update
   */
  export type other_employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a other_employee.
     */
    data: XOR<other_employeeUpdateInput, other_employeeUncheckedUpdateInput>
    /**
     * Choose, which other_employee to update.
     */
    where: other_employeeWhereUniqueInput
  }

  /**
   * other_employee updateMany
   */
  export type other_employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update other_employees.
     */
    data: XOR<other_employeeUpdateManyMutationInput, other_employeeUncheckedUpdateManyInput>
    /**
     * Filter which other_employees to update
     */
    where?: other_employeeWhereInput
    /**
     * Limit how many other_employees to update.
     */
    limit?: number
  }

  /**
   * other_employee upsert
   */
  export type other_employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the other_employee to update in case it exists.
     */
    where: other_employeeWhereUniqueInput
    /**
     * In case the other_employee found by the `where` argument doesn't exist, create a new other_employee with this data.
     */
    create: XOR<other_employeeCreateInput, other_employeeUncheckedCreateInput>
    /**
     * In case the other_employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<other_employeeUpdateInput, other_employeeUncheckedUpdateInput>
  }

  /**
   * other_employee delete
   */
  export type other_employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    /**
     * Filter which other_employee to delete.
     */
    where: other_employeeWhereUniqueInput
  }

  /**
   * other_employee deleteMany
   */
  export type other_employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_employees to delete
     */
    where?: other_employeeWhereInput
    /**
     * Limit how many other_employees to delete.
     */
    limit?: number
  }

  /**
   * other_employee.other_room
   */
  export type other_employee$other_roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    where?: other_roomWhereInput
  }

  /**
   * other_employee.other_employee_time_work
   */
  export type other_employee$other_employee_time_workArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    where?: other_employee_time_workWhereInput
    orderBy?: other_employee_time_workOrderByWithRelationInput | other_employee_time_workOrderByWithRelationInput[]
    cursor?: other_employee_time_workWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Other_employee_time_workScalarFieldEnum | Other_employee_time_workScalarFieldEnum[]
  }

  /**
   * other_employee without action
   */
  export type other_employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
  }


  /**
   * Model other_employee_time_work
   */

  export type AggregateOther_employee_time_work = {
    _count: Other_employee_time_workCountAggregateOutputType | null
    _min: Other_employee_time_workMinAggregateOutputType | null
    _max: Other_employee_time_workMaxAggregateOutputType | null
  }

  export type Other_employee_time_workMinAggregateOutputType = {
    essn: string | null
    date_work: $Enums.other_employee_time_work_date_work | null
    time_start: Date | null
    time_end: Date | null
  }

  export type Other_employee_time_workMaxAggregateOutputType = {
    essn: string | null
    date_work: $Enums.other_employee_time_work_date_work | null
    time_start: Date | null
    time_end: Date | null
  }

  export type Other_employee_time_workCountAggregateOutputType = {
    essn: number
    date_work: number
    time_start: number
    time_end: number
    _all: number
  }


  export type Other_employee_time_workMinAggregateInputType = {
    essn?: true
    date_work?: true
    time_start?: true
    time_end?: true
  }

  export type Other_employee_time_workMaxAggregateInputType = {
    essn?: true
    date_work?: true
    time_start?: true
    time_end?: true
  }

  export type Other_employee_time_workCountAggregateInputType = {
    essn?: true
    date_work?: true
    time_start?: true
    time_end?: true
    _all?: true
  }

  export type Other_employee_time_workAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_employee_time_work to aggregate.
     */
    where?: other_employee_time_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employee_time_works to fetch.
     */
    orderBy?: other_employee_time_workOrderByWithRelationInput | other_employee_time_workOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: other_employee_time_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employee_time_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employee_time_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned other_employee_time_works
    **/
    _count?: true | Other_employee_time_workCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Other_employee_time_workMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Other_employee_time_workMaxAggregateInputType
  }

  export type GetOther_employee_time_workAggregateType<T extends Other_employee_time_workAggregateArgs> = {
        [P in keyof T & keyof AggregateOther_employee_time_work]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOther_employee_time_work[P]>
      : GetScalarType<T[P], AggregateOther_employee_time_work[P]>
  }




  export type other_employee_time_workGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: other_employee_time_workWhereInput
    orderBy?: other_employee_time_workOrderByWithAggregationInput | other_employee_time_workOrderByWithAggregationInput[]
    by: Other_employee_time_workScalarFieldEnum[] | Other_employee_time_workScalarFieldEnum
    having?: other_employee_time_workScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Other_employee_time_workCountAggregateInputType | true
    _min?: Other_employee_time_workMinAggregateInputType
    _max?: Other_employee_time_workMaxAggregateInputType
  }

  export type Other_employee_time_workGroupByOutputType = {
    essn: string
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date
    time_end: Date
    _count: Other_employee_time_workCountAggregateOutputType | null
    _min: Other_employee_time_workMinAggregateOutputType | null
    _max: Other_employee_time_workMaxAggregateOutputType | null
  }

  type GetOther_employee_time_workGroupByPayload<T extends other_employee_time_workGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Other_employee_time_workGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Other_employee_time_workGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Other_employee_time_workGroupByOutputType[P]>
            : GetScalarType<T[P], Other_employee_time_workGroupByOutputType[P]>
        }
      >
    >


  export type other_employee_time_workSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    essn?: boolean
    date_work?: boolean
    time_start?: boolean
    time_end?: boolean
    other_employee?: boolean | other_employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["other_employee_time_work"]>



  export type other_employee_time_workSelectScalar = {
    essn?: boolean
    date_work?: boolean
    time_start?: boolean
    time_end?: boolean
  }

  export type other_employee_time_workOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"essn" | "date_work" | "time_start" | "time_end", ExtArgs["result"]["other_employee_time_work"]>
  export type other_employee_time_workInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_employee?: boolean | other_employeeDefaultArgs<ExtArgs>
  }

  export type $other_employee_time_workPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "other_employee_time_work"
    objects: {
      other_employee: Prisma.$other_employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      essn: string
      date_work: $Enums.other_employee_time_work_date_work
      time_start: Date
      time_end: Date
    }, ExtArgs["result"]["other_employee_time_work"]>
    composites: {}
  }

  type other_employee_time_workGetPayload<S extends boolean | null | undefined | other_employee_time_workDefaultArgs> = $Result.GetResult<Prisma.$other_employee_time_workPayload, S>

  type other_employee_time_workCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<other_employee_time_workFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Other_employee_time_workCountAggregateInputType | true
    }

  export interface other_employee_time_workDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['other_employee_time_work'], meta: { name: 'other_employee_time_work' } }
    /**
     * Find zero or one Other_employee_time_work that matches the filter.
     * @param {other_employee_time_workFindUniqueArgs} args - Arguments to find a Other_employee_time_work
     * @example
     * // Get one Other_employee_time_work
     * const other_employee_time_work = await prisma.other_employee_time_work.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends other_employee_time_workFindUniqueArgs>(args: SelectSubset<T, other_employee_time_workFindUniqueArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Other_employee_time_work that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {other_employee_time_workFindUniqueOrThrowArgs} args - Arguments to find a Other_employee_time_work
     * @example
     * // Get one Other_employee_time_work
     * const other_employee_time_work = await prisma.other_employee_time_work.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends other_employee_time_workFindUniqueOrThrowArgs>(args: SelectSubset<T, other_employee_time_workFindUniqueOrThrowArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_employee_time_work that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employee_time_workFindFirstArgs} args - Arguments to find a Other_employee_time_work
     * @example
     * // Get one Other_employee_time_work
     * const other_employee_time_work = await prisma.other_employee_time_work.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends other_employee_time_workFindFirstArgs>(args?: SelectSubset<T, other_employee_time_workFindFirstArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_employee_time_work that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employee_time_workFindFirstOrThrowArgs} args - Arguments to find a Other_employee_time_work
     * @example
     * // Get one Other_employee_time_work
     * const other_employee_time_work = await prisma.other_employee_time_work.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends other_employee_time_workFindFirstOrThrowArgs>(args?: SelectSubset<T, other_employee_time_workFindFirstOrThrowArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Other_employee_time_works that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employee_time_workFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Other_employee_time_works
     * const other_employee_time_works = await prisma.other_employee_time_work.findMany()
     * 
     * // Get first 10 Other_employee_time_works
     * const other_employee_time_works = await prisma.other_employee_time_work.findMany({ take: 10 })
     * 
     * // Only select the `essn`
     * const other_employee_time_workWithEssnOnly = await prisma.other_employee_time_work.findMany({ select: { essn: true } })
     * 
     */
    findMany<T extends other_employee_time_workFindManyArgs>(args?: SelectSubset<T, other_employee_time_workFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Other_employee_time_work.
     * @param {other_employee_time_workCreateArgs} args - Arguments to create a Other_employee_time_work.
     * @example
     * // Create one Other_employee_time_work
     * const Other_employee_time_work = await prisma.other_employee_time_work.create({
     *   data: {
     *     // ... data to create a Other_employee_time_work
     *   }
     * })
     * 
     */
    create<T extends other_employee_time_workCreateArgs>(args: SelectSubset<T, other_employee_time_workCreateArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Other_employee_time_works.
     * @param {other_employee_time_workCreateManyArgs} args - Arguments to create many Other_employee_time_works.
     * @example
     * // Create many Other_employee_time_works
     * const other_employee_time_work = await prisma.other_employee_time_work.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends other_employee_time_workCreateManyArgs>(args?: SelectSubset<T, other_employee_time_workCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Other_employee_time_work.
     * @param {other_employee_time_workDeleteArgs} args - Arguments to delete one Other_employee_time_work.
     * @example
     * // Delete one Other_employee_time_work
     * const Other_employee_time_work = await prisma.other_employee_time_work.delete({
     *   where: {
     *     // ... filter to delete one Other_employee_time_work
     *   }
     * })
     * 
     */
    delete<T extends other_employee_time_workDeleteArgs>(args: SelectSubset<T, other_employee_time_workDeleteArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Other_employee_time_work.
     * @param {other_employee_time_workUpdateArgs} args - Arguments to update one Other_employee_time_work.
     * @example
     * // Update one Other_employee_time_work
     * const other_employee_time_work = await prisma.other_employee_time_work.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends other_employee_time_workUpdateArgs>(args: SelectSubset<T, other_employee_time_workUpdateArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Other_employee_time_works.
     * @param {other_employee_time_workDeleteManyArgs} args - Arguments to filter Other_employee_time_works to delete.
     * @example
     * // Delete a few Other_employee_time_works
     * const { count } = await prisma.other_employee_time_work.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends other_employee_time_workDeleteManyArgs>(args?: SelectSubset<T, other_employee_time_workDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Other_employee_time_works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employee_time_workUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Other_employee_time_works
     * const other_employee_time_work = await prisma.other_employee_time_work.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends other_employee_time_workUpdateManyArgs>(args: SelectSubset<T, other_employee_time_workUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Other_employee_time_work.
     * @param {other_employee_time_workUpsertArgs} args - Arguments to update or create a Other_employee_time_work.
     * @example
     * // Update or create a Other_employee_time_work
     * const other_employee_time_work = await prisma.other_employee_time_work.upsert({
     *   create: {
     *     // ... data to create a Other_employee_time_work
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Other_employee_time_work we want to update
     *   }
     * })
     */
    upsert<T extends other_employee_time_workUpsertArgs>(args: SelectSubset<T, other_employee_time_workUpsertArgs<ExtArgs>>): Prisma__other_employee_time_workClient<$Result.GetResult<Prisma.$other_employee_time_workPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Other_employee_time_works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employee_time_workCountArgs} args - Arguments to filter Other_employee_time_works to count.
     * @example
     * // Count the number of Other_employee_time_works
     * const count = await prisma.other_employee_time_work.count({
     *   where: {
     *     // ... the filter for the Other_employee_time_works we want to count
     *   }
     * })
    **/
    count<T extends other_employee_time_workCountArgs>(
      args?: Subset<T, other_employee_time_workCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Other_employee_time_workCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Other_employee_time_work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Other_employee_time_workAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Other_employee_time_workAggregateArgs>(args: Subset<T, Other_employee_time_workAggregateArgs>): Prisma.PrismaPromise<GetOther_employee_time_workAggregateType<T>>

    /**
     * Group by Other_employee_time_work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_employee_time_workGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends other_employee_time_workGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: other_employee_time_workGroupByArgs['orderBy'] }
        : { orderBy?: other_employee_time_workGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, other_employee_time_workGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOther_employee_time_workGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the other_employee_time_work model
   */
  readonly fields: other_employee_time_workFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for other_employee_time_work.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__other_employee_time_workClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    other_employee<T extends other_employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, other_employeeDefaultArgs<ExtArgs>>): Prisma__other_employeeClient<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the other_employee_time_work model
   */
  interface other_employee_time_workFieldRefs {
    readonly essn: FieldRef<"other_employee_time_work", 'String'>
    readonly date_work: FieldRef<"other_employee_time_work", 'other_employee_time_work_date_work'>
    readonly time_start: FieldRef<"other_employee_time_work", 'DateTime'>
    readonly time_end: FieldRef<"other_employee_time_work", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * other_employee_time_work findUnique
   */
  export type other_employee_time_workFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * Filter, which other_employee_time_work to fetch.
     */
    where: other_employee_time_workWhereUniqueInput
  }

  /**
   * other_employee_time_work findUniqueOrThrow
   */
  export type other_employee_time_workFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * Filter, which other_employee_time_work to fetch.
     */
    where: other_employee_time_workWhereUniqueInput
  }

  /**
   * other_employee_time_work findFirst
   */
  export type other_employee_time_workFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * Filter, which other_employee_time_work to fetch.
     */
    where?: other_employee_time_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employee_time_works to fetch.
     */
    orderBy?: other_employee_time_workOrderByWithRelationInput | other_employee_time_workOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_employee_time_works.
     */
    cursor?: other_employee_time_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employee_time_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employee_time_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_employee_time_works.
     */
    distinct?: Other_employee_time_workScalarFieldEnum | Other_employee_time_workScalarFieldEnum[]
  }

  /**
   * other_employee_time_work findFirstOrThrow
   */
  export type other_employee_time_workFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * Filter, which other_employee_time_work to fetch.
     */
    where?: other_employee_time_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employee_time_works to fetch.
     */
    orderBy?: other_employee_time_workOrderByWithRelationInput | other_employee_time_workOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_employee_time_works.
     */
    cursor?: other_employee_time_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employee_time_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employee_time_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_employee_time_works.
     */
    distinct?: Other_employee_time_workScalarFieldEnum | Other_employee_time_workScalarFieldEnum[]
  }

  /**
   * other_employee_time_work findMany
   */
  export type other_employee_time_workFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * Filter, which other_employee_time_works to fetch.
     */
    where?: other_employee_time_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_employee_time_works to fetch.
     */
    orderBy?: other_employee_time_workOrderByWithRelationInput | other_employee_time_workOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing other_employee_time_works.
     */
    cursor?: other_employee_time_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_employee_time_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_employee_time_works.
     */
    skip?: number
    distinct?: Other_employee_time_workScalarFieldEnum | Other_employee_time_workScalarFieldEnum[]
  }

  /**
   * other_employee_time_work create
   */
  export type other_employee_time_workCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * The data needed to create a other_employee_time_work.
     */
    data: XOR<other_employee_time_workCreateInput, other_employee_time_workUncheckedCreateInput>
  }

  /**
   * other_employee_time_work createMany
   */
  export type other_employee_time_workCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many other_employee_time_works.
     */
    data: other_employee_time_workCreateManyInput | other_employee_time_workCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * other_employee_time_work update
   */
  export type other_employee_time_workUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * The data needed to update a other_employee_time_work.
     */
    data: XOR<other_employee_time_workUpdateInput, other_employee_time_workUncheckedUpdateInput>
    /**
     * Choose, which other_employee_time_work to update.
     */
    where: other_employee_time_workWhereUniqueInput
  }

  /**
   * other_employee_time_work updateMany
   */
  export type other_employee_time_workUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update other_employee_time_works.
     */
    data: XOR<other_employee_time_workUpdateManyMutationInput, other_employee_time_workUncheckedUpdateManyInput>
    /**
     * Filter which other_employee_time_works to update
     */
    where?: other_employee_time_workWhereInput
    /**
     * Limit how many other_employee_time_works to update.
     */
    limit?: number
  }

  /**
   * other_employee_time_work upsert
   */
  export type other_employee_time_workUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * The filter to search for the other_employee_time_work to update in case it exists.
     */
    where: other_employee_time_workWhereUniqueInput
    /**
     * In case the other_employee_time_work found by the `where` argument doesn't exist, create a new other_employee_time_work with this data.
     */
    create: XOR<other_employee_time_workCreateInput, other_employee_time_workUncheckedCreateInput>
    /**
     * In case the other_employee_time_work was found with the provided `where` argument, update it with this data.
     */
    update: XOR<other_employee_time_workUpdateInput, other_employee_time_workUncheckedUpdateInput>
  }

  /**
   * other_employee_time_work delete
   */
  export type other_employee_time_workDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
    /**
     * Filter which other_employee_time_work to delete.
     */
    where: other_employee_time_workWhereUniqueInput
  }

  /**
   * other_employee_time_work deleteMany
   */
  export type other_employee_time_workDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_employee_time_works to delete
     */
    where?: other_employee_time_workWhereInput
    /**
     * Limit how many other_employee_time_works to delete.
     */
    limit?: number
  }

  /**
   * other_employee_time_work without action
   */
  export type other_employee_time_workDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee_time_work
     */
    select?: other_employee_time_workSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee_time_work
     */
    omit?: other_employee_time_workOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employee_time_workInclude<ExtArgs> | null
  }


  /**
   * Model other_room
   */

  export type AggregateOther_room = {
    _count: Other_roomCountAggregateOutputType | null
    _avg: Other_roomAvgAggregateOutputType | null
    _sum: Other_roomSumAggregateOutputType | null
    _min: Other_roomMinAggregateOutputType | null
    _max: Other_roomMaxAggregateOutputType | null
  }

  export type Other_roomAvgAggregateOutputType = {
    num_of_staff: number | null
  }

  export type Other_roomSumAggregateOutputType = {
    num_of_staff: number | null
  }

  export type Other_roomMinAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    room_type: string | null
    num_of_staff: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Other_roomMaxAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    room_type: string | null
    num_of_staff: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Other_roomCountAggregateOutputType = {
    building_id: number
    room_id: number
    room_type: number
    num_of_staff: number
    start_time: number
    end_time: number
    _all: number
  }


  export type Other_roomAvgAggregateInputType = {
    num_of_staff?: true
  }

  export type Other_roomSumAggregateInputType = {
    num_of_staff?: true
  }

  export type Other_roomMinAggregateInputType = {
    building_id?: true
    room_id?: true
    room_type?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
  }

  export type Other_roomMaxAggregateInputType = {
    building_id?: true
    room_id?: true
    room_type?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
  }

  export type Other_roomCountAggregateInputType = {
    building_id?: true
    room_id?: true
    room_type?: true
    num_of_staff?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type Other_roomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_room to aggregate.
     */
    where?: other_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_rooms to fetch.
     */
    orderBy?: other_roomOrderByWithRelationInput | other_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: other_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned other_rooms
    **/
    _count?: true | Other_roomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Other_roomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Other_roomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Other_roomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Other_roomMaxAggregateInputType
  }

  export type GetOther_roomAggregateType<T extends Other_roomAggregateArgs> = {
        [P in keyof T & keyof AggregateOther_room]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOther_room[P]>
      : GetScalarType<T[P], AggregateOther_room[P]>
  }




  export type other_roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: other_roomWhereInput
    orderBy?: other_roomOrderByWithAggregationInput | other_roomOrderByWithAggregationInput[]
    by: Other_roomScalarFieldEnum[] | Other_roomScalarFieldEnum
    having?: other_roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Other_roomCountAggregateInputType | true
    _avg?: Other_roomAvgAggregateInputType
    _sum?: Other_roomSumAggregateInputType
    _min?: Other_roomMinAggregateInputType
    _max?: Other_roomMaxAggregateInputType
  }

  export type Other_roomGroupByOutputType = {
    building_id: string
    room_id: string
    room_type: string
    num_of_staff: number
    start_time: Date
    end_time: Date
    _count: Other_roomCountAggregateOutputType | null
    _avg: Other_roomAvgAggregateOutputType | null
    _sum: Other_roomSumAggregateOutputType | null
    _min: Other_roomMinAggregateOutputType | null
    _max: Other_roomMaxAggregateOutputType | null
  }

  type GetOther_roomGroupByPayload<T extends other_roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Other_roomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Other_roomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Other_roomGroupByOutputType[P]>
            : GetScalarType<T[P], Other_roomGroupByOutputType[P]>
        }
      >
    >


  export type other_roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    building_id?: boolean
    room_id?: boolean
    room_type?: boolean
    num_of_staff?: boolean
    start_time?: boolean
    end_time?: boolean
    other_employee?: boolean | other_room$other_employeeArgs<ExtArgs>
    room?: boolean | roomDefaultArgs<ExtArgs>
    _count?: boolean | Other_roomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["other_room"]>



  export type other_roomSelectScalar = {
    building_id?: boolean
    room_id?: boolean
    room_type?: boolean
    num_of_staff?: boolean
    start_time?: boolean
    end_time?: boolean
  }

  export type other_roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"building_id" | "room_id" | "room_type" | "num_of_staff" | "start_time" | "end_time", ExtArgs["result"]["other_room"]>
  export type other_roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_employee?: boolean | other_room$other_employeeArgs<ExtArgs>
    room?: boolean | roomDefaultArgs<ExtArgs>
    _count?: boolean | Other_roomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $other_roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "other_room"
    objects: {
      other_employee: Prisma.$other_employeePayload<ExtArgs>[]
      room: Prisma.$roomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      building_id: string
      room_id: string
      room_type: string
      num_of_staff: number
      start_time: Date
      end_time: Date
    }, ExtArgs["result"]["other_room"]>
    composites: {}
  }

  type other_roomGetPayload<S extends boolean | null | undefined | other_roomDefaultArgs> = $Result.GetResult<Prisma.$other_roomPayload, S>

  type other_roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<other_roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Other_roomCountAggregateInputType | true
    }

  export interface other_roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['other_room'], meta: { name: 'other_room' } }
    /**
     * Find zero or one Other_room that matches the filter.
     * @param {other_roomFindUniqueArgs} args - Arguments to find a Other_room
     * @example
     * // Get one Other_room
     * const other_room = await prisma.other_room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends other_roomFindUniqueArgs>(args: SelectSubset<T, other_roomFindUniqueArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Other_room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {other_roomFindUniqueOrThrowArgs} args - Arguments to find a Other_room
     * @example
     * // Get one Other_room
     * const other_room = await prisma.other_room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends other_roomFindUniqueOrThrowArgs>(args: SelectSubset<T, other_roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_roomFindFirstArgs} args - Arguments to find a Other_room
     * @example
     * // Get one Other_room
     * const other_room = await prisma.other_room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends other_roomFindFirstArgs>(args?: SelectSubset<T, other_roomFindFirstArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_roomFindFirstOrThrowArgs} args - Arguments to find a Other_room
     * @example
     * // Get one Other_room
     * const other_room = await prisma.other_room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends other_roomFindFirstOrThrowArgs>(args?: SelectSubset<T, other_roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Other_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Other_rooms
     * const other_rooms = await prisma.other_room.findMany()
     * 
     * // Get first 10 Other_rooms
     * const other_rooms = await prisma.other_room.findMany({ take: 10 })
     * 
     * // Only select the `building_id`
     * const other_roomWithBuilding_idOnly = await prisma.other_room.findMany({ select: { building_id: true } })
     * 
     */
    findMany<T extends other_roomFindManyArgs>(args?: SelectSubset<T, other_roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Other_room.
     * @param {other_roomCreateArgs} args - Arguments to create a Other_room.
     * @example
     * // Create one Other_room
     * const Other_room = await prisma.other_room.create({
     *   data: {
     *     // ... data to create a Other_room
     *   }
     * })
     * 
     */
    create<T extends other_roomCreateArgs>(args: SelectSubset<T, other_roomCreateArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Other_rooms.
     * @param {other_roomCreateManyArgs} args - Arguments to create many Other_rooms.
     * @example
     * // Create many Other_rooms
     * const other_room = await prisma.other_room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends other_roomCreateManyArgs>(args?: SelectSubset<T, other_roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Other_room.
     * @param {other_roomDeleteArgs} args - Arguments to delete one Other_room.
     * @example
     * // Delete one Other_room
     * const Other_room = await prisma.other_room.delete({
     *   where: {
     *     // ... filter to delete one Other_room
     *   }
     * })
     * 
     */
    delete<T extends other_roomDeleteArgs>(args: SelectSubset<T, other_roomDeleteArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Other_room.
     * @param {other_roomUpdateArgs} args - Arguments to update one Other_room.
     * @example
     * // Update one Other_room
     * const other_room = await prisma.other_room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends other_roomUpdateArgs>(args: SelectSubset<T, other_roomUpdateArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Other_rooms.
     * @param {other_roomDeleteManyArgs} args - Arguments to filter Other_rooms to delete.
     * @example
     * // Delete a few Other_rooms
     * const { count } = await prisma.other_room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends other_roomDeleteManyArgs>(args?: SelectSubset<T, other_roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Other_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Other_rooms
     * const other_room = await prisma.other_room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends other_roomUpdateManyArgs>(args: SelectSubset<T, other_roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Other_room.
     * @param {other_roomUpsertArgs} args - Arguments to update or create a Other_room.
     * @example
     * // Update or create a Other_room
     * const other_room = await prisma.other_room.upsert({
     *   create: {
     *     // ... data to create a Other_room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Other_room we want to update
     *   }
     * })
     */
    upsert<T extends other_roomUpsertArgs>(args: SelectSubset<T, other_roomUpsertArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Other_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_roomCountArgs} args - Arguments to filter Other_rooms to count.
     * @example
     * // Count the number of Other_rooms
     * const count = await prisma.other_room.count({
     *   where: {
     *     // ... the filter for the Other_rooms we want to count
     *   }
     * })
    **/
    count<T extends other_roomCountArgs>(
      args?: Subset<T, other_roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Other_roomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Other_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Other_roomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Other_roomAggregateArgs>(args: Subset<T, Other_roomAggregateArgs>): Prisma.PrismaPromise<GetOther_roomAggregateType<T>>

    /**
     * Group by Other_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends other_roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: other_roomGroupByArgs['orderBy'] }
        : { orderBy?: other_roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, other_roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOther_roomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the other_room model
   */
  readonly fields: other_roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for other_room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__other_roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    other_employee<T extends other_room$other_employeeArgs<ExtArgs> = {}>(args?: Subset<T, other_room$other_employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room<T extends roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roomDefaultArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the other_room model
   */
  interface other_roomFieldRefs {
    readonly building_id: FieldRef<"other_room", 'String'>
    readonly room_id: FieldRef<"other_room", 'String'>
    readonly room_type: FieldRef<"other_room", 'String'>
    readonly num_of_staff: FieldRef<"other_room", 'Int'>
    readonly start_time: FieldRef<"other_room", 'DateTime'>
    readonly end_time: FieldRef<"other_room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * other_room findUnique
   */
  export type other_roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * Filter, which other_room to fetch.
     */
    where: other_roomWhereUniqueInput
  }

  /**
   * other_room findUniqueOrThrow
   */
  export type other_roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * Filter, which other_room to fetch.
     */
    where: other_roomWhereUniqueInput
  }

  /**
   * other_room findFirst
   */
  export type other_roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * Filter, which other_room to fetch.
     */
    where?: other_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_rooms to fetch.
     */
    orderBy?: other_roomOrderByWithRelationInput | other_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_rooms.
     */
    cursor?: other_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_rooms.
     */
    distinct?: Other_roomScalarFieldEnum | Other_roomScalarFieldEnum[]
  }

  /**
   * other_room findFirstOrThrow
   */
  export type other_roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * Filter, which other_room to fetch.
     */
    where?: other_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_rooms to fetch.
     */
    orderBy?: other_roomOrderByWithRelationInput | other_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_rooms.
     */
    cursor?: other_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_rooms.
     */
    distinct?: Other_roomScalarFieldEnum | Other_roomScalarFieldEnum[]
  }

  /**
   * other_room findMany
   */
  export type other_roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * Filter, which other_rooms to fetch.
     */
    where?: other_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_rooms to fetch.
     */
    orderBy?: other_roomOrderByWithRelationInput | other_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing other_rooms.
     */
    cursor?: other_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_rooms.
     */
    skip?: number
    distinct?: Other_roomScalarFieldEnum | Other_roomScalarFieldEnum[]
  }

  /**
   * other_room create
   */
  export type other_roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * The data needed to create a other_room.
     */
    data: XOR<other_roomCreateInput, other_roomUncheckedCreateInput>
  }

  /**
   * other_room createMany
   */
  export type other_roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many other_rooms.
     */
    data: other_roomCreateManyInput | other_roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * other_room update
   */
  export type other_roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * The data needed to update a other_room.
     */
    data: XOR<other_roomUpdateInput, other_roomUncheckedUpdateInput>
    /**
     * Choose, which other_room to update.
     */
    where: other_roomWhereUniqueInput
  }

  /**
   * other_room updateMany
   */
  export type other_roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update other_rooms.
     */
    data: XOR<other_roomUpdateManyMutationInput, other_roomUncheckedUpdateManyInput>
    /**
     * Filter which other_rooms to update
     */
    where?: other_roomWhereInput
    /**
     * Limit how many other_rooms to update.
     */
    limit?: number
  }

  /**
   * other_room upsert
   */
  export type other_roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * The filter to search for the other_room to update in case it exists.
     */
    where: other_roomWhereUniqueInput
    /**
     * In case the other_room found by the `where` argument doesn't exist, create a new other_room with this data.
     */
    create: XOR<other_roomCreateInput, other_roomUncheckedCreateInput>
    /**
     * In case the other_room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<other_roomUpdateInput, other_roomUncheckedUpdateInput>
  }

  /**
   * other_room delete
   */
  export type other_roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    /**
     * Filter which other_room to delete.
     */
    where: other_roomWhereUniqueInput
  }

  /**
   * other_room deleteMany
   */
  export type other_roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_rooms to delete
     */
    where?: other_roomWhereInput
    /**
     * Limit how many other_rooms to delete.
     */
    limit?: number
  }

  /**
   * other_room.other_employee
   */
  export type other_room$other_employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_employee
     */
    select?: other_employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_employee
     */
    omit?: other_employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_employeeInclude<ExtArgs> | null
    where?: other_employeeWhereInput
    orderBy?: other_employeeOrderByWithRelationInput | other_employeeOrderByWithRelationInput[]
    cursor?: other_employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Other_employeeScalarFieldEnum | Other_employeeScalarFieldEnum[]
  }

  /**
   * other_room without action
   */
  export type other_roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
  }


  /**
   * Model relative
   */

  export type AggregateRelative = {
    _count: RelativeCountAggregateOutputType | null
    _min: RelativeMinAggregateOutputType | null
    _max: RelativeMaxAggregateOutputType | null
  }

  export type RelativeMinAggregateOutputType = {
    Sssn: string | null
    fname: string | null
    lname: string | null
    birthday: Date | null
    relationship: string | null
    address: string | null
    phoneNumber: string | null
    job: string | null
  }

  export type RelativeMaxAggregateOutputType = {
    Sssn: string | null
    fname: string | null
    lname: string | null
    birthday: Date | null
    relationship: string | null
    address: string | null
    phoneNumber: string | null
    job: string | null
  }

  export type RelativeCountAggregateOutputType = {
    Sssn: number
    fname: number
    lname: number
    birthday: number
    relationship: number
    address: number
    phoneNumber: number
    job: number
    _all: number
  }


  export type RelativeMinAggregateInputType = {
    Sssn?: true
    fname?: true
    lname?: true
    birthday?: true
    relationship?: true
    address?: true
    phoneNumber?: true
    job?: true
  }

  export type RelativeMaxAggregateInputType = {
    Sssn?: true
    fname?: true
    lname?: true
    birthday?: true
    relationship?: true
    address?: true
    phoneNumber?: true
    job?: true
  }

  export type RelativeCountAggregateInputType = {
    Sssn?: true
    fname?: true
    lname?: true
    birthday?: true
    relationship?: true
    address?: true
    phoneNumber?: true
    job?: true
    _all?: true
  }

  export type RelativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which relative to aggregate.
     */
    where?: relativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatives to fetch.
     */
    orderBy?: relativeOrderByWithRelationInput | relativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: relativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned relatives
    **/
    _count?: true | RelativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelativeMaxAggregateInputType
  }

  export type GetRelativeAggregateType<T extends RelativeAggregateArgs> = {
        [P in keyof T & keyof AggregateRelative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelative[P]>
      : GetScalarType<T[P], AggregateRelative[P]>
  }




  export type relativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: relativeWhereInput
    orderBy?: relativeOrderByWithAggregationInput | relativeOrderByWithAggregationInput[]
    by: RelativeScalarFieldEnum[] | RelativeScalarFieldEnum
    having?: relativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelativeCountAggregateInputType | true
    _min?: RelativeMinAggregateInputType
    _max?: RelativeMaxAggregateInputType
  }

  export type RelativeGroupByOutputType = {
    Sssn: string
    fname: string
    lname: string
    birthday: Date
    relationship: string
    address: string
    phoneNumber: string | null
    job: string | null
    _count: RelativeCountAggregateOutputType | null
    _min: RelativeMinAggregateOutputType | null
    _max: RelativeMaxAggregateOutputType | null
  }

  type GetRelativeGroupByPayload<T extends relativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelativeGroupByOutputType[P]>
            : GetScalarType<T[P], RelativeGroupByOutputType[P]>
        }
      >
    >


  export type relativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Sssn?: boolean
    fname?: boolean
    lname?: boolean
    birthday?: boolean
    relationship?: boolean
    address?: boolean
    phoneNumber?: boolean
    job?: boolean
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relative"]>



  export type relativeSelectScalar = {
    Sssn?: boolean
    fname?: boolean
    lname?: boolean
    birthday?: boolean
    relationship?: boolean
    address?: boolean
    phoneNumber?: boolean
    job?: boolean
  }

  export type relativeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Sssn" | "fname" | "lname" | "birthday" | "relationship" | "address" | "phoneNumber" | "job", ExtArgs["result"]["relative"]>
  export type relativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | studentDefaultArgs<ExtArgs>
  }

  export type $relativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "relative"
    objects: {
      student: Prisma.$studentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Sssn: string
      fname: string
      lname: string
      birthday: Date
      relationship: string
      address: string
      phoneNumber: string | null
      job: string | null
    }, ExtArgs["result"]["relative"]>
    composites: {}
  }

  type relativeGetPayload<S extends boolean | null | undefined | relativeDefaultArgs> = $Result.GetResult<Prisma.$relativePayload, S>

  type relativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<relativeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelativeCountAggregateInputType | true
    }

  export interface relativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['relative'], meta: { name: 'relative' } }
    /**
     * Find zero or one Relative that matches the filter.
     * @param {relativeFindUniqueArgs} args - Arguments to find a Relative
     * @example
     * // Get one Relative
     * const relative = await prisma.relative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends relativeFindUniqueArgs>(args: SelectSubset<T, relativeFindUniqueArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Relative that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {relativeFindUniqueOrThrowArgs} args - Arguments to find a Relative
     * @example
     * // Get one Relative
     * const relative = await prisma.relative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends relativeFindUniqueOrThrowArgs>(args: SelectSubset<T, relativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Relative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relativeFindFirstArgs} args - Arguments to find a Relative
     * @example
     * // Get one Relative
     * const relative = await prisma.relative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends relativeFindFirstArgs>(args?: SelectSubset<T, relativeFindFirstArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Relative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relativeFindFirstOrThrowArgs} args - Arguments to find a Relative
     * @example
     * // Get one Relative
     * const relative = await prisma.relative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends relativeFindFirstOrThrowArgs>(args?: SelectSubset<T, relativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Relatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relatives
     * const relatives = await prisma.relative.findMany()
     * 
     * // Get first 10 Relatives
     * const relatives = await prisma.relative.findMany({ take: 10 })
     * 
     * // Only select the `Sssn`
     * const relativeWithSssnOnly = await prisma.relative.findMany({ select: { Sssn: true } })
     * 
     */
    findMany<T extends relativeFindManyArgs>(args?: SelectSubset<T, relativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Relative.
     * @param {relativeCreateArgs} args - Arguments to create a Relative.
     * @example
     * // Create one Relative
     * const Relative = await prisma.relative.create({
     *   data: {
     *     // ... data to create a Relative
     *   }
     * })
     * 
     */
    create<T extends relativeCreateArgs>(args: SelectSubset<T, relativeCreateArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Relatives.
     * @param {relativeCreateManyArgs} args - Arguments to create many Relatives.
     * @example
     * // Create many Relatives
     * const relative = await prisma.relative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends relativeCreateManyArgs>(args?: SelectSubset<T, relativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Relative.
     * @param {relativeDeleteArgs} args - Arguments to delete one Relative.
     * @example
     * // Delete one Relative
     * const Relative = await prisma.relative.delete({
     *   where: {
     *     // ... filter to delete one Relative
     *   }
     * })
     * 
     */
    delete<T extends relativeDeleteArgs>(args: SelectSubset<T, relativeDeleteArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Relative.
     * @param {relativeUpdateArgs} args - Arguments to update one Relative.
     * @example
     * // Update one Relative
     * const relative = await prisma.relative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends relativeUpdateArgs>(args: SelectSubset<T, relativeUpdateArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Relatives.
     * @param {relativeDeleteManyArgs} args - Arguments to filter Relatives to delete.
     * @example
     * // Delete a few Relatives
     * const { count } = await prisma.relative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends relativeDeleteManyArgs>(args?: SelectSubset<T, relativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relatives
     * const relative = await prisma.relative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends relativeUpdateManyArgs>(args: SelectSubset<T, relativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relative.
     * @param {relativeUpsertArgs} args - Arguments to update or create a Relative.
     * @example
     * // Update or create a Relative
     * const relative = await prisma.relative.upsert({
     *   create: {
     *     // ... data to create a Relative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relative we want to update
     *   }
     * })
     */
    upsert<T extends relativeUpsertArgs>(args: SelectSubset<T, relativeUpsertArgs<ExtArgs>>): Prisma__relativeClient<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Relatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relativeCountArgs} args - Arguments to filter Relatives to count.
     * @example
     * // Count the number of Relatives
     * const count = await prisma.relative.count({
     *   where: {
     *     // ... the filter for the Relatives we want to count
     *   }
     * })
    **/
    count<T extends relativeCountArgs>(
      args?: Subset<T, relativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelativeAggregateArgs>(args: Subset<T, RelativeAggregateArgs>): Prisma.PrismaPromise<GetRelativeAggregateType<T>>

    /**
     * Group by Relative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends relativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: relativeGroupByArgs['orderBy'] }
        : { orderBy?: relativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, relativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the relative model
   */
  readonly fields: relativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for relative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__relativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the relative model
   */
  interface relativeFieldRefs {
    readonly Sssn: FieldRef<"relative", 'String'>
    readonly fname: FieldRef<"relative", 'String'>
    readonly lname: FieldRef<"relative", 'String'>
    readonly birthday: FieldRef<"relative", 'DateTime'>
    readonly relationship: FieldRef<"relative", 'String'>
    readonly address: FieldRef<"relative", 'String'>
    readonly phoneNumber: FieldRef<"relative", 'String'>
    readonly job: FieldRef<"relative", 'String'>
  }
    

  // Custom InputTypes
  /**
   * relative findUnique
   */
  export type relativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * Filter, which relative to fetch.
     */
    where: relativeWhereUniqueInput
  }

  /**
   * relative findUniqueOrThrow
   */
  export type relativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * Filter, which relative to fetch.
     */
    where: relativeWhereUniqueInput
  }

  /**
   * relative findFirst
   */
  export type relativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * Filter, which relative to fetch.
     */
    where?: relativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatives to fetch.
     */
    orderBy?: relativeOrderByWithRelationInput | relativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relatives.
     */
    cursor?: relativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relatives.
     */
    distinct?: RelativeScalarFieldEnum | RelativeScalarFieldEnum[]
  }

  /**
   * relative findFirstOrThrow
   */
  export type relativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * Filter, which relative to fetch.
     */
    where?: relativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatives to fetch.
     */
    orderBy?: relativeOrderByWithRelationInput | relativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relatives.
     */
    cursor?: relativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relatives.
     */
    distinct?: RelativeScalarFieldEnum | RelativeScalarFieldEnum[]
  }

  /**
   * relative findMany
   */
  export type relativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * Filter, which relatives to fetch.
     */
    where?: relativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatives to fetch.
     */
    orderBy?: relativeOrderByWithRelationInput | relativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing relatives.
     */
    cursor?: relativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatives.
     */
    skip?: number
    distinct?: RelativeScalarFieldEnum | RelativeScalarFieldEnum[]
  }

  /**
   * relative create
   */
  export type relativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * The data needed to create a relative.
     */
    data: XOR<relativeCreateInput, relativeUncheckedCreateInput>
  }

  /**
   * relative createMany
   */
  export type relativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many relatives.
     */
    data: relativeCreateManyInput | relativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * relative update
   */
  export type relativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * The data needed to update a relative.
     */
    data: XOR<relativeUpdateInput, relativeUncheckedUpdateInput>
    /**
     * Choose, which relative to update.
     */
    where: relativeWhereUniqueInput
  }

  /**
   * relative updateMany
   */
  export type relativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update relatives.
     */
    data: XOR<relativeUpdateManyMutationInput, relativeUncheckedUpdateManyInput>
    /**
     * Filter which relatives to update
     */
    where?: relativeWhereInput
    /**
     * Limit how many relatives to update.
     */
    limit?: number
  }

  /**
   * relative upsert
   */
  export type relativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * The filter to search for the relative to update in case it exists.
     */
    where: relativeWhereUniqueInput
    /**
     * In case the relative found by the `where` argument doesn't exist, create a new relative with this data.
     */
    create: XOR<relativeCreateInput, relativeUncheckedCreateInput>
    /**
     * In case the relative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<relativeUpdateInput, relativeUncheckedUpdateInput>
  }

  /**
   * relative delete
   */
  export type relativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    /**
     * Filter which relative to delete.
     */
    where: relativeWhereUniqueInput
  }

  /**
   * relative deleteMany
   */
  export type relativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which relatives to delete
     */
    where?: relativeWhereInput
    /**
     * Limit how many relatives to delete.
     */
    limit?: number
  }

  /**
   * relative without action
   */
  export type relativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
  }


  /**
   * Model room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    room_area: Decimal | null
  }

  export type RoomSumAggregateOutputType = {
    room_area: Decimal | null
  }

  export type RoomMinAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    room_status: $Enums.room_room_status | null
    room_area: Decimal | null
  }

  export type RoomMaxAggregateOutputType = {
    building_id: string | null
    room_id: string | null
    room_status: $Enums.room_room_status | null
    room_area: Decimal | null
  }

  export type RoomCountAggregateOutputType = {
    building_id: number
    room_id: number
    room_status: number
    room_area: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    room_area?: true
  }

  export type RoomSumAggregateInputType = {
    room_area?: true
  }

  export type RoomMinAggregateInputType = {
    building_id?: true
    room_id?: true
    room_status?: true
    room_area?: true
  }

  export type RoomMaxAggregateInputType = {
    building_id?: true
    room_id?: true
    room_status?: true
    room_area?: true
  }

  export type RoomCountAggregateInputType = {
    building_id?: true
    room_id?: true
    room_status?: true
    room_area?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room to aggregate.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roomWhereInput
    orderBy?: roomOrderByWithAggregationInput | roomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    building_id: string
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    building_id?: boolean
    room_id?: boolean
    room_status?: boolean
    room_area?: boolean
    health_room?: boolean | room$health_roomArgs<ExtArgs>
    management_room?: boolean | room$management_roomArgs<ExtArgs>
    other_room?: boolean | room$other_roomArgs<ExtArgs>
    building?: boolean | buildingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>



  export type roomSelectScalar = {
    building_id?: boolean
    room_id?: boolean
    room_status?: boolean
    room_area?: boolean
  }

  export type roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"building_id" | "room_id" | "room_status" | "room_area", ExtArgs["result"]["room"]>
  export type roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    health_room?: boolean | room$health_roomArgs<ExtArgs>
    management_room?: boolean | room$management_roomArgs<ExtArgs>
    other_room?: boolean | room$other_roomArgs<ExtArgs>
    building?: boolean | buildingDefaultArgs<ExtArgs>
  }

  export type $roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "room"
    objects: {
      health_room: Prisma.$health_roomPayload<ExtArgs> | null
      management_room: Prisma.$management_roomPayload<ExtArgs> | null
      other_room: Prisma.$other_roomPayload<ExtArgs> | null
      building: Prisma.$buildingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      building_id: string
      room_id: string
      room_status: $Enums.room_room_status
      room_area: Prisma.Decimal
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type roomGetPayload<S extends boolean | null | undefined | roomDefaultArgs> = $Result.GetResult<Prisma.$roomPayload, S>

  type roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['room'], meta: { name: 'room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {roomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roomFindUniqueArgs>(args: SelectSubset<T, roomFindUniqueArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roomFindUniqueOrThrowArgs>(args: SelectSubset<T, roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roomFindFirstArgs>(args?: SelectSubset<T, roomFindFirstArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roomFindFirstOrThrowArgs>(args?: SelectSubset<T, roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `building_id`
     * const roomWithBuilding_idOnly = await prisma.room.findMany({ select: { building_id: true } })
     * 
     */
    findMany<T extends roomFindManyArgs>(args?: SelectSubset<T, roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {roomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends roomCreateArgs>(args: SelectSubset<T, roomCreateArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {roomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roomCreateManyArgs>(args?: SelectSubset<T, roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {roomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends roomDeleteArgs>(args: SelectSubset<T, roomDeleteArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {roomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roomUpdateArgs>(args: SelectSubset<T, roomUpdateArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {roomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roomDeleteManyArgs>(args?: SelectSubset<T, roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roomUpdateManyArgs>(args: SelectSubset<T, roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {roomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends roomUpsertArgs>(args: SelectSubset<T, roomUpsertArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends roomCountArgs>(
      args?: Subset<T, roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roomGroupByArgs['orderBy'] }
        : { orderBy?: roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the room model
   */
  readonly fields: roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    health_room<T extends room$health_roomArgs<ExtArgs> = {}>(args?: Subset<T, room$health_roomArgs<ExtArgs>>): Prisma__health_roomClient<$Result.GetResult<Prisma.$health_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    management_room<T extends room$management_roomArgs<ExtArgs> = {}>(args?: Subset<T, room$management_roomArgs<ExtArgs>>): Prisma__management_roomClient<$Result.GetResult<Prisma.$management_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_room<T extends room$other_roomArgs<ExtArgs> = {}>(args?: Subset<T, room$other_roomArgs<ExtArgs>>): Prisma__other_roomClient<$Result.GetResult<Prisma.$other_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    building<T extends buildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, buildingDefaultArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the room model
   */
  interface roomFieldRefs {
    readonly building_id: FieldRef<"room", 'String'>
    readonly room_id: FieldRef<"room", 'String'>
    readonly room_status: FieldRef<"room", 'room_room_status'>
    readonly room_area: FieldRef<"room", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * room findUnique
   */
  export type roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room findUniqueOrThrow
   */
  export type roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room findFirst
   */
  export type roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rooms.
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * room findFirstOrThrow
   */
  export type roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rooms.
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * room findMany
   */
  export type roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which rooms to fetch.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rooms.
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * room create
   */
  export type roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * The data needed to create a room.
     */
    data: XOR<roomCreateInput, roomUncheckedCreateInput>
  }

  /**
   * room createMany
   */
  export type roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rooms.
     */
    data: roomCreateManyInput | roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * room update
   */
  export type roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * The data needed to update a room.
     */
    data: XOR<roomUpdateInput, roomUncheckedUpdateInput>
    /**
     * Choose, which room to update.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room updateMany
   */
  export type roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rooms.
     */
    data: XOR<roomUpdateManyMutationInput, roomUncheckedUpdateManyInput>
    /**
     * Filter which rooms to update
     */
    where?: roomWhereInput
    /**
     * Limit how many rooms to update.
     */
    limit?: number
  }

  /**
   * room upsert
   */
  export type roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * The filter to search for the room to update in case it exists.
     */
    where: roomWhereUniqueInput
    /**
     * In case the room found by the `where` argument doesn't exist, create a new room with this data.
     */
    create: XOR<roomCreateInput, roomUncheckedCreateInput>
    /**
     * In case the room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roomUpdateInput, roomUncheckedUpdateInput>
  }

  /**
   * room delete
   */
  export type roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter which room to delete.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room deleteMany
   */
  export type roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rooms to delete
     */
    where?: roomWhereInput
    /**
     * Limit how many rooms to delete.
     */
    limit?: number
  }

  /**
   * room.health_room
   */
  export type room$health_roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_room
     */
    select?: health_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_room
     */
    omit?: health_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_roomInclude<ExtArgs> | null
    where?: health_roomWhereInput
  }

  /**
   * room.management_room
   */
  export type room$management_roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the management_room
     */
    select?: management_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the management_room
     */
    omit?: management_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: management_roomInclude<ExtArgs> | null
    where?: management_roomWhereInput
  }

  /**
   * room.other_room
   */
  export type room$other_roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_room
     */
    select?: other_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_room
     */
    omit?: other_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: other_roomInclude<ExtArgs> | null
    where?: other_roomWhereInput
  }

  /**
   * room without action
   */
  export type roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
  }


  /**
   * Model student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    Sssn: string | null
    studentId: string | null
    hasHealthInsurance: boolean | null
    studyStatus: string | null
    className: string | null
    faculty: string | null
    building_id: string | null
    room_id: string | null
  }

  export type StudentMaxAggregateOutputType = {
    Sssn: string | null
    studentId: string | null
    hasHealthInsurance: boolean | null
    studyStatus: string | null
    className: string | null
    faculty: string | null
    building_id: string | null
    room_id: string | null
  }

  export type StudentCountAggregateOutputType = {
    Sssn: number
    studentId: number
    hasHealthInsurance: number
    studyStatus: number
    className: number
    faculty: number
    building_id: number
    room_id: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    Sssn?: true
    studentId?: true
    hasHealthInsurance?: true
    studyStatus?: true
    className?: true
    faculty?: true
    building_id?: true
    room_id?: true
  }

  export type StudentMaxAggregateInputType = {
    Sssn?: true
    studentId?: true
    hasHealthInsurance?: true
    studyStatus?: true
    className?: true
    faculty?: true
    building_id?: true
    room_id?: true
  }

  export type StudentCountAggregateInputType = {
    Sssn?: true
    studentId?: true
    hasHealthInsurance?: true
    studyStatus?: true
    className?: true
    faculty?: true
    building_id?: true
    room_id?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student to aggregate.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type studentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
    orderBy?: studentOrderByWithAggregationInput | studentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus: string | null
    className: string | null
    faculty: string | null
    building_id: string | null
    room_id: string | null
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends studentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type studentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Sssn?: boolean
    studentId?: boolean
    hasHealthInsurance?: boolean
    studyStatus?: boolean
    className?: boolean
    faculty?: boolean
    building_id?: boolean
    room_id?: boolean
    Dormitory_Card?: boolean | student$Dormitory_CardArgs<ExtArgs>
    relative?: boolean | student$relativeArgs<ExtArgs>
    People?: boolean | PeopleDefaultArgs<ExtArgs>
    living_room?: boolean | student$living_roomArgs<ExtArgs>
    studentDiscipline?: boolean | student$studentDisciplineArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type studentSelectScalar = {
    Sssn?: boolean
    studentId?: boolean
    hasHealthInsurance?: boolean
    studyStatus?: boolean
    className?: boolean
    faculty?: boolean
    building_id?: boolean
    room_id?: boolean
  }

  export type studentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Sssn" | "studentId" | "hasHealthInsurance" | "studyStatus" | "className" | "faculty" | "building_id" | "room_id", ExtArgs["result"]["student"]>
  export type studentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dormitory_Card?: boolean | student$Dormitory_CardArgs<ExtArgs>
    relative?: boolean | student$relativeArgs<ExtArgs>
    People?: boolean | PeopleDefaultArgs<ExtArgs>
    living_room?: boolean | student$living_roomArgs<ExtArgs>
    studentDiscipline?: boolean | student$studentDisciplineArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $studentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student"
    objects: {
      Dormitory_Card: Prisma.$Dormitory_CardPayload<ExtArgs>[]
      relative: Prisma.$relativePayload<ExtArgs>[]
      People: Prisma.$PeoplePayload<ExtArgs>
      living_room: Prisma.$living_roomPayload<ExtArgs> | null
      studentDiscipline: Prisma.$studentDisciplinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Sssn: string
      studentId: string
      hasHealthInsurance: boolean
      studyStatus: string | null
      className: string | null
      faculty: string | null
      building_id: string | null
      room_id: string | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type studentGetPayload<S extends boolean | null | undefined | studentDefaultArgs> = $Result.GetResult<Prisma.$studentPayload, S>

  type studentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface studentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student'], meta: { name: 'student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentFindUniqueArgs>(args: SelectSubset<T, studentFindUniqueArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentFindUniqueOrThrowArgs>(args: SelectSubset<T, studentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentFindFirstArgs>(args?: SelectSubset<T, studentFindFirstArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentFindFirstOrThrowArgs>(args?: SelectSubset<T, studentFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `Sssn`
     * const studentWithSssnOnly = await prisma.student.findMany({ select: { Sssn: true } })
     * 
     */
    findMany<T extends studentFindManyArgs>(args?: SelectSubset<T, studentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends studentCreateArgs>(args: SelectSubset<T, studentCreateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentCreateManyArgs>(args?: SelectSubset<T, studentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends studentDeleteArgs>(args: SelectSubset<T, studentDeleteArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentUpdateArgs>(args: SelectSubset<T, studentUpdateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentDeleteManyArgs>(args?: SelectSubset<T, studentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentUpdateManyArgs>(args: SelectSubset<T, studentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends studentUpsertArgs>(args: SelectSubset<T, studentUpsertArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentGroupByArgs['orderBy'] }
        : { orderBy?: studentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student model
   */
  readonly fields: studentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Dormitory_Card<T extends student$Dormitory_CardArgs<ExtArgs> = {}>(args?: Subset<T, student$Dormitory_CardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Dormitory_CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relative<T extends student$relativeArgs<ExtArgs> = {}>(args?: Subset<T, student$relativeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$relativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    People<T extends PeopleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeopleDefaultArgs<ExtArgs>>): Prisma__PeopleClient<$Result.GetResult<Prisma.$PeoplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    living_room<T extends student$living_roomArgs<ExtArgs> = {}>(args?: Subset<T, student$living_roomArgs<ExtArgs>>): Prisma__living_roomClient<$Result.GetResult<Prisma.$living_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentDiscipline<T extends student$studentDisciplineArgs<ExtArgs> = {}>(args?: Subset<T, student$studentDisciplineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student model
   */
  interface studentFieldRefs {
    readonly Sssn: FieldRef<"student", 'String'>
    readonly studentId: FieldRef<"student", 'String'>
    readonly hasHealthInsurance: FieldRef<"student", 'Boolean'>
    readonly studyStatus: FieldRef<"student", 'String'>
    readonly className: FieldRef<"student", 'String'>
    readonly faculty: FieldRef<"student", 'String'>
    readonly building_id: FieldRef<"student", 'String'>
    readonly room_id: FieldRef<"student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * student findUnique
   */
  export type studentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findUniqueOrThrow
   */
  export type studentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findFirst
   */
  export type studentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findFirstOrThrow
   */
  export type studentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findMany
   */
  export type studentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student create
   */
  export type studentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to create a student.
     */
    data: XOR<studentCreateInput, studentUncheckedCreateInput>
  }

  /**
   * student createMany
   */
  export type studentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student update
   */
  export type studentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to update a student.
     */
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student updateMany
   */
  export type studentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * student upsert
   */
  export type studentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The filter to search for the student to update in case it exists.
     */
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     */
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }

  /**
   * student delete
   */
  export type studentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter which student to delete.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * student.Dormitory_Card
   */
  export type student$Dormitory_CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dormitory_Card
     */
    select?: Dormitory_CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dormitory_Card
     */
    omit?: Dormitory_CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dormitory_CardInclude<ExtArgs> | null
    where?: Dormitory_CardWhereInput
    orderBy?: Dormitory_CardOrderByWithRelationInput | Dormitory_CardOrderByWithRelationInput[]
    cursor?: Dormitory_CardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Dormitory_CardScalarFieldEnum | Dormitory_CardScalarFieldEnum[]
  }

  /**
   * student.relative
   */
  export type student$relativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relative
     */
    select?: relativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the relative
     */
    omit?: relativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: relativeInclude<ExtArgs> | null
    where?: relativeWhereInput
    orderBy?: relativeOrderByWithRelationInput | relativeOrderByWithRelationInput[]
    cursor?: relativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelativeScalarFieldEnum | RelativeScalarFieldEnum[]
  }

  /**
   * student.living_room
   */
  export type student$living_roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the living_room
     */
    select?: living_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the living_room
     */
    omit?: living_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: living_roomInclude<ExtArgs> | null
    where?: living_roomWhereInput
  }

  /**
   * student.studentDiscipline
   */
  export type student$studentDisciplineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    where?: studentDisciplineWhereInput
    orderBy?: studentDisciplineOrderByWithRelationInput | studentDisciplineOrderByWithRelationInput[]
    cursor?: studentDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentDisciplineScalarFieldEnum | StudentDisciplineScalarFieldEnum[]
  }

  /**
   * student without action
   */
  export type studentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
  }


  /**
   * Model studentDiscipline
   */

  export type AggregateStudentDiscipline = {
    _count: StudentDisciplineCountAggregateOutputType | null
    _min: StudentDisciplineMinAggregateOutputType | null
    _max: StudentDisciplineMaxAggregateOutputType | null
  }

  export type StudentDisciplineMinAggregateOutputType = {
    actionId: string | null
    Sssn: string | null
  }

  export type StudentDisciplineMaxAggregateOutputType = {
    actionId: string | null
    Sssn: string | null
  }

  export type StudentDisciplineCountAggregateOutputType = {
    actionId: number
    Sssn: number
    _all: number
  }


  export type StudentDisciplineMinAggregateInputType = {
    actionId?: true
    Sssn?: true
  }

  export type StudentDisciplineMaxAggregateInputType = {
    actionId?: true
    Sssn?: true
  }

  export type StudentDisciplineCountAggregateInputType = {
    actionId?: true
    Sssn?: true
    _all?: true
  }

  export type StudentDisciplineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentDiscipline to aggregate.
     */
    where?: studentDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentDisciplines to fetch.
     */
    orderBy?: studentDisciplineOrderByWithRelationInput | studentDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned studentDisciplines
    **/
    _count?: true | StudentDisciplineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentDisciplineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentDisciplineMaxAggregateInputType
  }

  export type GetStudentDisciplineAggregateType<T extends StudentDisciplineAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentDiscipline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentDiscipline[P]>
      : GetScalarType<T[P], AggregateStudentDiscipline[P]>
  }




  export type studentDisciplineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentDisciplineWhereInput
    orderBy?: studentDisciplineOrderByWithAggregationInput | studentDisciplineOrderByWithAggregationInput[]
    by: StudentDisciplineScalarFieldEnum[] | StudentDisciplineScalarFieldEnum
    having?: studentDisciplineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentDisciplineCountAggregateInputType | true
    _min?: StudentDisciplineMinAggregateInputType
    _max?: StudentDisciplineMaxAggregateInputType
  }

  export type StudentDisciplineGroupByOutputType = {
    actionId: string
    Sssn: string
    _count: StudentDisciplineCountAggregateOutputType | null
    _min: StudentDisciplineMinAggregateOutputType | null
    _max: StudentDisciplineMaxAggregateOutputType | null
  }

  type GetStudentDisciplineGroupByPayload<T extends studentDisciplineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentDisciplineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentDisciplineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentDisciplineGroupByOutputType[P]>
            : GetScalarType<T[P], StudentDisciplineGroupByOutputType[P]>
        }
      >
    >


  export type studentDisciplineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    actionId?: boolean
    Sssn?: boolean
    disciplinaryAction?: boolean | disciplinaryActionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentDiscipline"]>



  export type studentDisciplineSelectScalar = {
    actionId?: boolean
    Sssn?: boolean
  }

  export type studentDisciplineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"actionId" | "Sssn", ExtArgs["result"]["studentDiscipline"]>
  export type studentDisciplineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplinaryAction?: boolean | disciplinaryActionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }

  export type $studentDisciplinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "studentDiscipline"
    objects: {
      disciplinaryAction: Prisma.$disciplinaryActionPayload<ExtArgs>
      student: Prisma.$studentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      actionId: string
      Sssn: string
    }, ExtArgs["result"]["studentDiscipline"]>
    composites: {}
  }

  type studentDisciplineGetPayload<S extends boolean | null | undefined | studentDisciplineDefaultArgs> = $Result.GetResult<Prisma.$studentDisciplinePayload, S>

  type studentDisciplineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentDisciplineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentDisciplineCountAggregateInputType | true
    }

  export interface studentDisciplineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['studentDiscipline'], meta: { name: 'studentDiscipline' } }
    /**
     * Find zero or one StudentDiscipline that matches the filter.
     * @param {studentDisciplineFindUniqueArgs} args - Arguments to find a StudentDiscipline
     * @example
     * // Get one StudentDiscipline
     * const studentDiscipline = await prisma.studentDiscipline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentDisciplineFindUniqueArgs>(args: SelectSubset<T, studentDisciplineFindUniqueArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentDiscipline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentDisciplineFindUniqueOrThrowArgs} args - Arguments to find a StudentDiscipline
     * @example
     * // Get one StudentDiscipline
     * const studentDiscipline = await prisma.studentDiscipline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentDisciplineFindUniqueOrThrowArgs>(args: SelectSubset<T, studentDisciplineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentDiscipline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentDisciplineFindFirstArgs} args - Arguments to find a StudentDiscipline
     * @example
     * // Get one StudentDiscipline
     * const studentDiscipline = await prisma.studentDiscipline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentDisciplineFindFirstArgs>(args?: SelectSubset<T, studentDisciplineFindFirstArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentDiscipline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentDisciplineFindFirstOrThrowArgs} args - Arguments to find a StudentDiscipline
     * @example
     * // Get one StudentDiscipline
     * const studentDiscipline = await prisma.studentDiscipline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentDisciplineFindFirstOrThrowArgs>(args?: SelectSubset<T, studentDisciplineFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentDisciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentDisciplineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentDisciplines
     * const studentDisciplines = await prisma.studentDiscipline.findMany()
     * 
     * // Get first 10 StudentDisciplines
     * const studentDisciplines = await prisma.studentDiscipline.findMany({ take: 10 })
     * 
     * // Only select the `actionId`
     * const studentDisciplineWithActionIdOnly = await prisma.studentDiscipline.findMany({ select: { actionId: true } })
     * 
     */
    findMany<T extends studentDisciplineFindManyArgs>(args?: SelectSubset<T, studentDisciplineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentDiscipline.
     * @param {studentDisciplineCreateArgs} args - Arguments to create a StudentDiscipline.
     * @example
     * // Create one StudentDiscipline
     * const StudentDiscipline = await prisma.studentDiscipline.create({
     *   data: {
     *     // ... data to create a StudentDiscipline
     *   }
     * })
     * 
     */
    create<T extends studentDisciplineCreateArgs>(args: SelectSubset<T, studentDisciplineCreateArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentDisciplines.
     * @param {studentDisciplineCreateManyArgs} args - Arguments to create many StudentDisciplines.
     * @example
     * // Create many StudentDisciplines
     * const studentDiscipline = await prisma.studentDiscipline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentDisciplineCreateManyArgs>(args?: SelectSubset<T, studentDisciplineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentDiscipline.
     * @param {studentDisciplineDeleteArgs} args - Arguments to delete one StudentDiscipline.
     * @example
     * // Delete one StudentDiscipline
     * const StudentDiscipline = await prisma.studentDiscipline.delete({
     *   where: {
     *     // ... filter to delete one StudentDiscipline
     *   }
     * })
     * 
     */
    delete<T extends studentDisciplineDeleteArgs>(args: SelectSubset<T, studentDisciplineDeleteArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentDiscipline.
     * @param {studentDisciplineUpdateArgs} args - Arguments to update one StudentDiscipline.
     * @example
     * // Update one StudentDiscipline
     * const studentDiscipline = await prisma.studentDiscipline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentDisciplineUpdateArgs>(args: SelectSubset<T, studentDisciplineUpdateArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentDisciplines.
     * @param {studentDisciplineDeleteManyArgs} args - Arguments to filter StudentDisciplines to delete.
     * @example
     * // Delete a few StudentDisciplines
     * const { count } = await prisma.studentDiscipline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentDisciplineDeleteManyArgs>(args?: SelectSubset<T, studentDisciplineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentDisciplineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentDisciplines
     * const studentDiscipline = await prisma.studentDiscipline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentDisciplineUpdateManyArgs>(args: SelectSubset<T, studentDisciplineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentDiscipline.
     * @param {studentDisciplineUpsertArgs} args - Arguments to update or create a StudentDiscipline.
     * @example
     * // Update or create a StudentDiscipline
     * const studentDiscipline = await prisma.studentDiscipline.upsert({
     *   create: {
     *     // ... data to create a StudentDiscipline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentDiscipline we want to update
     *   }
     * })
     */
    upsert<T extends studentDisciplineUpsertArgs>(args: SelectSubset<T, studentDisciplineUpsertArgs<ExtArgs>>): Prisma__studentDisciplineClient<$Result.GetResult<Prisma.$studentDisciplinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentDisciplineCountArgs} args - Arguments to filter StudentDisciplines to count.
     * @example
     * // Count the number of StudentDisciplines
     * const count = await prisma.studentDiscipline.count({
     *   where: {
     *     // ... the filter for the StudentDisciplines we want to count
     *   }
     * })
    **/
    count<T extends studentDisciplineCountArgs>(
      args?: Subset<T, studentDisciplineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentDisciplineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDisciplineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentDisciplineAggregateArgs>(args: Subset<T, StudentDisciplineAggregateArgs>): Prisma.PrismaPromise<GetStudentDisciplineAggregateType<T>>

    /**
     * Group by StudentDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentDisciplineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentDisciplineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentDisciplineGroupByArgs['orderBy'] }
        : { orderBy?: studentDisciplineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentDisciplineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentDisciplineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the studentDiscipline model
   */
  readonly fields: studentDisciplineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for studentDiscipline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentDisciplineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    disciplinaryAction<T extends disciplinaryActionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, disciplinaryActionDefaultArgs<ExtArgs>>): Prisma__disciplinaryActionClient<$Result.GetResult<Prisma.$disciplinaryActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the studentDiscipline model
   */
  interface studentDisciplineFieldRefs {
    readonly actionId: FieldRef<"studentDiscipline", 'String'>
    readonly Sssn: FieldRef<"studentDiscipline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * studentDiscipline findUnique
   */
  export type studentDisciplineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which studentDiscipline to fetch.
     */
    where: studentDisciplineWhereUniqueInput
  }

  /**
   * studentDiscipline findUniqueOrThrow
   */
  export type studentDisciplineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which studentDiscipline to fetch.
     */
    where: studentDisciplineWhereUniqueInput
  }

  /**
   * studentDiscipline findFirst
   */
  export type studentDisciplineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which studentDiscipline to fetch.
     */
    where?: studentDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentDisciplines to fetch.
     */
    orderBy?: studentDisciplineOrderByWithRelationInput | studentDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentDisciplines.
     */
    cursor?: studentDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentDisciplines.
     */
    distinct?: StudentDisciplineScalarFieldEnum | StudentDisciplineScalarFieldEnum[]
  }

  /**
   * studentDiscipline findFirstOrThrow
   */
  export type studentDisciplineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which studentDiscipline to fetch.
     */
    where?: studentDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentDisciplines to fetch.
     */
    orderBy?: studentDisciplineOrderByWithRelationInput | studentDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentDisciplines.
     */
    cursor?: studentDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentDisciplines.
     */
    distinct?: StudentDisciplineScalarFieldEnum | StudentDisciplineScalarFieldEnum[]
  }

  /**
   * studentDiscipline findMany
   */
  export type studentDisciplineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which studentDisciplines to fetch.
     */
    where?: studentDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentDisciplines to fetch.
     */
    orderBy?: studentDisciplineOrderByWithRelationInput | studentDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing studentDisciplines.
     */
    cursor?: studentDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentDisciplines.
     */
    skip?: number
    distinct?: StudentDisciplineScalarFieldEnum | StudentDisciplineScalarFieldEnum[]
  }

  /**
   * studentDiscipline create
   */
  export type studentDisciplineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to create a studentDiscipline.
     */
    data: XOR<studentDisciplineCreateInput, studentDisciplineUncheckedCreateInput>
  }

  /**
   * studentDiscipline createMany
   */
  export type studentDisciplineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many studentDisciplines.
     */
    data: studentDisciplineCreateManyInput | studentDisciplineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * studentDiscipline update
   */
  export type studentDisciplineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to update a studentDiscipline.
     */
    data: XOR<studentDisciplineUpdateInput, studentDisciplineUncheckedUpdateInput>
    /**
     * Choose, which studentDiscipline to update.
     */
    where: studentDisciplineWhereUniqueInput
  }

  /**
   * studentDiscipline updateMany
   */
  export type studentDisciplineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update studentDisciplines.
     */
    data: XOR<studentDisciplineUpdateManyMutationInput, studentDisciplineUncheckedUpdateManyInput>
    /**
     * Filter which studentDisciplines to update
     */
    where?: studentDisciplineWhereInput
    /**
     * Limit how many studentDisciplines to update.
     */
    limit?: number
  }

  /**
   * studentDiscipline upsert
   */
  export type studentDisciplineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * The filter to search for the studentDiscipline to update in case it exists.
     */
    where: studentDisciplineWhereUniqueInput
    /**
     * In case the studentDiscipline found by the `where` argument doesn't exist, create a new studentDiscipline with this data.
     */
    create: XOR<studentDisciplineCreateInput, studentDisciplineUncheckedCreateInput>
    /**
     * In case the studentDiscipline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentDisciplineUpdateInput, studentDisciplineUncheckedUpdateInput>
  }

  /**
   * studentDiscipline delete
   */
  export type studentDisciplineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
    /**
     * Filter which studentDiscipline to delete.
     */
    where: studentDisciplineWhereUniqueInput
  }

  /**
   * studentDiscipline deleteMany
   */
  export type studentDisciplineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentDisciplines to delete
     */
    where?: studentDisciplineWhereInput
    /**
     * Limit how many studentDisciplines to delete.
     */
    limit?: number
  }

  /**
   * studentDiscipline without action
   */
  export type studentDisciplineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentDiscipline
     */
    select?: studentDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentDiscipline
     */
    omit?: studentDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentDisciplineInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AddressScalarFieldEnum: {
    ssn: 'ssn',
    commune: 'commune',
    district: 'district',
    province: 'province'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const Dormitory_CardScalarFieldEnum: {
    Number: 'Number',
    Start_Date: 'Start_Date',
    End_Date: 'End_Date',
    ID_Card: 'ID_Card',
    Validity: 'Validity'
  };

  export type Dormitory_CardScalarFieldEnum = (typeof Dormitory_CardScalarFieldEnum)[keyof typeof Dormitory_CardScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    ssn: 'ssn',
    email: 'email'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const Employee_CardScalarFieldEnum: {
    Number: 'Number',
    Start_Date: 'Start_Date',
    End_Date: 'End_Date',
    ID_Card: 'ID_Card',
    Employee_Type: 'Employee_Type'
  };

  export type Employee_CardScalarFieldEnum = (typeof Employee_CardScalarFieldEnum)[keyof typeof Employee_CardScalarFieldEnum]


  export const Identity_CardScalarFieldEnum: {
    ID: 'ID',
    Issued_Date: 'Issued_Date'
  };

  export type Identity_CardScalarFieldEnum = (typeof Identity_CardScalarFieldEnum)[keyof typeof Identity_CardScalarFieldEnum]


  export const PeopleScalarFieldEnum: {
    SSN: 'SSN',
    Full_Name: 'Full_Name',
    Last_Name: 'Last_Name',
    Birthday: 'Birthday',
    Sex: 'Sex',
    Health_State: 'Health_State',
    Ethnic_Group: 'Ethnic_Group'
  };

  export type PeopleScalarFieldEnum = (typeof PeopleScalarFieldEnum)[keyof typeof PeopleScalarFieldEnum]


  export const PhoneNumberScalarFieldEnum: {
    ssn: 'ssn',
    phoneNumber: 'phoneNumber'
  };

  export type PhoneNumberScalarFieldEnum = (typeof PhoneNumberScalarFieldEnum)[keyof typeof PhoneNumberScalarFieldEnum]


  export const BuildingScalarFieldEnum: {
    building_id: 'building_id',
    building_name: 'building_name',
    floors: 'floors',
    rooms: 'rooms',
    has_air_conditioner: 'has_air_conditioner',
    sponsor: 'sponsor',
    construction_date: 'construction_date',
    last_renovation: 'last_renovation'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const Building_equipmentScalarFieldEnum: {
    building_id: 'building_id',
    equipment_id: 'equipment_id',
    quantity: 'quantity'
  };

  export type Building_equipmentScalarFieldEnum = (typeof Building_equipmentScalarFieldEnum)[keyof typeof Building_equipmentScalarFieldEnum]


  export const DisciplinaryActionScalarFieldEnum: {
    actionId: 'actionId',
    actionType: 'actionType',
    reason: 'reason',
    decisionDate: 'decisionDate',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    severityLevel: 'severityLevel',
    status: 'status'
  };

  export type DisciplinaryActionScalarFieldEnum = (typeof DisciplinaryActionScalarFieldEnum)[keyof typeof DisciplinaryActionScalarFieldEnum]


  export const DisciplineStaffScalarFieldEnum: {
    actionId: 'actionId',
    essn: 'essn'
  };

  export type DisciplineStaffScalarFieldEnum = (typeof DisciplineStaffScalarFieldEnum)[keyof typeof DisciplineStaffScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    essn: 'essn',
    salary: 'salary',
    empId: 'empId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const Health_roomScalarFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id',
    num_of_staff: 'num_of_staff',
    start_time: 'start_time',
    end_time: 'end_time',
    equipment_status: 'equipment_status'
  };

  export type Health_roomScalarFieldEnum = (typeof Health_roomScalarFieldEnum)[keyof typeof Health_roomScalarFieldEnum]


  export const Large_equipmentScalarFieldEnum: {
    equipment_id: 'equipment_id',
    equipment_name: 'equipment_name',
    equipment_type: 'equipment_type',
    equipment_status: 'equipment_status',
    purchase_date: 'purchase_date',
    purchase_location: 'purchase_location'
  };

  export type Large_equipmentScalarFieldEnum = (typeof Large_equipmentScalarFieldEnum)[keyof typeof Large_equipmentScalarFieldEnum]


  export const Living_roomScalarFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id',
    max_num_of_students: 'max_num_of_students',
    current_num_of_students: 'current_num_of_students',
    rental_price: 'rental_price',
    occupancy_rate: 'occupancy_rate'
  };

  export type Living_roomScalarFieldEnum = (typeof Living_roomScalarFieldEnum)[keyof typeof Living_roomScalarFieldEnum]


  export const Management_roomScalarFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id',
    num_of_staff: 'num_of_staff',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type Management_roomScalarFieldEnum = (typeof Management_roomScalarFieldEnum)[keyof typeof Management_roomScalarFieldEnum]


  export const ManagerDormScalarFieldEnum: {
    user_name: 'user_name',
    password: 'password'
  };

  export type ManagerDormScalarFieldEnum = (typeof ManagerDormScalarFieldEnum)[keyof typeof ManagerDormScalarFieldEnum]


  export const Manager_degreeScalarFieldEnum: {
    essn: 'essn',
    degree: 'degree'
  };

  export type Manager_degreeScalarFieldEnum = (typeof Manager_degreeScalarFieldEnum)[keyof typeof Manager_degreeScalarFieldEnum]


  export const Manager_employeeScalarFieldEnum: {
    essn: 'essn',
    room_id: 'room_id',
    building_id: 'building_id',
    experience: 'experience'
  };

  export type Manager_employeeScalarFieldEnum = (typeof Manager_employeeScalarFieldEnum)[keyof typeof Manager_employeeScalarFieldEnum]


  export const Medical_degreeScalarFieldEnum: {
    essn: 'essn',
    degree: 'degree'
  };

  export type Medical_degreeScalarFieldEnum = (typeof Medical_degreeScalarFieldEnum)[keyof typeof Medical_degreeScalarFieldEnum]


  export const Medical_employeeScalarFieldEnum: {
    essn: 'essn',
    room_id: 'room_id',
    building_id: 'building_id',
    experience: 'experience'
  };

  export type Medical_employeeScalarFieldEnum = (typeof Medical_employeeScalarFieldEnum)[keyof typeof Medical_employeeScalarFieldEnum]


  export const Other_employeeScalarFieldEnum: {
    essn: 'essn',
    room_id: 'room_id',
    building_id: 'building_id',
    typeWork: 'typeWork'
  };

  export type Other_employeeScalarFieldEnum = (typeof Other_employeeScalarFieldEnum)[keyof typeof Other_employeeScalarFieldEnum]


  export const Other_employee_time_workScalarFieldEnum: {
    essn: 'essn',
    date_work: 'date_work',
    time_start: 'time_start',
    time_end: 'time_end'
  };

  export type Other_employee_time_workScalarFieldEnum = (typeof Other_employee_time_workScalarFieldEnum)[keyof typeof Other_employee_time_workScalarFieldEnum]


  export const Other_roomScalarFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id',
    room_type: 'room_type',
    num_of_staff: 'num_of_staff',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type Other_roomScalarFieldEnum = (typeof Other_roomScalarFieldEnum)[keyof typeof Other_roomScalarFieldEnum]


  export const RelativeScalarFieldEnum: {
    Sssn: 'Sssn',
    fname: 'fname',
    lname: 'lname',
    birthday: 'birthday',
    relationship: 'relationship',
    address: 'address',
    phoneNumber: 'phoneNumber',
    job: 'job'
  };

  export type RelativeScalarFieldEnum = (typeof RelativeScalarFieldEnum)[keyof typeof RelativeScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id',
    room_status: 'room_status',
    room_area: 'room_area'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    Sssn: 'Sssn',
    studentId: 'studentId',
    hasHealthInsurance: 'hasHealthInsurance',
    studyStatus: 'studyStatus',
    className: 'className',
    faculty: 'faculty',
    building_id: 'building_id',
    room_id: 'room_id'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const StudentDisciplineScalarFieldEnum: {
    actionId: 'actionId',
    Sssn: 'Sssn'
  };

  export type StudentDisciplineScalarFieldEnum = (typeof StudentDisciplineScalarFieldEnum)[keyof typeof StudentDisciplineScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const AddressOrderByRelevanceFieldEnum: {
    ssn: 'ssn',
    commune: 'commune',
    district: 'district',
    province: 'province'
  };

  export type AddressOrderByRelevanceFieldEnum = (typeof AddressOrderByRelevanceFieldEnum)[keyof typeof AddressOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const Dormitory_CardOrderByRelevanceFieldEnum: {
    Number: 'Number',
    ID_Card: 'ID_Card'
  };

  export type Dormitory_CardOrderByRelevanceFieldEnum = (typeof Dormitory_CardOrderByRelevanceFieldEnum)[keyof typeof Dormitory_CardOrderByRelevanceFieldEnum]


  export const EmailOrderByRelevanceFieldEnum: {
    ssn: 'ssn',
    email: 'email'
  };

  export type EmailOrderByRelevanceFieldEnum = (typeof EmailOrderByRelevanceFieldEnum)[keyof typeof EmailOrderByRelevanceFieldEnum]


  export const Employee_CardOrderByRelevanceFieldEnum: {
    Number: 'Number',
    ID_Card: 'ID_Card',
    Employee_Type: 'Employee_Type'
  };

  export type Employee_CardOrderByRelevanceFieldEnum = (typeof Employee_CardOrderByRelevanceFieldEnum)[keyof typeof Employee_CardOrderByRelevanceFieldEnum]


  export const Identity_CardOrderByRelevanceFieldEnum: {
    ID: 'ID'
  };

  export type Identity_CardOrderByRelevanceFieldEnum = (typeof Identity_CardOrderByRelevanceFieldEnum)[keyof typeof Identity_CardOrderByRelevanceFieldEnum]


  export const PeopleOrderByRelevanceFieldEnum: {
    SSN: 'SSN',
    Full_Name: 'Full_Name',
    Last_Name: 'Last_Name',
    Sex: 'Sex',
    Health_State: 'Health_State',
    Ethnic_Group: 'Ethnic_Group'
  };

  export type PeopleOrderByRelevanceFieldEnum = (typeof PeopleOrderByRelevanceFieldEnum)[keyof typeof PeopleOrderByRelevanceFieldEnum]


  export const PhoneNumberOrderByRelevanceFieldEnum: {
    ssn: 'ssn',
    phoneNumber: 'phoneNumber'
  };

  export type PhoneNumberOrderByRelevanceFieldEnum = (typeof PhoneNumberOrderByRelevanceFieldEnum)[keyof typeof PhoneNumberOrderByRelevanceFieldEnum]


  export const buildingOrderByRelevanceFieldEnum: {
    building_id: 'building_id',
    building_name: 'building_name',
    sponsor: 'sponsor'
  };

  export type buildingOrderByRelevanceFieldEnum = (typeof buildingOrderByRelevanceFieldEnum)[keyof typeof buildingOrderByRelevanceFieldEnum]


  export const building_equipmentOrderByRelevanceFieldEnum: {
    building_id: 'building_id',
    equipment_id: 'equipment_id'
  };

  export type building_equipmentOrderByRelevanceFieldEnum = (typeof building_equipmentOrderByRelevanceFieldEnum)[keyof typeof building_equipmentOrderByRelevanceFieldEnum]


  export const disciplinaryActionOrderByRelevanceFieldEnum: {
    actionId: 'actionId',
    actionType: 'actionType',
    reason: 'reason',
    severityLevel: 'severityLevel',
    status: 'status'
  };

  export type disciplinaryActionOrderByRelevanceFieldEnum = (typeof disciplinaryActionOrderByRelevanceFieldEnum)[keyof typeof disciplinaryActionOrderByRelevanceFieldEnum]


  export const disciplineStaffOrderByRelevanceFieldEnum: {
    actionId: 'actionId',
    essn: 'essn'
  };

  export type disciplineStaffOrderByRelevanceFieldEnum = (typeof disciplineStaffOrderByRelevanceFieldEnum)[keyof typeof disciplineStaffOrderByRelevanceFieldEnum]


  export const employeeOrderByRelevanceFieldEnum: {
    essn: 'essn',
    empId: 'empId'
  };

  export type employeeOrderByRelevanceFieldEnum = (typeof employeeOrderByRelevanceFieldEnum)[keyof typeof employeeOrderByRelevanceFieldEnum]


  export const health_roomOrderByRelevanceFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id'
  };

  export type health_roomOrderByRelevanceFieldEnum = (typeof health_roomOrderByRelevanceFieldEnum)[keyof typeof health_roomOrderByRelevanceFieldEnum]


  export const large_equipmentOrderByRelevanceFieldEnum: {
    equipment_id: 'equipment_id',
    equipment_name: 'equipment_name',
    equipment_type: 'equipment_type',
    purchase_location: 'purchase_location'
  };

  export type large_equipmentOrderByRelevanceFieldEnum = (typeof large_equipmentOrderByRelevanceFieldEnum)[keyof typeof large_equipmentOrderByRelevanceFieldEnum]


  export const living_roomOrderByRelevanceFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id'
  };

  export type living_roomOrderByRelevanceFieldEnum = (typeof living_roomOrderByRelevanceFieldEnum)[keyof typeof living_roomOrderByRelevanceFieldEnum]


  export const management_roomOrderByRelevanceFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id'
  };

  export type management_roomOrderByRelevanceFieldEnum = (typeof management_roomOrderByRelevanceFieldEnum)[keyof typeof management_roomOrderByRelevanceFieldEnum]


  export const managerDormOrderByRelevanceFieldEnum: {
    user_name: 'user_name',
    password: 'password'
  };

  export type managerDormOrderByRelevanceFieldEnum = (typeof managerDormOrderByRelevanceFieldEnum)[keyof typeof managerDormOrderByRelevanceFieldEnum]


  export const manager_degreeOrderByRelevanceFieldEnum: {
    essn: 'essn',
    degree: 'degree'
  };

  export type manager_degreeOrderByRelevanceFieldEnum = (typeof manager_degreeOrderByRelevanceFieldEnum)[keyof typeof manager_degreeOrderByRelevanceFieldEnum]


  export const manager_employeeOrderByRelevanceFieldEnum: {
    essn: 'essn',
    room_id: 'room_id',
    building_id: 'building_id'
  };

  export type manager_employeeOrderByRelevanceFieldEnum = (typeof manager_employeeOrderByRelevanceFieldEnum)[keyof typeof manager_employeeOrderByRelevanceFieldEnum]


  export const medical_degreeOrderByRelevanceFieldEnum: {
    essn: 'essn',
    degree: 'degree'
  };

  export type medical_degreeOrderByRelevanceFieldEnum = (typeof medical_degreeOrderByRelevanceFieldEnum)[keyof typeof medical_degreeOrderByRelevanceFieldEnum]


  export const medical_employeeOrderByRelevanceFieldEnum: {
    essn: 'essn',
    room_id: 'room_id',
    building_id: 'building_id'
  };

  export type medical_employeeOrderByRelevanceFieldEnum = (typeof medical_employeeOrderByRelevanceFieldEnum)[keyof typeof medical_employeeOrderByRelevanceFieldEnum]


  export const other_employeeOrderByRelevanceFieldEnum: {
    essn: 'essn',
    room_id: 'room_id',
    building_id: 'building_id',
    typeWork: 'typeWork'
  };

  export type other_employeeOrderByRelevanceFieldEnum = (typeof other_employeeOrderByRelevanceFieldEnum)[keyof typeof other_employeeOrderByRelevanceFieldEnum]


  export const other_employee_time_workOrderByRelevanceFieldEnum: {
    essn: 'essn'
  };

  export type other_employee_time_workOrderByRelevanceFieldEnum = (typeof other_employee_time_workOrderByRelevanceFieldEnum)[keyof typeof other_employee_time_workOrderByRelevanceFieldEnum]


  export const other_roomOrderByRelevanceFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id',
    room_type: 'room_type'
  };

  export type other_roomOrderByRelevanceFieldEnum = (typeof other_roomOrderByRelevanceFieldEnum)[keyof typeof other_roomOrderByRelevanceFieldEnum]


  export const relativeOrderByRelevanceFieldEnum: {
    Sssn: 'Sssn',
    fname: 'fname',
    lname: 'lname',
    relationship: 'relationship',
    address: 'address',
    phoneNumber: 'phoneNumber',
    job: 'job'
  };

  export type relativeOrderByRelevanceFieldEnum = (typeof relativeOrderByRelevanceFieldEnum)[keyof typeof relativeOrderByRelevanceFieldEnum]


  export const roomOrderByRelevanceFieldEnum: {
    building_id: 'building_id',
    room_id: 'room_id'
  };

  export type roomOrderByRelevanceFieldEnum = (typeof roomOrderByRelevanceFieldEnum)[keyof typeof roomOrderByRelevanceFieldEnum]


  export const studentOrderByRelevanceFieldEnum: {
    Sssn: 'Sssn',
    studentId: 'studentId',
    studyStatus: 'studyStatus',
    className: 'className',
    faculty: 'faculty',
    building_id: 'building_id',
    room_id: 'room_id'
  };

  export type studentOrderByRelevanceFieldEnum = (typeof studentOrderByRelevanceFieldEnum)[keyof typeof studentOrderByRelevanceFieldEnum]


  export const studentDisciplineOrderByRelevanceFieldEnum: {
    actionId: 'actionId',
    Sssn: 'Sssn'
  };

  export type studentDisciplineOrderByRelevanceFieldEnum = (typeof studentDisciplineOrderByRelevanceFieldEnum)[keyof typeof studentDisciplineOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'health_room_equipment_status'
   */
  export type Enumhealth_room_equipment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'health_room_equipment_status'>
    


  /**
   * Reference to a field of type 'large_equipment_equipment_status'
   */
  export type Enumlarge_equipment_equipment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'large_equipment_equipment_status'>
    


  /**
   * Reference to a field of type 'other_employee_time_work_date_work'
   */
  export type Enumother_employee_time_work_date_workFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'other_employee_time_work_date_work'>
    


  /**
   * Reference to a field of type 'room_room_status'
   */
  export type Enumroom_room_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'room_room_status'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    ssn?: StringFilter<"Address"> | string
    commune?: StringFilter<"Address"> | string
    district?: StringFilter<"Address"> | string
    province?: StringFilter<"Address"> | string
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    ssn?: SortOrder
    commune?: SortOrder
    district?: SortOrder
    province?: SortOrder
    People?: PeopleOrderByWithRelationInput
    _relevance?: AddressOrderByRelevanceInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    ssn_commune_district_province?: AddressSsnCommuneDistrictProvinceCompoundUniqueInput
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    ssn?: StringFilter<"Address"> | string
    commune?: StringFilter<"Address"> | string
    district?: StringFilter<"Address"> | string
    province?: StringFilter<"Address"> | string
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
  }, "ssn_commune_district_province">

  export type AddressOrderByWithAggregationInput = {
    ssn?: SortOrder
    commune?: SortOrder
    district?: SortOrder
    province?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    ssn?: StringWithAggregatesFilter<"Address"> | string
    commune?: StringWithAggregatesFilter<"Address"> | string
    district?: StringWithAggregatesFilter<"Address"> | string
    province?: StringWithAggregatesFilter<"Address"> | string
  }

  export type Dormitory_CardWhereInput = {
    AND?: Dormitory_CardWhereInput | Dormitory_CardWhereInput[]
    OR?: Dormitory_CardWhereInput[]
    NOT?: Dormitory_CardWhereInput | Dormitory_CardWhereInput[]
    Number?: StringFilter<"Dormitory_Card"> | string
    Start_Date?: DateTimeNullableFilter<"Dormitory_Card"> | Date | string | null
    End_Date?: DateTimeNullableFilter<"Dormitory_Card"> | Date | string | null
    ID_Card?: StringFilter<"Dormitory_Card"> | string
    Validity?: BoolNullableFilter<"Dormitory_Card"> | boolean | null
    Identity_Card?: XOR<Identity_CardScalarRelationFilter, Identity_CardWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }

  export type Dormitory_CardOrderByWithRelationInput = {
    Number?: SortOrder
    Start_Date?: SortOrderInput | SortOrder
    End_Date?: SortOrderInput | SortOrder
    ID_Card?: SortOrder
    Validity?: SortOrderInput | SortOrder
    Identity_Card?: Identity_CardOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
    _relevance?: Dormitory_CardOrderByRelevanceInput
  }

  export type Dormitory_CardWhereUniqueInput = Prisma.AtLeast<{
    Number?: string
    AND?: Dormitory_CardWhereInput | Dormitory_CardWhereInput[]
    OR?: Dormitory_CardWhereInput[]
    NOT?: Dormitory_CardWhereInput | Dormitory_CardWhereInput[]
    Start_Date?: DateTimeNullableFilter<"Dormitory_Card"> | Date | string | null
    End_Date?: DateTimeNullableFilter<"Dormitory_Card"> | Date | string | null
    ID_Card?: StringFilter<"Dormitory_Card"> | string
    Validity?: BoolNullableFilter<"Dormitory_Card"> | boolean | null
    Identity_Card?: XOR<Identity_CardScalarRelationFilter, Identity_CardWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }, "Number">

  export type Dormitory_CardOrderByWithAggregationInput = {
    Number?: SortOrder
    Start_Date?: SortOrderInput | SortOrder
    End_Date?: SortOrderInput | SortOrder
    ID_Card?: SortOrder
    Validity?: SortOrderInput | SortOrder
    _count?: Dormitory_CardCountOrderByAggregateInput
    _max?: Dormitory_CardMaxOrderByAggregateInput
    _min?: Dormitory_CardMinOrderByAggregateInput
  }

  export type Dormitory_CardScalarWhereWithAggregatesInput = {
    AND?: Dormitory_CardScalarWhereWithAggregatesInput | Dormitory_CardScalarWhereWithAggregatesInput[]
    OR?: Dormitory_CardScalarWhereWithAggregatesInput[]
    NOT?: Dormitory_CardScalarWhereWithAggregatesInput | Dormitory_CardScalarWhereWithAggregatesInput[]
    Number?: StringWithAggregatesFilter<"Dormitory_Card"> | string
    Start_Date?: DateTimeNullableWithAggregatesFilter<"Dormitory_Card"> | Date | string | null
    End_Date?: DateTimeNullableWithAggregatesFilter<"Dormitory_Card"> | Date | string | null
    ID_Card?: StringWithAggregatesFilter<"Dormitory_Card"> | string
    Validity?: BoolNullableWithAggregatesFilter<"Dormitory_Card"> | boolean | null
  }

  export type EmailWhereInput = {
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    ssn?: StringFilter<"Email"> | string
    email?: StringFilter<"Email"> | string
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
  }

  export type EmailOrderByWithRelationInput = {
    ssn?: SortOrder
    email?: SortOrder
    People?: PeopleOrderByWithRelationInput
    _relevance?: EmailOrderByRelevanceInput
  }

  export type EmailWhereUniqueInput = Prisma.AtLeast<{
    ssn_email?: EmailSsnEmailCompoundUniqueInput
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    ssn?: StringFilter<"Email"> | string
    email?: StringFilter<"Email"> | string
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
  }, "ssn_email">

  export type EmailOrderByWithAggregationInput = {
    ssn?: SortOrder
    email?: SortOrder
    _count?: EmailCountOrderByAggregateInput
    _max?: EmailMaxOrderByAggregateInput
    _min?: EmailMinOrderByAggregateInput
  }

  export type EmailScalarWhereWithAggregatesInput = {
    AND?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    OR?: EmailScalarWhereWithAggregatesInput[]
    NOT?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    ssn?: StringWithAggregatesFilter<"Email"> | string
    email?: StringWithAggregatesFilter<"Email"> | string
  }

  export type Employee_CardWhereInput = {
    AND?: Employee_CardWhereInput | Employee_CardWhereInput[]
    OR?: Employee_CardWhereInput[]
    NOT?: Employee_CardWhereInput | Employee_CardWhereInput[]
    Number?: StringFilter<"Employee_Card"> | string
    Start_Date?: DateTimeNullableFilter<"Employee_Card"> | Date | string | null
    End_Date?: DateTimeNullableFilter<"Employee_Card"> | Date | string | null
    ID_Card?: StringFilter<"Employee_Card"> | string
    Employee_Type?: StringNullableFilter<"Employee_Card"> | string | null
    Identity_Card?: XOR<Identity_CardScalarRelationFilter, Identity_CardWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type Employee_CardOrderByWithRelationInput = {
    Number?: SortOrder
    Start_Date?: SortOrderInput | SortOrder
    End_Date?: SortOrderInput | SortOrder
    ID_Card?: SortOrder
    Employee_Type?: SortOrderInput | SortOrder
    Identity_Card?: Identity_CardOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    _relevance?: Employee_CardOrderByRelevanceInput
  }

  export type Employee_CardWhereUniqueInput = Prisma.AtLeast<{
    Number?: string
    AND?: Employee_CardWhereInput | Employee_CardWhereInput[]
    OR?: Employee_CardWhereInput[]
    NOT?: Employee_CardWhereInput | Employee_CardWhereInput[]
    Start_Date?: DateTimeNullableFilter<"Employee_Card"> | Date | string | null
    End_Date?: DateTimeNullableFilter<"Employee_Card"> | Date | string | null
    ID_Card?: StringFilter<"Employee_Card"> | string
    Employee_Type?: StringNullableFilter<"Employee_Card"> | string | null
    Identity_Card?: XOR<Identity_CardScalarRelationFilter, Identity_CardWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "Number">

  export type Employee_CardOrderByWithAggregationInput = {
    Number?: SortOrder
    Start_Date?: SortOrderInput | SortOrder
    End_Date?: SortOrderInput | SortOrder
    ID_Card?: SortOrder
    Employee_Type?: SortOrderInput | SortOrder
    _count?: Employee_CardCountOrderByAggregateInput
    _max?: Employee_CardMaxOrderByAggregateInput
    _min?: Employee_CardMinOrderByAggregateInput
  }

  export type Employee_CardScalarWhereWithAggregatesInput = {
    AND?: Employee_CardScalarWhereWithAggregatesInput | Employee_CardScalarWhereWithAggregatesInput[]
    OR?: Employee_CardScalarWhereWithAggregatesInput[]
    NOT?: Employee_CardScalarWhereWithAggregatesInput | Employee_CardScalarWhereWithAggregatesInput[]
    Number?: StringWithAggregatesFilter<"Employee_Card"> | string
    Start_Date?: DateTimeNullableWithAggregatesFilter<"Employee_Card"> | Date | string | null
    End_Date?: DateTimeNullableWithAggregatesFilter<"Employee_Card"> | Date | string | null
    ID_Card?: StringWithAggregatesFilter<"Employee_Card"> | string
    Employee_Type?: StringNullableWithAggregatesFilter<"Employee_Card"> | string | null
  }

  export type Identity_CardWhereInput = {
    AND?: Identity_CardWhereInput | Identity_CardWhereInput[]
    OR?: Identity_CardWhereInput[]
    NOT?: Identity_CardWhereInput | Identity_CardWhereInput[]
    ID?: StringFilter<"Identity_Card"> | string
    Issued_Date?: DateTimeFilter<"Identity_Card"> | Date | string
    Dormitory_Card?: XOR<Dormitory_CardNullableScalarRelationFilter, Dormitory_CardWhereInput> | null
    Employee_Card?: XOR<Employee_CardNullableScalarRelationFilter, Employee_CardWhereInput> | null
  }

  export type Identity_CardOrderByWithRelationInput = {
    ID?: SortOrder
    Issued_Date?: SortOrder
    Dormitory_Card?: Dormitory_CardOrderByWithRelationInput
    Employee_Card?: Employee_CardOrderByWithRelationInput
    _relevance?: Identity_CardOrderByRelevanceInput
  }

  export type Identity_CardWhereUniqueInput = Prisma.AtLeast<{
    ID?: string
    AND?: Identity_CardWhereInput | Identity_CardWhereInput[]
    OR?: Identity_CardWhereInput[]
    NOT?: Identity_CardWhereInput | Identity_CardWhereInput[]
    Issued_Date?: DateTimeFilter<"Identity_Card"> | Date | string
    Dormitory_Card?: XOR<Dormitory_CardNullableScalarRelationFilter, Dormitory_CardWhereInput> | null
    Employee_Card?: XOR<Employee_CardNullableScalarRelationFilter, Employee_CardWhereInput> | null
  }, "ID">

  export type Identity_CardOrderByWithAggregationInput = {
    ID?: SortOrder
    Issued_Date?: SortOrder
    _count?: Identity_CardCountOrderByAggregateInput
    _max?: Identity_CardMaxOrderByAggregateInput
    _min?: Identity_CardMinOrderByAggregateInput
  }

  export type Identity_CardScalarWhereWithAggregatesInput = {
    AND?: Identity_CardScalarWhereWithAggregatesInput | Identity_CardScalarWhereWithAggregatesInput[]
    OR?: Identity_CardScalarWhereWithAggregatesInput[]
    NOT?: Identity_CardScalarWhereWithAggregatesInput | Identity_CardScalarWhereWithAggregatesInput[]
    ID?: StringWithAggregatesFilter<"Identity_Card"> | string
    Issued_Date?: DateTimeWithAggregatesFilter<"Identity_Card"> | Date | string
  }

  export type PeopleWhereInput = {
    AND?: PeopleWhereInput | PeopleWhereInput[]
    OR?: PeopleWhereInput[]
    NOT?: PeopleWhereInput | PeopleWhereInput[]
    SSN?: StringFilter<"People"> | string
    Full_Name?: StringFilter<"People"> | string
    Last_Name?: StringFilter<"People"> | string
    Birthday?: DateTimeFilter<"People"> | Date | string
    Sex?: StringNullableFilter<"People"> | string | null
    Health_State?: StringNullableFilter<"People"> | string | null
    Ethnic_Group?: StringNullableFilter<"People"> | string | null
    Address?: AddressListRelationFilter
    Email?: EmailListRelationFilter
    PhoneNumber?: PhoneNumberListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
  }

  export type PeopleOrderByWithRelationInput = {
    SSN?: SortOrder
    Full_Name?: SortOrder
    Last_Name?: SortOrder
    Birthday?: SortOrder
    Sex?: SortOrderInput | SortOrder
    Health_State?: SortOrderInput | SortOrder
    Ethnic_Group?: SortOrderInput | SortOrder
    Address?: AddressOrderByRelationAggregateInput
    Email?: EmailOrderByRelationAggregateInput
    PhoneNumber?: PhoneNumberOrderByRelationAggregateInput
    employee?: employeeOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
    _relevance?: PeopleOrderByRelevanceInput
  }

  export type PeopleWhereUniqueInput = Prisma.AtLeast<{
    SSN?: string
    AND?: PeopleWhereInput | PeopleWhereInput[]
    OR?: PeopleWhereInput[]
    NOT?: PeopleWhereInput | PeopleWhereInput[]
    Full_Name?: StringFilter<"People"> | string
    Last_Name?: StringFilter<"People"> | string
    Birthday?: DateTimeFilter<"People"> | Date | string
    Sex?: StringNullableFilter<"People"> | string | null
    Health_State?: StringNullableFilter<"People"> | string | null
    Ethnic_Group?: StringNullableFilter<"People"> | string | null
    Address?: AddressListRelationFilter
    Email?: EmailListRelationFilter
    PhoneNumber?: PhoneNumberListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
  }, "SSN">

  export type PeopleOrderByWithAggregationInput = {
    SSN?: SortOrder
    Full_Name?: SortOrder
    Last_Name?: SortOrder
    Birthday?: SortOrder
    Sex?: SortOrderInput | SortOrder
    Health_State?: SortOrderInput | SortOrder
    Ethnic_Group?: SortOrderInput | SortOrder
    _count?: PeopleCountOrderByAggregateInput
    _max?: PeopleMaxOrderByAggregateInput
    _min?: PeopleMinOrderByAggregateInput
  }

  export type PeopleScalarWhereWithAggregatesInput = {
    AND?: PeopleScalarWhereWithAggregatesInput | PeopleScalarWhereWithAggregatesInput[]
    OR?: PeopleScalarWhereWithAggregatesInput[]
    NOT?: PeopleScalarWhereWithAggregatesInput | PeopleScalarWhereWithAggregatesInput[]
    SSN?: StringWithAggregatesFilter<"People"> | string
    Full_Name?: StringWithAggregatesFilter<"People"> | string
    Last_Name?: StringWithAggregatesFilter<"People"> | string
    Birthday?: DateTimeWithAggregatesFilter<"People"> | Date | string
    Sex?: StringNullableWithAggregatesFilter<"People"> | string | null
    Health_State?: StringNullableWithAggregatesFilter<"People"> | string | null
    Ethnic_Group?: StringNullableWithAggregatesFilter<"People"> | string | null
  }

  export type PhoneNumberWhereInput = {
    AND?: PhoneNumberWhereInput | PhoneNumberWhereInput[]
    OR?: PhoneNumberWhereInput[]
    NOT?: PhoneNumberWhereInput | PhoneNumberWhereInput[]
    ssn?: StringFilter<"PhoneNumber"> | string
    phoneNumber?: StringFilter<"PhoneNumber"> | string
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
  }

  export type PhoneNumberOrderByWithRelationInput = {
    ssn?: SortOrder
    phoneNumber?: SortOrder
    People?: PeopleOrderByWithRelationInput
    _relevance?: PhoneNumberOrderByRelevanceInput
  }

  export type PhoneNumberWhereUniqueInput = Prisma.AtLeast<{
    ssn_phoneNumber?: PhoneNumberSsnPhoneNumberCompoundUniqueInput
    AND?: PhoneNumberWhereInput | PhoneNumberWhereInput[]
    OR?: PhoneNumberWhereInput[]
    NOT?: PhoneNumberWhereInput | PhoneNumberWhereInput[]
    ssn?: StringFilter<"PhoneNumber"> | string
    phoneNumber?: StringFilter<"PhoneNumber"> | string
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
  }, "ssn_phoneNumber">

  export type PhoneNumberOrderByWithAggregationInput = {
    ssn?: SortOrder
    phoneNumber?: SortOrder
    _count?: PhoneNumberCountOrderByAggregateInput
    _max?: PhoneNumberMaxOrderByAggregateInput
    _min?: PhoneNumberMinOrderByAggregateInput
  }

  export type PhoneNumberScalarWhereWithAggregatesInput = {
    AND?: PhoneNumberScalarWhereWithAggregatesInput | PhoneNumberScalarWhereWithAggregatesInput[]
    OR?: PhoneNumberScalarWhereWithAggregatesInput[]
    NOT?: PhoneNumberScalarWhereWithAggregatesInput | PhoneNumberScalarWhereWithAggregatesInput[]
    ssn?: StringWithAggregatesFilter<"PhoneNumber"> | string
    phoneNumber?: StringWithAggregatesFilter<"PhoneNumber"> | string
  }

  export type buildingWhereInput = {
    AND?: buildingWhereInput | buildingWhereInput[]
    OR?: buildingWhereInput[]
    NOT?: buildingWhereInput | buildingWhereInput[]
    building_id?: StringFilter<"building"> | string
    building_name?: StringFilter<"building"> | string
    floors?: IntFilter<"building"> | number
    rooms?: IntFilter<"building"> | number
    has_air_conditioner?: BoolFilter<"building"> | boolean
    sponsor?: StringNullableFilter<"building"> | string | null
    construction_date?: DateTimeFilter<"building"> | Date | string
    last_renovation?: DateTimeNullableFilter<"building"> | Date | string | null
    building_equipment?: Building_equipmentListRelationFilter
    room?: RoomListRelationFilter
  }

  export type buildingOrderByWithRelationInput = {
    building_id?: SortOrder
    building_name?: SortOrder
    floors?: SortOrder
    rooms?: SortOrder
    has_air_conditioner?: SortOrder
    sponsor?: SortOrderInput | SortOrder
    construction_date?: SortOrder
    last_renovation?: SortOrderInput | SortOrder
    building_equipment?: building_equipmentOrderByRelationAggregateInput
    room?: roomOrderByRelationAggregateInput
    _relevance?: buildingOrderByRelevanceInput
  }

  export type buildingWhereUniqueInput = Prisma.AtLeast<{
    building_id?: string
    AND?: buildingWhereInput | buildingWhereInput[]
    OR?: buildingWhereInput[]
    NOT?: buildingWhereInput | buildingWhereInput[]
    building_name?: StringFilter<"building"> | string
    floors?: IntFilter<"building"> | number
    rooms?: IntFilter<"building"> | number
    has_air_conditioner?: BoolFilter<"building"> | boolean
    sponsor?: StringNullableFilter<"building"> | string | null
    construction_date?: DateTimeFilter<"building"> | Date | string
    last_renovation?: DateTimeNullableFilter<"building"> | Date | string | null
    building_equipment?: Building_equipmentListRelationFilter
    room?: RoomListRelationFilter
  }, "building_id">

  export type buildingOrderByWithAggregationInput = {
    building_id?: SortOrder
    building_name?: SortOrder
    floors?: SortOrder
    rooms?: SortOrder
    has_air_conditioner?: SortOrder
    sponsor?: SortOrderInput | SortOrder
    construction_date?: SortOrder
    last_renovation?: SortOrderInput | SortOrder
    _count?: buildingCountOrderByAggregateInput
    _avg?: buildingAvgOrderByAggregateInput
    _max?: buildingMaxOrderByAggregateInput
    _min?: buildingMinOrderByAggregateInput
    _sum?: buildingSumOrderByAggregateInput
  }

  export type buildingScalarWhereWithAggregatesInput = {
    AND?: buildingScalarWhereWithAggregatesInput | buildingScalarWhereWithAggregatesInput[]
    OR?: buildingScalarWhereWithAggregatesInput[]
    NOT?: buildingScalarWhereWithAggregatesInput | buildingScalarWhereWithAggregatesInput[]
    building_id?: StringWithAggregatesFilter<"building"> | string
    building_name?: StringWithAggregatesFilter<"building"> | string
    floors?: IntWithAggregatesFilter<"building"> | number
    rooms?: IntWithAggregatesFilter<"building"> | number
    has_air_conditioner?: BoolWithAggregatesFilter<"building"> | boolean
    sponsor?: StringNullableWithAggregatesFilter<"building"> | string | null
    construction_date?: DateTimeWithAggregatesFilter<"building"> | Date | string
    last_renovation?: DateTimeNullableWithAggregatesFilter<"building"> | Date | string | null
  }

  export type building_equipmentWhereInput = {
    AND?: building_equipmentWhereInput | building_equipmentWhereInput[]
    OR?: building_equipmentWhereInput[]
    NOT?: building_equipmentWhereInput | building_equipmentWhereInput[]
    building_id?: StringFilter<"building_equipment"> | string
    equipment_id?: StringFilter<"building_equipment"> | string
    quantity?: IntFilter<"building_equipment"> | number
    building?: XOR<BuildingScalarRelationFilter, buildingWhereInput>
    large_equipment?: XOR<Large_equipmentScalarRelationFilter, large_equipmentWhereInput>
  }

  export type building_equipmentOrderByWithRelationInput = {
    building_id?: SortOrder
    equipment_id?: SortOrder
    quantity?: SortOrder
    building?: buildingOrderByWithRelationInput
    large_equipment?: large_equipmentOrderByWithRelationInput
    _relevance?: building_equipmentOrderByRelevanceInput
  }

  export type building_equipmentWhereUniqueInput = Prisma.AtLeast<{
    building_id_equipment_id?: building_equipmentBuilding_idEquipment_idCompoundUniqueInput
    AND?: building_equipmentWhereInput | building_equipmentWhereInput[]
    OR?: building_equipmentWhereInput[]
    NOT?: building_equipmentWhereInput | building_equipmentWhereInput[]
    building_id?: StringFilter<"building_equipment"> | string
    equipment_id?: StringFilter<"building_equipment"> | string
    quantity?: IntFilter<"building_equipment"> | number
    building?: XOR<BuildingScalarRelationFilter, buildingWhereInput>
    large_equipment?: XOR<Large_equipmentScalarRelationFilter, large_equipmentWhereInput>
  }, "building_id_equipment_id">

  export type building_equipmentOrderByWithAggregationInput = {
    building_id?: SortOrder
    equipment_id?: SortOrder
    quantity?: SortOrder
    _count?: building_equipmentCountOrderByAggregateInput
    _avg?: building_equipmentAvgOrderByAggregateInput
    _max?: building_equipmentMaxOrderByAggregateInput
    _min?: building_equipmentMinOrderByAggregateInput
    _sum?: building_equipmentSumOrderByAggregateInput
  }

  export type building_equipmentScalarWhereWithAggregatesInput = {
    AND?: building_equipmentScalarWhereWithAggregatesInput | building_equipmentScalarWhereWithAggregatesInput[]
    OR?: building_equipmentScalarWhereWithAggregatesInput[]
    NOT?: building_equipmentScalarWhereWithAggregatesInput | building_equipmentScalarWhereWithAggregatesInput[]
    building_id?: StringWithAggregatesFilter<"building_equipment"> | string
    equipment_id?: StringWithAggregatesFilter<"building_equipment"> | string
    quantity?: IntWithAggregatesFilter<"building_equipment"> | number
  }

  export type disciplinaryActionWhereInput = {
    AND?: disciplinaryActionWhereInput | disciplinaryActionWhereInput[]
    OR?: disciplinaryActionWhereInput[]
    NOT?: disciplinaryActionWhereInput | disciplinaryActionWhereInput[]
    actionId?: StringFilter<"disciplinaryAction"> | string
    actionType?: StringFilter<"disciplinaryAction"> | string
    reason?: StringFilter<"disciplinaryAction"> | string
    decisionDate?: DateTimeFilter<"disciplinaryAction"> | Date | string
    effectiveFrom?: DateTimeFilter<"disciplinaryAction"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"disciplinaryAction"> | Date | string | null
    severityLevel?: StringNullableFilter<"disciplinaryAction"> | string | null
    status?: StringNullableFilter<"disciplinaryAction"> | string | null
    disciplineStaff?: DisciplineStaffListRelationFilter
    studentDiscipline?: StudentDisciplineListRelationFilter
  }

  export type disciplinaryActionOrderByWithRelationInput = {
    actionId?: SortOrder
    actionType?: SortOrder
    reason?: SortOrder
    decisionDate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    severityLevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    disciplineStaff?: disciplineStaffOrderByRelationAggregateInput
    studentDiscipline?: studentDisciplineOrderByRelationAggregateInput
    _relevance?: disciplinaryActionOrderByRelevanceInput
  }

  export type disciplinaryActionWhereUniqueInput = Prisma.AtLeast<{
    actionId?: string
    AND?: disciplinaryActionWhereInput | disciplinaryActionWhereInput[]
    OR?: disciplinaryActionWhereInput[]
    NOT?: disciplinaryActionWhereInput | disciplinaryActionWhereInput[]
    actionType?: StringFilter<"disciplinaryAction"> | string
    reason?: StringFilter<"disciplinaryAction"> | string
    decisionDate?: DateTimeFilter<"disciplinaryAction"> | Date | string
    effectiveFrom?: DateTimeFilter<"disciplinaryAction"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"disciplinaryAction"> | Date | string | null
    severityLevel?: StringNullableFilter<"disciplinaryAction"> | string | null
    status?: StringNullableFilter<"disciplinaryAction"> | string | null
    disciplineStaff?: DisciplineStaffListRelationFilter
    studentDiscipline?: StudentDisciplineListRelationFilter
  }, "actionId">

  export type disciplinaryActionOrderByWithAggregationInput = {
    actionId?: SortOrder
    actionType?: SortOrder
    reason?: SortOrder
    decisionDate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    severityLevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: disciplinaryActionCountOrderByAggregateInput
    _max?: disciplinaryActionMaxOrderByAggregateInput
    _min?: disciplinaryActionMinOrderByAggregateInput
  }

  export type disciplinaryActionScalarWhereWithAggregatesInput = {
    AND?: disciplinaryActionScalarWhereWithAggregatesInput | disciplinaryActionScalarWhereWithAggregatesInput[]
    OR?: disciplinaryActionScalarWhereWithAggregatesInput[]
    NOT?: disciplinaryActionScalarWhereWithAggregatesInput | disciplinaryActionScalarWhereWithAggregatesInput[]
    actionId?: StringWithAggregatesFilter<"disciplinaryAction"> | string
    actionType?: StringWithAggregatesFilter<"disciplinaryAction"> | string
    reason?: StringWithAggregatesFilter<"disciplinaryAction"> | string
    decisionDate?: DateTimeWithAggregatesFilter<"disciplinaryAction"> | Date | string
    effectiveFrom?: DateTimeWithAggregatesFilter<"disciplinaryAction"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"disciplinaryAction"> | Date | string | null
    severityLevel?: StringNullableWithAggregatesFilter<"disciplinaryAction"> | string | null
    status?: StringNullableWithAggregatesFilter<"disciplinaryAction"> | string | null
  }

  export type disciplineStaffWhereInput = {
    AND?: disciplineStaffWhereInput | disciplineStaffWhereInput[]
    OR?: disciplineStaffWhereInput[]
    NOT?: disciplineStaffWhereInput | disciplineStaffWhereInput[]
    actionId?: StringFilter<"disciplineStaff"> | string
    essn?: StringFilter<"disciplineStaff"> | string
    disciplinaryAction?: XOR<DisciplinaryActionScalarRelationFilter, disciplinaryActionWhereInput>
    manager_employee?: XOR<Manager_employeeScalarRelationFilter, manager_employeeWhereInput>
  }

  export type disciplineStaffOrderByWithRelationInput = {
    actionId?: SortOrder
    essn?: SortOrder
    disciplinaryAction?: disciplinaryActionOrderByWithRelationInput
    manager_employee?: manager_employeeOrderByWithRelationInput
    _relevance?: disciplineStaffOrderByRelevanceInput
  }

  export type disciplineStaffWhereUniqueInput = Prisma.AtLeast<{
    actionId_essn?: disciplineStaffActionIdEssnCompoundUniqueInput
    AND?: disciplineStaffWhereInput | disciplineStaffWhereInput[]
    OR?: disciplineStaffWhereInput[]
    NOT?: disciplineStaffWhereInput | disciplineStaffWhereInput[]
    actionId?: StringFilter<"disciplineStaff"> | string
    essn?: StringFilter<"disciplineStaff"> | string
    disciplinaryAction?: XOR<DisciplinaryActionScalarRelationFilter, disciplinaryActionWhereInput>
    manager_employee?: XOR<Manager_employeeScalarRelationFilter, manager_employeeWhereInput>
  }, "actionId_essn">

  export type disciplineStaffOrderByWithAggregationInput = {
    actionId?: SortOrder
    essn?: SortOrder
    _count?: disciplineStaffCountOrderByAggregateInput
    _max?: disciplineStaffMaxOrderByAggregateInput
    _min?: disciplineStaffMinOrderByAggregateInput
  }

  export type disciplineStaffScalarWhereWithAggregatesInput = {
    AND?: disciplineStaffScalarWhereWithAggregatesInput | disciplineStaffScalarWhereWithAggregatesInput[]
    OR?: disciplineStaffScalarWhereWithAggregatesInput[]
    NOT?: disciplineStaffScalarWhereWithAggregatesInput | disciplineStaffScalarWhereWithAggregatesInput[]
    actionId?: StringWithAggregatesFilter<"disciplineStaff"> | string
    essn?: StringWithAggregatesFilter<"disciplineStaff"> | string
  }

  export type employeeWhereInput = {
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    essn?: StringFilter<"employee"> | string
    salary?: DecimalNullableFilter<"employee"> | Decimal | DecimalJsLike | number | string | null
    empId?: StringNullableFilter<"employee"> | string | null
    Employee_Card?: Employee_CardListRelationFilter
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
    manager_employee?: XOR<Manager_employeeNullableScalarRelationFilter, manager_employeeWhereInput> | null
    medical_employee?: XOR<Medical_employeeNullableScalarRelationFilter, medical_employeeWhereInput> | null
    other_employee?: XOR<Other_employeeNullableScalarRelationFilter, other_employeeWhereInput> | null
  }

  export type employeeOrderByWithRelationInput = {
    essn?: SortOrder
    salary?: SortOrderInput | SortOrder
    empId?: SortOrderInput | SortOrder
    Employee_Card?: Employee_CardOrderByRelationAggregateInput
    People?: PeopleOrderByWithRelationInput
    manager_employee?: manager_employeeOrderByWithRelationInput
    medical_employee?: medical_employeeOrderByWithRelationInput
    other_employee?: other_employeeOrderByWithRelationInput
    _relevance?: employeeOrderByRelevanceInput
  }

  export type employeeWhereUniqueInput = Prisma.AtLeast<{
    essn?: string
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    salary?: DecimalNullableFilter<"employee"> | Decimal | DecimalJsLike | number | string | null
    empId?: StringNullableFilter<"employee"> | string | null
    Employee_Card?: Employee_CardListRelationFilter
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
    manager_employee?: XOR<Manager_employeeNullableScalarRelationFilter, manager_employeeWhereInput> | null
    medical_employee?: XOR<Medical_employeeNullableScalarRelationFilter, medical_employeeWhereInput> | null
    other_employee?: XOR<Other_employeeNullableScalarRelationFilter, other_employeeWhereInput> | null
  }, "essn">

  export type employeeOrderByWithAggregationInput = {
    essn?: SortOrder
    salary?: SortOrderInput | SortOrder
    empId?: SortOrderInput | SortOrder
    _count?: employeeCountOrderByAggregateInput
    _avg?: employeeAvgOrderByAggregateInput
    _max?: employeeMaxOrderByAggregateInput
    _min?: employeeMinOrderByAggregateInput
    _sum?: employeeSumOrderByAggregateInput
  }

  export type employeeScalarWhereWithAggregatesInput = {
    AND?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    OR?: employeeScalarWhereWithAggregatesInput[]
    NOT?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    essn?: StringWithAggregatesFilter<"employee"> | string
    salary?: DecimalNullableWithAggregatesFilter<"employee"> | Decimal | DecimalJsLike | number | string | null
    empId?: StringNullableWithAggregatesFilter<"employee"> | string | null
  }

  export type health_roomWhereInput = {
    AND?: health_roomWhereInput | health_roomWhereInput[]
    OR?: health_roomWhereInput[]
    NOT?: health_roomWhereInput | health_roomWhereInput[]
    building_id?: StringFilter<"health_room"> | string
    room_id?: StringFilter<"health_room"> | string
    num_of_staff?: IntFilter<"health_room"> | number
    start_time?: DateTimeFilter<"health_room"> | Date | string
    end_time?: DateTimeFilter<"health_room"> | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFilter<"health_room"> | $Enums.health_room_equipment_status
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    medical_employee?: Medical_employeeListRelationFilter
  }

  export type health_roomOrderByWithRelationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    equipment_status?: SortOrder
    room?: roomOrderByWithRelationInput
    medical_employee?: medical_employeeOrderByRelationAggregateInput
    _relevance?: health_roomOrderByRelevanceInput
  }

  export type health_roomWhereUniqueInput = Prisma.AtLeast<{
    building_id_room_id?: health_roomBuilding_idRoom_idCompoundUniqueInput
    AND?: health_roomWhereInput | health_roomWhereInput[]
    OR?: health_roomWhereInput[]
    NOT?: health_roomWhereInput | health_roomWhereInput[]
    building_id?: StringFilter<"health_room"> | string
    room_id?: StringFilter<"health_room"> | string
    num_of_staff?: IntFilter<"health_room"> | number
    start_time?: DateTimeFilter<"health_room"> | Date | string
    end_time?: DateTimeFilter<"health_room"> | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFilter<"health_room"> | $Enums.health_room_equipment_status
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    medical_employee?: Medical_employeeListRelationFilter
  }, "building_id_room_id">

  export type health_roomOrderByWithAggregationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    equipment_status?: SortOrder
    _count?: health_roomCountOrderByAggregateInput
    _avg?: health_roomAvgOrderByAggregateInput
    _max?: health_roomMaxOrderByAggregateInput
    _min?: health_roomMinOrderByAggregateInput
    _sum?: health_roomSumOrderByAggregateInput
  }

  export type health_roomScalarWhereWithAggregatesInput = {
    AND?: health_roomScalarWhereWithAggregatesInput | health_roomScalarWhereWithAggregatesInput[]
    OR?: health_roomScalarWhereWithAggregatesInput[]
    NOT?: health_roomScalarWhereWithAggregatesInput | health_roomScalarWhereWithAggregatesInput[]
    building_id?: StringWithAggregatesFilter<"health_room"> | string
    room_id?: StringWithAggregatesFilter<"health_room"> | string
    num_of_staff?: IntWithAggregatesFilter<"health_room"> | number
    start_time?: DateTimeWithAggregatesFilter<"health_room"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"health_room"> | Date | string
    equipment_status?: Enumhealth_room_equipment_statusWithAggregatesFilter<"health_room"> | $Enums.health_room_equipment_status
  }

  export type large_equipmentWhereInput = {
    AND?: large_equipmentWhereInput | large_equipmentWhereInput[]
    OR?: large_equipmentWhereInput[]
    NOT?: large_equipmentWhereInput | large_equipmentWhereInput[]
    equipment_id?: StringFilter<"large_equipment"> | string
    equipment_name?: StringFilter<"large_equipment"> | string
    equipment_type?: StringFilter<"large_equipment"> | string
    equipment_status?: Enumlarge_equipment_equipment_statusFilter<"large_equipment"> | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFilter<"large_equipment"> | Date | string
    purchase_location?: StringNullableFilter<"large_equipment"> | string | null
    building_equipment?: Building_equipmentListRelationFilter
  }

  export type large_equipmentOrderByWithRelationInput = {
    equipment_id?: SortOrder
    equipment_name?: SortOrder
    equipment_type?: SortOrder
    equipment_status?: SortOrder
    purchase_date?: SortOrder
    purchase_location?: SortOrderInput | SortOrder
    building_equipment?: building_equipmentOrderByRelationAggregateInput
    _relevance?: large_equipmentOrderByRelevanceInput
  }

  export type large_equipmentWhereUniqueInput = Prisma.AtLeast<{
    equipment_id?: string
    AND?: large_equipmentWhereInput | large_equipmentWhereInput[]
    OR?: large_equipmentWhereInput[]
    NOT?: large_equipmentWhereInput | large_equipmentWhereInput[]
    equipment_name?: StringFilter<"large_equipment"> | string
    equipment_type?: StringFilter<"large_equipment"> | string
    equipment_status?: Enumlarge_equipment_equipment_statusFilter<"large_equipment"> | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFilter<"large_equipment"> | Date | string
    purchase_location?: StringNullableFilter<"large_equipment"> | string | null
    building_equipment?: Building_equipmentListRelationFilter
  }, "equipment_id">

  export type large_equipmentOrderByWithAggregationInput = {
    equipment_id?: SortOrder
    equipment_name?: SortOrder
    equipment_type?: SortOrder
    equipment_status?: SortOrder
    purchase_date?: SortOrder
    purchase_location?: SortOrderInput | SortOrder
    _count?: large_equipmentCountOrderByAggregateInput
    _max?: large_equipmentMaxOrderByAggregateInput
    _min?: large_equipmentMinOrderByAggregateInput
  }

  export type large_equipmentScalarWhereWithAggregatesInput = {
    AND?: large_equipmentScalarWhereWithAggregatesInput | large_equipmentScalarWhereWithAggregatesInput[]
    OR?: large_equipmentScalarWhereWithAggregatesInput[]
    NOT?: large_equipmentScalarWhereWithAggregatesInput | large_equipmentScalarWhereWithAggregatesInput[]
    equipment_id?: StringWithAggregatesFilter<"large_equipment"> | string
    equipment_name?: StringWithAggregatesFilter<"large_equipment"> | string
    equipment_type?: StringWithAggregatesFilter<"large_equipment"> | string
    equipment_status?: Enumlarge_equipment_equipment_statusWithAggregatesFilter<"large_equipment"> | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeWithAggregatesFilter<"large_equipment"> | Date | string
    purchase_location?: StringNullableWithAggregatesFilter<"large_equipment"> | string | null
  }

  export type living_roomWhereInput = {
    AND?: living_roomWhereInput | living_roomWhereInput[]
    OR?: living_roomWhereInput[]
    NOT?: living_roomWhereInput | living_roomWhereInput[]
    building_id?: StringFilter<"living_room"> | string
    room_id?: StringFilter<"living_room"> | string
    max_num_of_students?: IntFilter<"living_room"> | number
    current_num_of_students?: IntFilter<"living_room"> | number
    rental_price?: DecimalFilter<"living_room"> | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFilter<"living_room"> | Decimal | DecimalJsLike | number | string
    student?: StudentListRelationFilter
  }

  export type living_roomOrderByWithRelationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    max_num_of_students?: SortOrder
    current_num_of_students?: SortOrder
    rental_price?: SortOrder
    occupancy_rate?: SortOrder
    student?: studentOrderByRelationAggregateInput
    _relevance?: living_roomOrderByRelevanceInput
  }

  export type living_roomWhereUniqueInput = Prisma.AtLeast<{
    building_id_room_id?: living_roomBuilding_idRoom_idCompoundUniqueInput
    AND?: living_roomWhereInput | living_roomWhereInput[]
    OR?: living_roomWhereInput[]
    NOT?: living_roomWhereInput | living_roomWhereInput[]
    building_id?: StringFilter<"living_room"> | string
    room_id?: StringFilter<"living_room"> | string
    max_num_of_students?: IntFilter<"living_room"> | number
    current_num_of_students?: IntFilter<"living_room"> | number
    rental_price?: DecimalFilter<"living_room"> | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFilter<"living_room"> | Decimal | DecimalJsLike | number | string
    student?: StudentListRelationFilter
  }, "building_id_room_id">

  export type living_roomOrderByWithAggregationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    max_num_of_students?: SortOrder
    current_num_of_students?: SortOrder
    rental_price?: SortOrder
    occupancy_rate?: SortOrder
    _count?: living_roomCountOrderByAggregateInput
    _avg?: living_roomAvgOrderByAggregateInput
    _max?: living_roomMaxOrderByAggregateInput
    _min?: living_roomMinOrderByAggregateInput
    _sum?: living_roomSumOrderByAggregateInput
  }

  export type living_roomScalarWhereWithAggregatesInput = {
    AND?: living_roomScalarWhereWithAggregatesInput | living_roomScalarWhereWithAggregatesInput[]
    OR?: living_roomScalarWhereWithAggregatesInput[]
    NOT?: living_roomScalarWhereWithAggregatesInput | living_roomScalarWhereWithAggregatesInput[]
    building_id?: StringWithAggregatesFilter<"living_room"> | string
    room_id?: StringWithAggregatesFilter<"living_room"> | string
    max_num_of_students?: IntWithAggregatesFilter<"living_room"> | number
    current_num_of_students?: IntWithAggregatesFilter<"living_room"> | number
    rental_price?: DecimalWithAggregatesFilter<"living_room"> | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalWithAggregatesFilter<"living_room"> | Decimal | DecimalJsLike | number | string
  }

  export type management_roomWhereInput = {
    AND?: management_roomWhereInput | management_roomWhereInput[]
    OR?: management_roomWhereInput[]
    NOT?: management_roomWhereInput | management_roomWhereInput[]
    building_id?: StringFilter<"management_room"> | string
    room_id?: StringFilter<"management_room"> | string
    num_of_staff?: IntFilter<"management_room"> | number
    start_time?: DateTimeFilter<"management_room"> | Date | string
    end_time?: DateTimeFilter<"management_room"> | Date | string
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    manager_employee?: Manager_employeeListRelationFilter
  }

  export type management_roomOrderByWithRelationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: roomOrderByWithRelationInput
    manager_employee?: manager_employeeOrderByRelationAggregateInput
    _relevance?: management_roomOrderByRelevanceInput
  }

  export type management_roomWhereUniqueInput = Prisma.AtLeast<{
    building_id_room_id?: management_roomBuilding_idRoom_idCompoundUniqueInput
    AND?: management_roomWhereInput | management_roomWhereInput[]
    OR?: management_roomWhereInput[]
    NOT?: management_roomWhereInput | management_roomWhereInput[]
    building_id?: StringFilter<"management_room"> | string
    room_id?: StringFilter<"management_room"> | string
    num_of_staff?: IntFilter<"management_room"> | number
    start_time?: DateTimeFilter<"management_room"> | Date | string
    end_time?: DateTimeFilter<"management_room"> | Date | string
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    manager_employee?: Manager_employeeListRelationFilter
  }, "building_id_room_id">

  export type management_roomOrderByWithAggregationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    _count?: management_roomCountOrderByAggregateInput
    _avg?: management_roomAvgOrderByAggregateInput
    _max?: management_roomMaxOrderByAggregateInput
    _min?: management_roomMinOrderByAggregateInput
    _sum?: management_roomSumOrderByAggregateInput
  }

  export type management_roomScalarWhereWithAggregatesInput = {
    AND?: management_roomScalarWhereWithAggregatesInput | management_roomScalarWhereWithAggregatesInput[]
    OR?: management_roomScalarWhereWithAggregatesInput[]
    NOT?: management_roomScalarWhereWithAggregatesInput | management_roomScalarWhereWithAggregatesInput[]
    building_id?: StringWithAggregatesFilter<"management_room"> | string
    room_id?: StringWithAggregatesFilter<"management_room"> | string
    num_of_staff?: IntWithAggregatesFilter<"management_room"> | number
    start_time?: DateTimeWithAggregatesFilter<"management_room"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"management_room"> | Date | string
  }

  export type managerDormWhereInput = {
    AND?: managerDormWhereInput | managerDormWhereInput[]
    OR?: managerDormWhereInput[]
    NOT?: managerDormWhereInput | managerDormWhereInput[]
    user_name?: StringFilter<"managerDorm"> | string
    password?: StringFilter<"managerDorm"> | string
  }

  export type managerDormOrderByWithRelationInput = {
    user_name?: SortOrder
    password?: SortOrder
    _relevance?: managerDormOrderByRelevanceInput
  }

  export type managerDormWhereUniqueInput = Prisma.AtLeast<{
    user_name_password?: managerDormUser_namePasswordCompoundUniqueInput
    AND?: managerDormWhereInput | managerDormWhereInput[]
    OR?: managerDormWhereInput[]
    NOT?: managerDormWhereInput | managerDormWhereInput[]
    user_name?: StringFilter<"managerDorm"> | string
    password?: StringFilter<"managerDorm"> | string
  }, "user_name_password">

  export type managerDormOrderByWithAggregationInput = {
    user_name?: SortOrder
    password?: SortOrder
    _count?: managerDormCountOrderByAggregateInput
    _max?: managerDormMaxOrderByAggregateInput
    _min?: managerDormMinOrderByAggregateInput
  }

  export type managerDormScalarWhereWithAggregatesInput = {
    AND?: managerDormScalarWhereWithAggregatesInput | managerDormScalarWhereWithAggregatesInput[]
    OR?: managerDormScalarWhereWithAggregatesInput[]
    NOT?: managerDormScalarWhereWithAggregatesInput | managerDormScalarWhereWithAggregatesInput[]
    user_name?: StringWithAggregatesFilter<"managerDorm"> | string
    password?: StringWithAggregatesFilter<"managerDorm"> | string
  }

  export type manager_degreeWhereInput = {
    AND?: manager_degreeWhereInput | manager_degreeWhereInput[]
    OR?: manager_degreeWhereInput[]
    NOT?: manager_degreeWhereInput | manager_degreeWhereInput[]
    essn?: StringFilter<"manager_degree"> | string
    degree?: StringFilter<"manager_degree"> | string
    manager_employee?: XOR<Manager_employeeScalarRelationFilter, manager_employeeWhereInput>
  }

  export type manager_degreeOrderByWithRelationInput = {
    essn?: SortOrder
    degree?: SortOrder
    manager_employee?: manager_employeeOrderByWithRelationInput
    _relevance?: manager_degreeOrderByRelevanceInput
  }

  export type manager_degreeWhereUniqueInput = Prisma.AtLeast<{
    essn_degree?: manager_degreeEssnDegreeCompoundUniqueInput
    AND?: manager_degreeWhereInput | manager_degreeWhereInput[]
    OR?: manager_degreeWhereInput[]
    NOT?: manager_degreeWhereInput | manager_degreeWhereInput[]
    essn?: StringFilter<"manager_degree"> | string
    degree?: StringFilter<"manager_degree"> | string
    manager_employee?: XOR<Manager_employeeScalarRelationFilter, manager_employeeWhereInput>
  }, "essn_degree">

  export type manager_degreeOrderByWithAggregationInput = {
    essn?: SortOrder
    degree?: SortOrder
    _count?: manager_degreeCountOrderByAggregateInput
    _max?: manager_degreeMaxOrderByAggregateInput
    _min?: manager_degreeMinOrderByAggregateInput
  }

  export type manager_degreeScalarWhereWithAggregatesInput = {
    AND?: manager_degreeScalarWhereWithAggregatesInput | manager_degreeScalarWhereWithAggregatesInput[]
    OR?: manager_degreeScalarWhereWithAggregatesInput[]
    NOT?: manager_degreeScalarWhereWithAggregatesInput | manager_degreeScalarWhereWithAggregatesInput[]
    essn?: StringWithAggregatesFilter<"manager_degree"> | string
    degree?: StringWithAggregatesFilter<"manager_degree"> | string
  }

  export type manager_employeeWhereInput = {
    AND?: manager_employeeWhereInput | manager_employeeWhereInput[]
    OR?: manager_employeeWhereInput[]
    NOT?: manager_employeeWhereInput | manager_employeeWhereInput[]
    essn?: StringFilter<"manager_employee"> | string
    room_id?: StringNullableFilter<"manager_employee"> | string | null
    building_id?: StringNullableFilter<"manager_employee"> | string | null
    experience?: DecimalNullableFilter<"manager_employee"> | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: DisciplineStaffListRelationFilter
    manager_degree?: Manager_degreeListRelationFilter
    management_room?: XOR<Management_roomNullableScalarRelationFilter, management_roomWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type manager_employeeOrderByWithRelationInput = {
    essn?: SortOrder
    room_id?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    disciplineStaff?: disciplineStaffOrderByRelationAggregateInput
    manager_degree?: manager_degreeOrderByRelationAggregateInput
    management_room?: management_roomOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    _relevance?: manager_employeeOrderByRelevanceInput
  }

  export type manager_employeeWhereUniqueInput = Prisma.AtLeast<{
    essn?: string
    AND?: manager_employeeWhereInput | manager_employeeWhereInput[]
    OR?: manager_employeeWhereInput[]
    NOT?: manager_employeeWhereInput | manager_employeeWhereInput[]
    room_id?: StringNullableFilter<"manager_employee"> | string | null
    building_id?: StringNullableFilter<"manager_employee"> | string | null
    experience?: DecimalNullableFilter<"manager_employee"> | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: DisciplineStaffListRelationFilter
    manager_degree?: Manager_degreeListRelationFilter
    management_room?: XOR<Management_roomNullableScalarRelationFilter, management_roomWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "essn">

  export type manager_employeeOrderByWithAggregationInput = {
    essn?: SortOrder
    room_id?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    _count?: manager_employeeCountOrderByAggregateInput
    _avg?: manager_employeeAvgOrderByAggregateInput
    _max?: manager_employeeMaxOrderByAggregateInput
    _min?: manager_employeeMinOrderByAggregateInput
    _sum?: manager_employeeSumOrderByAggregateInput
  }

  export type manager_employeeScalarWhereWithAggregatesInput = {
    AND?: manager_employeeScalarWhereWithAggregatesInput | manager_employeeScalarWhereWithAggregatesInput[]
    OR?: manager_employeeScalarWhereWithAggregatesInput[]
    NOT?: manager_employeeScalarWhereWithAggregatesInput | manager_employeeScalarWhereWithAggregatesInput[]
    essn?: StringWithAggregatesFilter<"manager_employee"> | string
    room_id?: StringNullableWithAggregatesFilter<"manager_employee"> | string | null
    building_id?: StringNullableWithAggregatesFilter<"manager_employee"> | string | null
    experience?: DecimalNullableWithAggregatesFilter<"manager_employee"> | Decimal | DecimalJsLike | number | string | null
  }

  export type medical_degreeWhereInput = {
    AND?: medical_degreeWhereInput | medical_degreeWhereInput[]
    OR?: medical_degreeWhereInput[]
    NOT?: medical_degreeWhereInput | medical_degreeWhereInput[]
    essn?: StringFilter<"medical_degree"> | string
    degree?: StringFilter<"medical_degree"> | string
    medical_employee?: XOR<Medical_employeeScalarRelationFilter, medical_employeeWhereInput>
  }

  export type medical_degreeOrderByWithRelationInput = {
    essn?: SortOrder
    degree?: SortOrder
    medical_employee?: medical_employeeOrderByWithRelationInput
    _relevance?: medical_degreeOrderByRelevanceInput
  }

  export type medical_degreeWhereUniqueInput = Prisma.AtLeast<{
    essn_degree?: medical_degreeEssnDegreeCompoundUniqueInput
    AND?: medical_degreeWhereInput | medical_degreeWhereInput[]
    OR?: medical_degreeWhereInput[]
    NOT?: medical_degreeWhereInput | medical_degreeWhereInput[]
    essn?: StringFilter<"medical_degree"> | string
    degree?: StringFilter<"medical_degree"> | string
    medical_employee?: XOR<Medical_employeeScalarRelationFilter, medical_employeeWhereInput>
  }, "essn_degree">

  export type medical_degreeOrderByWithAggregationInput = {
    essn?: SortOrder
    degree?: SortOrder
    _count?: medical_degreeCountOrderByAggregateInput
    _max?: medical_degreeMaxOrderByAggregateInput
    _min?: medical_degreeMinOrderByAggregateInput
  }

  export type medical_degreeScalarWhereWithAggregatesInput = {
    AND?: medical_degreeScalarWhereWithAggregatesInput | medical_degreeScalarWhereWithAggregatesInput[]
    OR?: medical_degreeScalarWhereWithAggregatesInput[]
    NOT?: medical_degreeScalarWhereWithAggregatesInput | medical_degreeScalarWhereWithAggregatesInput[]
    essn?: StringWithAggregatesFilter<"medical_degree"> | string
    degree?: StringWithAggregatesFilter<"medical_degree"> | string
  }

  export type medical_employeeWhereInput = {
    AND?: medical_employeeWhereInput | medical_employeeWhereInput[]
    OR?: medical_employeeWhereInput[]
    NOT?: medical_employeeWhereInput | medical_employeeWhereInput[]
    essn?: StringFilter<"medical_employee"> | string
    room_id?: StringNullableFilter<"medical_employee"> | string | null
    building_id?: StringNullableFilter<"medical_employee"> | string | null
    experience?: DecimalNullableFilter<"medical_employee"> | Decimal | DecimalJsLike | number | string | null
    medical_degree?: Medical_degreeListRelationFilter
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    health_room?: XOR<Health_roomNullableScalarRelationFilter, health_roomWhereInput> | null
  }

  export type medical_employeeOrderByWithRelationInput = {
    essn?: SortOrder
    room_id?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    medical_degree?: medical_degreeOrderByRelationAggregateInput
    employee?: employeeOrderByWithRelationInput
    health_room?: health_roomOrderByWithRelationInput
    _relevance?: medical_employeeOrderByRelevanceInput
  }

  export type medical_employeeWhereUniqueInput = Prisma.AtLeast<{
    essn?: string
    AND?: medical_employeeWhereInput | medical_employeeWhereInput[]
    OR?: medical_employeeWhereInput[]
    NOT?: medical_employeeWhereInput | medical_employeeWhereInput[]
    room_id?: StringNullableFilter<"medical_employee"> | string | null
    building_id?: StringNullableFilter<"medical_employee"> | string | null
    experience?: DecimalNullableFilter<"medical_employee"> | Decimal | DecimalJsLike | number | string | null
    medical_degree?: Medical_degreeListRelationFilter
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    health_room?: XOR<Health_roomNullableScalarRelationFilter, health_roomWhereInput> | null
  }, "essn">

  export type medical_employeeOrderByWithAggregationInput = {
    essn?: SortOrder
    room_id?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    _count?: medical_employeeCountOrderByAggregateInput
    _avg?: medical_employeeAvgOrderByAggregateInput
    _max?: medical_employeeMaxOrderByAggregateInput
    _min?: medical_employeeMinOrderByAggregateInput
    _sum?: medical_employeeSumOrderByAggregateInput
  }

  export type medical_employeeScalarWhereWithAggregatesInput = {
    AND?: medical_employeeScalarWhereWithAggregatesInput | medical_employeeScalarWhereWithAggregatesInput[]
    OR?: medical_employeeScalarWhereWithAggregatesInput[]
    NOT?: medical_employeeScalarWhereWithAggregatesInput | medical_employeeScalarWhereWithAggregatesInput[]
    essn?: StringWithAggregatesFilter<"medical_employee"> | string
    room_id?: StringNullableWithAggregatesFilter<"medical_employee"> | string | null
    building_id?: StringNullableWithAggregatesFilter<"medical_employee"> | string | null
    experience?: DecimalNullableWithAggregatesFilter<"medical_employee"> | Decimal | DecimalJsLike | number | string | null
  }

  export type other_employeeWhereInput = {
    AND?: other_employeeWhereInput | other_employeeWhereInput[]
    OR?: other_employeeWhereInput[]
    NOT?: other_employeeWhereInput | other_employeeWhereInput[]
    essn?: StringFilter<"other_employee"> | string
    room_id?: StringNullableFilter<"other_employee"> | string | null
    building_id?: StringNullableFilter<"other_employee"> | string | null
    typeWork?: StringNullableFilter<"other_employee"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    other_room?: XOR<Other_roomNullableScalarRelationFilter, other_roomWhereInput> | null
    other_employee_time_work?: Other_employee_time_workListRelationFilter
  }

  export type other_employeeOrderByWithRelationInput = {
    essn?: SortOrder
    room_id?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    typeWork?: SortOrderInput | SortOrder
    employee?: employeeOrderByWithRelationInput
    other_room?: other_roomOrderByWithRelationInput
    other_employee_time_work?: other_employee_time_workOrderByRelationAggregateInput
    _relevance?: other_employeeOrderByRelevanceInput
  }

  export type other_employeeWhereUniqueInput = Prisma.AtLeast<{
    essn?: string
    AND?: other_employeeWhereInput | other_employeeWhereInput[]
    OR?: other_employeeWhereInput[]
    NOT?: other_employeeWhereInput | other_employeeWhereInput[]
    room_id?: StringNullableFilter<"other_employee"> | string | null
    building_id?: StringNullableFilter<"other_employee"> | string | null
    typeWork?: StringNullableFilter<"other_employee"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    other_room?: XOR<Other_roomNullableScalarRelationFilter, other_roomWhereInput> | null
    other_employee_time_work?: Other_employee_time_workListRelationFilter
  }, "essn">

  export type other_employeeOrderByWithAggregationInput = {
    essn?: SortOrder
    room_id?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    typeWork?: SortOrderInput | SortOrder
    _count?: other_employeeCountOrderByAggregateInput
    _max?: other_employeeMaxOrderByAggregateInput
    _min?: other_employeeMinOrderByAggregateInput
  }

  export type other_employeeScalarWhereWithAggregatesInput = {
    AND?: other_employeeScalarWhereWithAggregatesInput | other_employeeScalarWhereWithAggregatesInput[]
    OR?: other_employeeScalarWhereWithAggregatesInput[]
    NOT?: other_employeeScalarWhereWithAggregatesInput | other_employeeScalarWhereWithAggregatesInput[]
    essn?: StringWithAggregatesFilter<"other_employee"> | string
    room_id?: StringNullableWithAggregatesFilter<"other_employee"> | string | null
    building_id?: StringNullableWithAggregatesFilter<"other_employee"> | string | null
    typeWork?: StringNullableWithAggregatesFilter<"other_employee"> | string | null
  }

  export type other_employee_time_workWhereInput = {
    AND?: other_employee_time_workWhereInput | other_employee_time_workWhereInput[]
    OR?: other_employee_time_workWhereInput[]
    NOT?: other_employee_time_workWhereInput | other_employee_time_workWhereInput[]
    essn?: StringFilter<"other_employee_time_work"> | string
    date_work?: Enumother_employee_time_work_date_workFilter<"other_employee_time_work"> | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFilter<"other_employee_time_work"> | Date | string
    time_end?: DateTimeFilter<"other_employee_time_work"> | Date | string
    other_employee?: XOR<Other_employeeScalarRelationFilter, other_employeeWhereInput>
  }

  export type other_employee_time_workOrderByWithRelationInput = {
    essn?: SortOrder
    date_work?: SortOrder
    time_start?: SortOrder
    time_end?: SortOrder
    other_employee?: other_employeeOrderByWithRelationInput
    _relevance?: other_employee_time_workOrderByRelevanceInput
  }

  export type other_employee_time_workWhereUniqueInput = Prisma.AtLeast<{
    essn_date_work_time_start_time_end?: other_employee_time_workEssnDate_workTime_startTime_endCompoundUniqueInput
    AND?: other_employee_time_workWhereInput | other_employee_time_workWhereInput[]
    OR?: other_employee_time_workWhereInput[]
    NOT?: other_employee_time_workWhereInput | other_employee_time_workWhereInput[]
    essn?: StringFilter<"other_employee_time_work"> | string
    date_work?: Enumother_employee_time_work_date_workFilter<"other_employee_time_work"> | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFilter<"other_employee_time_work"> | Date | string
    time_end?: DateTimeFilter<"other_employee_time_work"> | Date | string
    other_employee?: XOR<Other_employeeScalarRelationFilter, other_employeeWhereInput>
  }, "essn_date_work_time_start_time_end">

  export type other_employee_time_workOrderByWithAggregationInput = {
    essn?: SortOrder
    date_work?: SortOrder
    time_start?: SortOrder
    time_end?: SortOrder
    _count?: other_employee_time_workCountOrderByAggregateInput
    _max?: other_employee_time_workMaxOrderByAggregateInput
    _min?: other_employee_time_workMinOrderByAggregateInput
  }

  export type other_employee_time_workScalarWhereWithAggregatesInput = {
    AND?: other_employee_time_workScalarWhereWithAggregatesInput | other_employee_time_workScalarWhereWithAggregatesInput[]
    OR?: other_employee_time_workScalarWhereWithAggregatesInput[]
    NOT?: other_employee_time_workScalarWhereWithAggregatesInput | other_employee_time_workScalarWhereWithAggregatesInput[]
    essn?: StringWithAggregatesFilter<"other_employee_time_work"> | string
    date_work?: Enumother_employee_time_work_date_workWithAggregatesFilter<"other_employee_time_work"> | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeWithAggregatesFilter<"other_employee_time_work"> | Date | string
    time_end?: DateTimeWithAggregatesFilter<"other_employee_time_work"> | Date | string
  }

  export type other_roomWhereInput = {
    AND?: other_roomWhereInput | other_roomWhereInput[]
    OR?: other_roomWhereInput[]
    NOT?: other_roomWhereInput | other_roomWhereInput[]
    building_id?: StringFilter<"other_room"> | string
    room_id?: StringFilter<"other_room"> | string
    room_type?: StringFilter<"other_room"> | string
    num_of_staff?: IntFilter<"other_room"> | number
    start_time?: DateTimeFilter<"other_room"> | Date | string
    end_time?: DateTimeFilter<"other_room"> | Date | string
    other_employee?: Other_employeeListRelationFilter
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
  }

  export type other_roomOrderByWithRelationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_type?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    other_employee?: other_employeeOrderByRelationAggregateInput
    room?: roomOrderByWithRelationInput
    _relevance?: other_roomOrderByRelevanceInput
  }

  export type other_roomWhereUniqueInput = Prisma.AtLeast<{
    building_id_room_id?: other_roomBuilding_idRoom_idCompoundUniqueInput
    AND?: other_roomWhereInput | other_roomWhereInput[]
    OR?: other_roomWhereInput[]
    NOT?: other_roomWhereInput | other_roomWhereInput[]
    building_id?: StringFilter<"other_room"> | string
    room_id?: StringFilter<"other_room"> | string
    room_type?: StringFilter<"other_room"> | string
    num_of_staff?: IntFilter<"other_room"> | number
    start_time?: DateTimeFilter<"other_room"> | Date | string
    end_time?: DateTimeFilter<"other_room"> | Date | string
    other_employee?: Other_employeeListRelationFilter
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
  }, "building_id_room_id">

  export type other_roomOrderByWithAggregationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_type?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    _count?: other_roomCountOrderByAggregateInput
    _avg?: other_roomAvgOrderByAggregateInput
    _max?: other_roomMaxOrderByAggregateInput
    _min?: other_roomMinOrderByAggregateInput
    _sum?: other_roomSumOrderByAggregateInput
  }

  export type other_roomScalarWhereWithAggregatesInput = {
    AND?: other_roomScalarWhereWithAggregatesInput | other_roomScalarWhereWithAggregatesInput[]
    OR?: other_roomScalarWhereWithAggregatesInput[]
    NOT?: other_roomScalarWhereWithAggregatesInput | other_roomScalarWhereWithAggregatesInput[]
    building_id?: StringWithAggregatesFilter<"other_room"> | string
    room_id?: StringWithAggregatesFilter<"other_room"> | string
    room_type?: StringWithAggregatesFilter<"other_room"> | string
    num_of_staff?: IntWithAggregatesFilter<"other_room"> | number
    start_time?: DateTimeWithAggregatesFilter<"other_room"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"other_room"> | Date | string
  }

  export type relativeWhereInput = {
    AND?: relativeWhereInput | relativeWhereInput[]
    OR?: relativeWhereInput[]
    NOT?: relativeWhereInput | relativeWhereInput[]
    Sssn?: StringFilter<"relative"> | string
    fname?: StringFilter<"relative"> | string
    lname?: StringFilter<"relative"> | string
    birthday?: DateTimeFilter<"relative"> | Date | string
    relationship?: StringFilter<"relative"> | string
    address?: StringFilter<"relative"> | string
    phoneNumber?: StringNullableFilter<"relative"> | string | null
    job?: StringNullableFilter<"relative"> | string | null
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }

  export type relativeOrderByWithRelationInput = {
    Sssn?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    birthday?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    student?: studentOrderByWithRelationInput
    _relevance?: relativeOrderByRelevanceInput
  }

  export type relativeWhereUniqueInput = Prisma.AtLeast<{
    Sssn_fname_lname?: relativeSssnFnameLnameCompoundUniqueInput
    AND?: relativeWhereInput | relativeWhereInput[]
    OR?: relativeWhereInput[]
    NOT?: relativeWhereInput | relativeWhereInput[]
    Sssn?: StringFilter<"relative"> | string
    fname?: StringFilter<"relative"> | string
    lname?: StringFilter<"relative"> | string
    birthday?: DateTimeFilter<"relative"> | Date | string
    relationship?: StringFilter<"relative"> | string
    address?: StringFilter<"relative"> | string
    phoneNumber?: StringNullableFilter<"relative"> | string | null
    job?: StringNullableFilter<"relative"> | string | null
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }, "Sssn_fname_lname">

  export type relativeOrderByWithAggregationInput = {
    Sssn?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    birthday?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    _count?: relativeCountOrderByAggregateInput
    _max?: relativeMaxOrderByAggregateInput
    _min?: relativeMinOrderByAggregateInput
  }

  export type relativeScalarWhereWithAggregatesInput = {
    AND?: relativeScalarWhereWithAggregatesInput | relativeScalarWhereWithAggregatesInput[]
    OR?: relativeScalarWhereWithAggregatesInput[]
    NOT?: relativeScalarWhereWithAggregatesInput | relativeScalarWhereWithAggregatesInput[]
    Sssn?: StringWithAggregatesFilter<"relative"> | string
    fname?: StringWithAggregatesFilter<"relative"> | string
    lname?: StringWithAggregatesFilter<"relative"> | string
    birthday?: DateTimeWithAggregatesFilter<"relative"> | Date | string
    relationship?: StringWithAggregatesFilter<"relative"> | string
    address?: StringWithAggregatesFilter<"relative"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"relative"> | string | null
    job?: StringNullableWithAggregatesFilter<"relative"> | string | null
  }

  export type roomWhereInput = {
    AND?: roomWhereInput | roomWhereInput[]
    OR?: roomWhereInput[]
    NOT?: roomWhereInput | roomWhereInput[]
    building_id?: StringFilter<"room"> | string
    room_id?: StringFilter<"room"> | string
    room_status?: Enumroom_room_statusFilter<"room"> | $Enums.room_room_status
    room_area?: DecimalFilter<"room"> | Decimal | DecimalJsLike | number | string
    health_room?: XOR<Health_roomNullableScalarRelationFilter, health_roomWhereInput> | null
    management_room?: XOR<Management_roomNullableScalarRelationFilter, management_roomWhereInput> | null
    other_room?: XOR<Other_roomNullableScalarRelationFilter, other_roomWhereInput> | null
    building?: XOR<BuildingScalarRelationFilter, buildingWhereInput>
  }

  export type roomOrderByWithRelationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_status?: SortOrder
    room_area?: SortOrder
    health_room?: health_roomOrderByWithRelationInput
    management_room?: management_roomOrderByWithRelationInput
    other_room?: other_roomOrderByWithRelationInput
    building?: buildingOrderByWithRelationInput
    _relevance?: roomOrderByRelevanceInput
  }

  export type roomWhereUniqueInput = Prisma.AtLeast<{
    building_id_room_id?: roomBuilding_idRoom_idCompoundUniqueInput
    AND?: roomWhereInput | roomWhereInput[]
    OR?: roomWhereInput[]
    NOT?: roomWhereInput | roomWhereInput[]
    building_id?: StringFilter<"room"> | string
    room_id?: StringFilter<"room"> | string
    room_status?: Enumroom_room_statusFilter<"room"> | $Enums.room_room_status
    room_area?: DecimalFilter<"room"> | Decimal | DecimalJsLike | number | string
    health_room?: XOR<Health_roomNullableScalarRelationFilter, health_roomWhereInput> | null
    management_room?: XOR<Management_roomNullableScalarRelationFilter, management_roomWhereInput> | null
    other_room?: XOR<Other_roomNullableScalarRelationFilter, other_roomWhereInput> | null
    building?: XOR<BuildingScalarRelationFilter, buildingWhereInput>
  }, "building_id_room_id">

  export type roomOrderByWithAggregationInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_status?: SortOrder
    room_area?: SortOrder
    _count?: roomCountOrderByAggregateInput
    _avg?: roomAvgOrderByAggregateInput
    _max?: roomMaxOrderByAggregateInput
    _min?: roomMinOrderByAggregateInput
    _sum?: roomSumOrderByAggregateInput
  }

  export type roomScalarWhereWithAggregatesInput = {
    AND?: roomScalarWhereWithAggregatesInput | roomScalarWhereWithAggregatesInput[]
    OR?: roomScalarWhereWithAggregatesInput[]
    NOT?: roomScalarWhereWithAggregatesInput | roomScalarWhereWithAggregatesInput[]
    building_id?: StringWithAggregatesFilter<"room"> | string
    room_id?: StringWithAggregatesFilter<"room"> | string
    room_status?: Enumroom_room_statusWithAggregatesFilter<"room"> | $Enums.room_room_status
    room_area?: DecimalWithAggregatesFilter<"room"> | Decimal | DecimalJsLike | number | string
  }

  export type studentWhereInput = {
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    Sssn?: StringFilter<"student"> | string
    studentId?: StringFilter<"student"> | string
    hasHealthInsurance?: BoolFilter<"student"> | boolean
    studyStatus?: StringNullableFilter<"student"> | string | null
    className?: StringNullableFilter<"student"> | string | null
    faculty?: StringNullableFilter<"student"> | string | null
    building_id?: StringNullableFilter<"student"> | string | null
    room_id?: StringNullableFilter<"student"> | string | null
    Dormitory_Card?: Dormitory_CardListRelationFilter
    relative?: RelativeListRelationFilter
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
    living_room?: XOR<Living_roomNullableScalarRelationFilter, living_roomWhereInput> | null
    studentDiscipline?: StudentDisciplineListRelationFilter
  }

  export type studentOrderByWithRelationInput = {
    Sssn?: SortOrder
    studentId?: SortOrder
    hasHealthInsurance?: SortOrder
    studyStatus?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    faculty?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    room_id?: SortOrderInput | SortOrder
    Dormitory_Card?: Dormitory_CardOrderByRelationAggregateInput
    relative?: relativeOrderByRelationAggregateInput
    People?: PeopleOrderByWithRelationInput
    living_room?: living_roomOrderByWithRelationInput
    studentDiscipline?: studentDisciplineOrderByRelationAggregateInput
    _relevance?: studentOrderByRelevanceInput
  }

  export type studentWhereUniqueInput = Prisma.AtLeast<{
    Sssn?: string
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    studentId?: StringFilter<"student"> | string
    hasHealthInsurance?: BoolFilter<"student"> | boolean
    studyStatus?: StringNullableFilter<"student"> | string | null
    className?: StringNullableFilter<"student"> | string | null
    faculty?: StringNullableFilter<"student"> | string | null
    building_id?: StringNullableFilter<"student"> | string | null
    room_id?: StringNullableFilter<"student"> | string | null
    Dormitory_Card?: Dormitory_CardListRelationFilter
    relative?: RelativeListRelationFilter
    People?: XOR<PeopleScalarRelationFilter, PeopleWhereInput>
    living_room?: XOR<Living_roomNullableScalarRelationFilter, living_roomWhereInput> | null
    studentDiscipline?: StudentDisciplineListRelationFilter
  }, "Sssn">

  export type studentOrderByWithAggregationInput = {
    Sssn?: SortOrder
    studentId?: SortOrder
    hasHealthInsurance?: SortOrder
    studyStatus?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    faculty?: SortOrderInput | SortOrder
    building_id?: SortOrderInput | SortOrder
    room_id?: SortOrderInput | SortOrder
    _count?: studentCountOrderByAggregateInput
    _max?: studentMaxOrderByAggregateInput
    _min?: studentMinOrderByAggregateInput
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    OR?: studentScalarWhereWithAggregatesInput[]
    NOT?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    Sssn?: StringWithAggregatesFilter<"student"> | string
    studentId?: StringWithAggregatesFilter<"student"> | string
    hasHealthInsurance?: BoolWithAggregatesFilter<"student"> | boolean
    studyStatus?: StringNullableWithAggregatesFilter<"student"> | string | null
    className?: StringNullableWithAggregatesFilter<"student"> | string | null
    faculty?: StringNullableWithAggregatesFilter<"student"> | string | null
    building_id?: StringNullableWithAggregatesFilter<"student"> | string | null
    room_id?: StringNullableWithAggregatesFilter<"student"> | string | null
  }

  export type studentDisciplineWhereInput = {
    AND?: studentDisciplineWhereInput | studentDisciplineWhereInput[]
    OR?: studentDisciplineWhereInput[]
    NOT?: studentDisciplineWhereInput | studentDisciplineWhereInput[]
    actionId?: StringFilter<"studentDiscipline"> | string
    Sssn?: StringFilter<"studentDiscipline"> | string
    disciplinaryAction?: XOR<DisciplinaryActionScalarRelationFilter, disciplinaryActionWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }

  export type studentDisciplineOrderByWithRelationInput = {
    actionId?: SortOrder
    Sssn?: SortOrder
    disciplinaryAction?: disciplinaryActionOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
    _relevance?: studentDisciplineOrderByRelevanceInput
  }

  export type studentDisciplineWhereUniqueInput = Prisma.AtLeast<{
    actionId_Sssn?: studentDisciplineActionIdSssnCompoundUniqueInput
    AND?: studentDisciplineWhereInput | studentDisciplineWhereInput[]
    OR?: studentDisciplineWhereInput[]
    NOT?: studentDisciplineWhereInput | studentDisciplineWhereInput[]
    actionId?: StringFilter<"studentDiscipline"> | string
    Sssn?: StringFilter<"studentDiscipline"> | string
    disciplinaryAction?: XOR<DisciplinaryActionScalarRelationFilter, disciplinaryActionWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }, "actionId_Sssn">

  export type studentDisciplineOrderByWithAggregationInput = {
    actionId?: SortOrder
    Sssn?: SortOrder
    _count?: studentDisciplineCountOrderByAggregateInput
    _max?: studentDisciplineMaxOrderByAggregateInput
    _min?: studentDisciplineMinOrderByAggregateInput
  }

  export type studentDisciplineScalarWhereWithAggregatesInput = {
    AND?: studentDisciplineScalarWhereWithAggregatesInput | studentDisciplineScalarWhereWithAggregatesInput[]
    OR?: studentDisciplineScalarWhereWithAggregatesInput[]
    NOT?: studentDisciplineScalarWhereWithAggregatesInput | studentDisciplineScalarWhereWithAggregatesInput[]
    actionId?: StringWithAggregatesFilter<"studentDiscipline"> | string
    Sssn?: StringWithAggregatesFilter<"studentDiscipline"> | string
  }

  export type AddressCreateInput = {
    commune: string
    district: string
    province: string
    People: PeopleCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    ssn: string
    commune: string
    district: string
    province: string
  }

  export type AddressUpdateInput = {
    commune?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    People?: PeopleUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    ssn?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyInput = {
    ssn: string
    commune: string
    district: string
    province: string
  }

  export type AddressUpdateManyMutationInput = {
    commune?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    ssn?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
  }

  export type Dormitory_CardCreateInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Validity?: boolean | null
    Identity_Card: Identity_CardCreateNestedOneWithoutDormitory_CardInput
    student: studentCreateNestedOneWithoutDormitory_CardInput
  }

  export type Dormitory_CardUncheckedCreateInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    ID_Card: string
    Validity?: boolean | null
  }

  export type Dormitory_CardUpdateInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Identity_Card?: Identity_CardUpdateOneRequiredWithoutDormitory_CardNestedInput
    student?: studentUpdateOneRequiredWithoutDormitory_CardNestedInput
  }

  export type Dormitory_CardUncheckedUpdateInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ID_Card?: StringFieldUpdateOperationsInput | string
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type Dormitory_CardCreateManyInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    ID_Card: string
    Validity?: boolean | null
  }

  export type Dormitory_CardUpdateManyMutationInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type Dormitory_CardUncheckedUpdateManyInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ID_Card?: StringFieldUpdateOperationsInput | string
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EmailCreateInput = {
    email: string
    People: PeopleCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateInput = {
    ssn: string
    email: string
  }

  export type EmailUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    People?: PeopleUpdateOneRequiredWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateInput = {
    ssn?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCreateManyInput = {
    ssn: string
    email: string
  }

  export type EmailUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type EmailUncheckedUpdateManyInput = {
    ssn?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type Employee_CardCreateInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Employee_Type?: string | null
    Identity_Card: Identity_CardCreateNestedOneWithoutEmployee_CardInput
    employee: employeeCreateNestedOneWithoutEmployee_CardInput
  }

  export type Employee_CardUncheckedCreateInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    ID_Card: string
    Employee_Type?: string | null
  }

  export type Employee_CardUpdateInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
    Identity_Card?: Identity_CardUpdateOneRequiredWithoutEmployee_CardNestedInput
    employee?: employeeUpdateOneRequiredWithoutEmployee_CardNestedInput
  }

  export type Employee_CardUncheckedUpdateInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ID_Card?: StringFieldUpdateOperationsInput | string
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Employee_CardCreateManyInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    ID_Card: string
    Employee_Type?: string | null
  }

  export type Employee_CardUpdateManyMutationInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Employee_CardUncheckedUpdateManyInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ID_Card?: StringFieldUpdateOperationsInput | string
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Identity_CardCreateInput = {
    ID: string
    Issued_Date: Date | string
    Dormitory_Card?: Dormitory_CardCreateNestedOneWithoutIdentity_CardInput
    Employee_Card?: Employee_CardCreateNestedOneWithoutIdentity_CardInput
  }

  export type Identity_CardUncheckedCreateInput = {
    ID: string
    Issued_Date: Date | string
    Dormitory_Card?: Dormitory_CardUncheckedCreateNestedOneWithoutIdentity_CardInput
    Employee_Card?: Employee_CardUncheckedCreateNestedOneWithoutIdentity_CardInput
  }

  export type Identity_CardUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Dormitory_Card?: Dormitory_CardUpdateOneWithoutIdentity_CardNestedInput
    Employee_Card?: Employee_CardUpdateOneWithoutIdentity_CardNestedInput
  }

  export type Identity_CardUncheckedUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Dormitory_Card?: Dormitory_CardUncheckedUpdateOneWithoutIdentity_CardNestedInput
    Employee_Card?: Employee_CardUncheckedUpdateOneWithoutIdentity_CardNestedInput
  }

  export type Identity_CardCreateManyInput = {
    ID: string
    Issued_Date: Date | string
  }

  export type Identity_CardUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Identity_CardUncheckedUpdateManyInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeopleCreateInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressCreateNestedManyWithoutPeopleInput
    Email?: EmailCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberCreateNestedManyWithoutPeopleInput
    employee?: employeeCreateNestedOneWithoutPeopleInput
    student?: studentCreateNestedOneWithoutPeopleInput
  }

  export type PeopleUncheckedCreateInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressUncheckedCreateNestedManyWithoutPeopleInput
    Email?: EmailUncheckedCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberUncheckedCreateNestedManyWithoutPeopleInput
    employee?: employeeUncheckedCreateNestedOneWithoutPeopleInput
    student?: studentUncheckedCreateNestedOneWithoutPeopleInput
  }

  export type PeopleUpdateInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUpdateManyWithoutPeopleNestedInput
    Email?: EmailUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUpdateManyWithoutPeopleNestedInput
    employee?: employeeUpdateOneWithoutPeopleNestedInput
    student?: studentUpdateOneWithoutPeopleNestedInput
  }

  export type PeopleUncheckedUpdateInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateManyWithoutPeopleNestedInput
    Email?: EmailUncheckedUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUncheckedUpdateManyWithoutPeopleNestedInput
    employee?: employeeUncheckedUpdateOneWithoutPeopleNestedInput
    student?: studentUncheckedUpdateOneWithoutPeopleNestedInput
  }

  export type PeopleCreateManyInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
  }

  export type PeopleUpdateManyMutationInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeopleUncheckedUpdateManyInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhoneNumberCreateInput = {
    phoneNumber: string
    People: PeopleCreateNestedOneWithoutPhoneNumberInput
  }

  export type PhoneNumberUncheckedCreateInput = {
    ssn: string
    phoneNumber: string
  }

  export type PhoneNumberUpdateInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    People?: PeopleUpdateOneRequiredWithoutPhoneNumberNestedInput
  }

  export type PhoneNumberUncheckedUpdateInput = {
    ssn?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneNumberCreateManyInput = {
    ssn: string
    phoneNumber: string
  }

  export type PhoneNumberUpdateManyMutationInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneNumberUncheckedUpdateManyInput = {
    ssn?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type buildingCreateInput = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor?: string | null
    construction_date: Date | string
    last_renovation?: Date | string | null
    building_equipment?: building_equipmentCreateNestedManyWithoutBuildingInput
    room?: roomCreateNestedManyWithoutBuildingInput
  }

  export type buildingUncheckedCreateInput = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor?: string | null
    construction_date: Date | string
    last_renovation?: Date | string | null
    building_equipment?: building_equipmentUncheckedCreateNestedManyWithoutBuildingInput
    room?: roomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type buildingUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    building_equipment?: building_equipmentUpdateManyWithoutBuildingNestedInput
    room?: roomUpdateManyWithoutBuildingNestedInput
  }

  export type buildingUncheckedUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    building_equipment?: building_equipmentUncheckedUpdateManyWithoutBuildingNestedInput
    room?: roomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type buildingCreateManyInput = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor?: string | null
    construction_date: Date | string
    last_renovation?: Date | string | null
  }

  export type buildingUpdateManyMutationInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type buildingUncheckedUpdateManyInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type building_equipmentCreateInput = {
    quantity: number
    building: buildingCreateNestedOneWithoutBuilding_equipmentInput
    large_equipment: large_equipmentCreateNestedOneWithoutBuilding_equipmentInput
  }

  export type building_equipmentUncheckedCreateInput = {
    building_id: string
    equipment_id: string
    quantity: number
  }

  export type building_equipmentUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    building?: buildingUpdateOneRequiredWithoutBuilding_equipmentNestedInput
    large_equipment?: large_equipmentUpdateOneRequiredWithoutBuilding_equipmentNestedInput
  }

  export type building_equipmentUncheckedUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    equipment_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type building_equipmentCreateManyInput = {
    building_id: string
    equipment_id: string
    quantity: number
  }

  export type building_equipmentUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type building_equipmentUncheckedUpdateManyInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    equipment_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type disciplinaryActionCreateInput = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date | string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    severityLevel?: string | null
    status?: string | null
    disciplineStaff?: disciplineStaffCreateNestedManyWithoutDisciplinaryActionInput
    studentDiscipline?: studentDisciplineCreateNestedManyWithoutDisciplinaryActionInput
  }

  export type disciplinaryActionUncheckedCreateInput = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date | string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    severityLevel?: string | null
    status?: string | null
    disciplineStaff?: disciplineStaffUncheckedCreateNestedManyWithoutDisciplinaryActionInput
    studentDiscipline?: studentDisciplineUncheckedCreateNestedManyWithoutDisciplinaryActionInput
  }

  export type disciplinaryActionUpdateInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    disciplineStaff?: disciplineStaffUpdateManyWithoutDisciplinaryActionNestedInput
    studentDiscipline?: studentDisciplineUpdateManyWithoutDisciplinaryActionNestedInput
  }

  export type disciplinaryActionUncheckedUpdateInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    disciplineStaff?: disciplineStaffUncheckedUpdateManyWithoutDisciplinaryActionNestedInput
    studentDiscipline?: studentDisciplineUncheckedUpdateManyWithoutDisciplinaryActionNestedInput
  }

  export type disciplinaryActionCreateManyInput = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date | string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    severityLevel?: string | null
    status?: string | null
  }

  export type disciplinaryActionUpdateManyMutationInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type disciplinaryActionUncheckedUpdateManyInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type disciplineStaffCreateInput = {
    disciplinaryAction: disciplinaryActionCreateNestedOneWithoutDisciplineStaffInput
    manager_employee: manager_employeeCreateNestedOneWithoutDisciplineStaffInput
  }

  export type disciplineStaffUncheckedCreateInput = {
    actionId: string
    essn: string
  }

  export type disciplineStaffUpdateInput = {
    disciplinaryAction?: disciplinaryActionUpdateOneRequiredWithoutDisciplineStaffNestedInput
    manager_employee?: manager_employeeUpdateOneRequiredWithoutDisciplineStaffNestedInput
  }

  export type disciplineStaffUncheckedUpdateInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    essn?: StringFieldUpdateOperationsInput | string
  }

  export type disciplineStaffCreateManyInput = {
    actionId: string
    essn: string
  }

  export type disciplineStaffUpdateManyMutationInput = {

  }

  export type disciplineStaffUncheckedUpdateManyInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    essn?: StringFieldUpdateOperationsInput | string
  }

  export type employeeCreateInput = {
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardCreateNestedManyWithoutEmployeeInput
    People: PeopleCreateNestedOneWithoutEmployeeInput
    manager_employee?: manager_employeeCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUncheckedCreateInput = {
    essn: string
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardUncheckedCreateNestedManyWithoutEmployeeInput
    manager_employee?: manager_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUpdateInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUpdateManyWithoutEmployeeNestedInput
    People?: PeopleUpdateOneRequiredWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUpdateOneWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateInput = {
    essn?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUncheckedUpdateManyWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type employeeCreateManyInput = {
    essn: string
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
  }

  export type employeeUpdateManyMutationInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeUncheckedUpdateManyInput = {
    essn?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type health_roomCreateInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    equipment_status: $Enums.health_room_equipment_status
    room: roomCreateNestedOneWithoutHealth_roomInput
    medical_employee?: medical_employeeCreateNestedManyWithoutHealth_roomInput
  }

  export type health_roomUncheckedCreateInput = {
    building_id: string
    room_id: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    equipment_status: $Enums.health_room_equipment_status
    medical_employee?: medical_employeeUncheckedCreateNestedManyWithoutHealth_roomInput
  }

  export type health_roomUpdateInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
    room?: roomUpdateOneRequiredWithoutHealth_roomNestedInput
    medical_employee?: medical_employeeUpdateManyWithoutHealth_roomNestedInput
  }

  export type health_roomUncheckedUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
    medical_employee?: medical_employeeUncheckedUpdateManyWithoutHealth_roomNestedInput
  }

  export type health_roomCreateManyInput = {
    building_id: string
    room_id: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    equipment_status: $Enums.health_room_equipment_status
  }

  export type health_roomUpdateManyMutationInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
  }

  export type health_roomUncheckedUpdateManyInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
  }

  export type large_equipmentCreateInput = {
    equipment_id: string
    equipment_name: string
    equipment_type: string
    equipment_status: $Enums.large_equipment_equipment_status
    purchase_date: Date | string
    purchase_location?: string | null
    building_equipment?: building_equipmentCreateNestedManyWithoutLarge_equipmentInput
  }

  export type large_equipmentUncheckedCreateInput = {
    equipment_id: string
    equipment_name: string
    equipment_type: string
    equipment_status: $Enums.large_equipment_equipment_status
    purchase_date: Date | string
    purchase_location?: string | null
    building_equipment?: building_equipmentUncheckedCreateNestedManyWithoutLarge_equipmentInput
  }

  export type large_equipmentUpdateInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    equipment_name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    equipment_status?: Enumlarge_equipment_equipment_statusFieldUpdateOperationsInput | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_location?: NullableStringFieldUpdateOperationsInput | string | null
    building_equipment?: building_equipmentUpdateManyWithoutLarge_equipmentNestedInput
  }

  export type large_equipmentUncheckedUpdateInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    equipment_name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    equipment_status?: Enumlarge_equipment_equipment_statusFieldUpdateOperationsInput | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_location?: NullableStringFieldUpdateOperationsInput | string | null
    building_equipment?: building_equipmentUncheckedUpdateManyWithoutLarge_equipmentNestedInput
  }

  export type large_equipmentCreateManyInput = {
    equipment_id: string
    equipment_name: string
    equipment_type: string
    equipment_status: $Enums.large_equipment_equipment_status
    purchase_date: Date | string
    purchase_location?: string | null
  }

  export type large_equipmentUpdateManyMutationInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    equipment_name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    equipment_status?: Enumlarge_equipment_equipment_statusFieldUpdateOperationsInput | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type large_equipmentUncheckedUpdateManyInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    equipment_name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    equipment_status?: Enumlarge_equipment_equipment_statusFieldUpdateOperationsInput | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type living_roomCreateInput = {
    building_id: string
    room_id: string
    max_num_of_students: number
    current_num_of_students?: number
    rental_price: Decimal | DecimalJsLike | number | string
    occupancy_rate?: Decimal | DecimalJsLike | number | string
    student?: studentCreateNestedManyWithoutLiving_roomInput
  }

  export type living_roomUncheckedCreateInput = {
    building_id: string
    room_id: string
    max_num_of_students: number
    current_num_of_students?: number
    rental_price: Decimal | DecimalJsLike | number | string
    occupancy_rate?: Decimal | DecimalJsLike | number | string
    student?: studentUncheckedCreateNestedManyWithoutLiving_roomInput
  }

  export type living_roomUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    max_num_of_students?: IntFieldUpdateOperationsInput | number
    current_num_of_students?: IntFieldUpdateOperationsInput | number
    rental_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    student?: studentUpdateManyWithoutLiving_roomNestedInput
  }

  export type living_roomUncheckedUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    max_num_of_students?: IntFieldUpdateOperationsInput | number
    current_num_of_students?: IntFieldUpdateOperationsInput | number
    rental_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    student?: studentUncheckedUpdateManyWithoutLiving_roomNestedInput
  }

  export type living_roomCreateManyInput = {
    building_id: string
    room_id: string
    max_num_of_students: number
    current_num_of_students?: number
    rental_price: Decimal | DecimalJsLike | number | string
    occupancy_rate?: Decimal | DecimalJsLike | number | string
  }

  export type living_roomUpdateManyMutationInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    max_num_of_students?: IntFieldUpdateOperationsInput | number
    current_num_of_students?: IntFieldUpdateOperationsInput | number
    rental_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type living_roomUncheckedUpdateManyInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    max_num_of_students?: IntFieldUpdateOperationsInput | number
    current_num_of_students?: IntFieldUpdateOperationsInput | number
    rental_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type management_roomCreateInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    room: roomCreateNestedOneWithoutManagement_roomInput
    manager_employee?: manager_employeeCreateNestedManyWithoutManagement_roomInput
  }

  export type management_roomUncheckedCreateInput = {
    building_id: string
    room_id: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    manager_employee?: manager_employeeUncheckedCreateNestedManyWithoutManagement_roomInput
  }

  export type management_roomUpdateInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: roomUpdateOneRequiredWithoutManagement_roomNestedInput
    manager_employee?: manager_employeeUpdateManyWithoutManagement_roomNestedInput
  }

  export type management_roomUncheckedUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    manager_employee?: manager_employeeUncheckedUpdateManyWithoutManagement_roomNestedInput
  }

  export type management_roomCreateManyInput = {
    building_id: string
    room_id: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
  }

  export type management_roomUpdateManyMutationInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type management_roomUncheckedUpdateManyInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type managerDormCreateInput = {
    user_name: string
    password: string
  }

  export type managerDormUncheckedCreateInput = {
    user_name: string
    password: string
  }

  export type managerDormUpdateInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type managerDormUncheckedUpdateInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type managerDormCreateManyInput = {
    user_name: string
    password: string
  }

  export type managerDormUpdateManyMutationInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type managerDormUncheckedUpdateManyInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type manager_degreeCreateInput = {
    degree: string
    manager_employee: manager_employeeCreateNestedOneWithoutManager_degreeInput
  }

  export type manager_degreeUncheckedCreateInput = {
    essn: string
    degree: string
  }

  export type manager_degreeUpdateInput = {
    degree?: StringFieldUpdateOperationsInput | string
    manager_employee?: manager_employeeUpdateOneRequiredWithoutManager_degreeNestedInput
  }

  export type manager_degreeUncheckedUpdateInput = {
    essn?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type manager_degreeCreateManyInput = {
    essn: string
    degree: string
  }

  export type manager_degreeUpdateManyMutationInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type manager_degreeUncheckedUpdateManyInput = {
    essn?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type manager_employeeCreateInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffCreateNestedManyWithoutManager_employeeInput
    manager_degree?: manager_degreeCreateNestedManyWithoutManager_employeeInput
    management_room?: management_roomCreateNestedOneWithoutManager_employeeInput
    employee: employeeCreateNestedOneWithoutManager_employeeInput
  }

  export type manager_employeeUncheckedCreateInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedCreateNestedManyWithoutManager_employeeInput
    manager_degree?: manager_degreeUncheckedCreateNestedManyWithoutManager_employeeInput
  }

  export type manager_employeeUpdateInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUpdateManyWithoutManager_employeeNestedInput
    manager_degree?: manager_degreeUpdateManyWithoutManager_employeeNestedInput
    management_room?: management_roomUpdateOneWithoutManager_employeeNestedInput
    employee?: employeeUpdateOneRequiredWithoutManager_employeeNestedInput
  }

  export type manager_employeeUncheckedUpdateInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedUpdateManyWithoutManager_employeeNestedInput
    manager_degree?: manager_degreeUncheckedUpdateManyWithoutManager_employeeNestedInput
  }

  export type manager_employeeCreateManyInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
  }

  export type manager_employeeUpdateManyMutationInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type manager_employeeUncheckedUpdateManyInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type medical_degreeCreateInput = {
    degree: string
    medical_employee: medical_employeeCreateNestedOneWithoutMedical_degreeInput
  }

  export type medical_degreeUncheckedCreateInput = {
    essn: string
    degree: string
  }

  export type medical_degreeUpdateInput = {
    degree?: StringFieldUpdateOperationsInput | string
    medical_employee?: medical_employeeUpdateOneRequiredWithoutMedical_degreeNestedInput
  }

  export type medical_degreeUncheckedUpdateInput = {
    essn?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type medical_degreeCreateManyInput = {
    essn: string
    degree: string
  }

  export type medical_degreeUpdateManyMutationInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type medical_degreeUncheckedUpdateManyInput = {
    essn?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type medical_employeeCreateInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeCreateNestedManyWithoutMedical_employeeInput
    employee: employeeCreateNestedOneWithoutMedical_employeeInput
    health_room?: health_roomCreateNestedOneWithoutMedical_employeeInput
  }

  export type medical_employeeUncheckedCreateInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUncheckedCreateNestedManyWithoutMedical_employeeInput
  }

  export type medical_employeeUpdateInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUpdateManyWithoutMedical_employeeNestedInput
    employee?: employeeUpdateOneRequiredWithoutMedical_employeeNestedInput
    health_room?: health_roomUpdateOneWithoutMedical_employeeNestedInput
  }

  export type medical_employeeUncheckedUpdateInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUncheckedUpdateManyWithoutMedical_employeeNestedInput
  }

  export type medical_employeeCreateManyInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
  }

  export type medical_employeeUpdateManyMutationInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type medical_employeeUncheckedUpdateManyInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type other_employeeCreateInput = {
    typeWork?: string | null
    employee: employeeCreateNestedOneWithoutOther_employeeInput
    other_room?: other_roomCreateNestedOneWithoutOther_employeeInput
    other_employee_time_work?: other_employee_time_workCreateNestedManyWithoutOther_employeeInput
  }

  export type other_employeeUncheckedCreateInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    typeWork?: string | null
    other_employee_time_work?: other_employee_time_workUncheckedCreateNestedManyWithoutOther_employeeInput
  }

  export type other_employeeUpdateInput = {
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: employeeUpdateOneRequiredWithoutOther_employeeNestedInput
    other_room?: other_roomUpdateOneWithoutOther_employeeNestedInput
    other_employee_time_work?: other_employee_time_workUpdateManyWithoutOther_employeeNestedInput
  }

  export type other_employeeUncheckedUpdateInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
    other_employee_time_work?: other_employee_time_workUncheckedUpdateManyWithoutOther_employeeNestedInput
  }

  export type other_employeeCreateManyInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    typeWork?: string | null
  }

  export type other_employeeUpdateManyMutationInput = {
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type other_employeeUncheckedUpdateManyInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type other_employee_time_workCreateInput = {
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date | string
    time_end: Date | string
    other_employee: other_employeeCreateNestedOneWithoutOther_employee_time_workInput
  }

  export type other_employee_time_workUncheckedCreateInput = {
    essn: string
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date | string
    time_end: Date | string
  }

  export type other_employee_time_workUpdateInput = {
    date_work?: Enumother_employee_time_work_date_workFieldUpdateOperationsInput | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFieldUpdateOperationsInput | Date | string
    time_end?: DateTimeFieldUpdateOperationsInput | Date | string
    other_employee?: other_employeeUpdateOneRequiredWithoutOther_employee_time_workNestedInput
  }

  export type other_employee_time_workUncheckedUpdateInput = {
    essn?: StringFieldUpdateOperationsInput | string
    date_work?: Enumother_employee_time_work_date_workFieldUpdateOperationsInput | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFieldUpdateOperationsInput | Date | string
    time_end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_employee_time_workCreateManyInput = {
    essn: string
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date | string
    time_end: Date | string
  }

  export type other_employee_time_workUpdateManyMutationInput = {
    date_work?: Enumother_employee_time_work_date_workFieldUpdateOperationsInput | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFieldUpdateOperationsInput | Date | string
    time_end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_employee_time_workUncheckedUpdateManyInput = {
    essn?: StringFieldUpdateOperationsInput | string
    date_work?: Enumother_employee_time_work_date_workFieldUpdateOperationsInput | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFieldUpdateOperationsInput | Date | string
    time_end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_roomCreateInput = {
    room_type: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    other_employee?: other_employeeCreateNestedManyWithoutOther_roomInput
    room: roomCreateNestedOneWithoutOther_roomInput
  }

  export type other_roomUncheckedCreateInput = {
    building_id: string
    room_id: string
    room_type: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    other_employee?: other_employeeUncheckedCreateNestedManyWithoutOther_roomInput
  }

  export type other_roomUpdateInput = {
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    other_employee?: other_employeeUpdateManyWithoutOther_roomNestedInput
    room?: roomUpdateOneRequiredWithoutOther_roomNestedInput
  }

  export type other_roomUncheckedUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    other_employee?: other_employeeUncheckedUpdateManyWithoutOther_roomNestedInput
  }

  export type other_roomCreateManyInput = {
    building_id: string
    room_id: string
    room_type: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
  }

  export type other_roomUpdateManyMutationInput = {
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_roomUncheckedUpdateManyInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type relativeCreateInput = {
    fname: string
    lname: string
    birthday: Date | string
    relationship: string
    address: string
    phoneNumber?: string | null
    job?: string | null
    student: studentCreateNestedOneWithoutRelativeInput
  }

  export type relativeUncheckedCreateInput = {
    Sssn: string
    fname: string
    lname: string
    birthday: Date | string
    relationship: string
    address: string
    phoneNumber?: string | null
    job?: string | null
  }

  export type relativeUpdateInput = {
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
    student?: studentUpdateOneRequiredWithoutRelativeNestedInput
  }

  export type relativeUncheckedUpdateInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type relativeCreateManyInput = {
    Sssn: string
    fname: string
    lname: string
    birthday: Date | string
    relationship: string
    address: string
    phoneNumber?: string | null
    job?: string | null
  }

  export type relativeUpdateManyMutationInput = {
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type relativeUncheckedUpdateManyInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roomCreateInput = {
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomCreateNestedOneWithoutRoomInput
    management_room?: management_roomCreateNestedOneWithoutRoomInput
    other_room?: other_roomCreateNestedOneWithoutRoomInput
    building: buildingCreateNestedOneWithoutRoomInput
  }

  export type roomUncheckedCreateInput = {
    building_id: string
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedCreateNestedOneWithoutRoomInput
    management_room?: management_roomUncheckedCreateNestedOneWithoutRoomInput
    other_room?: other_roomUncheckedCreateNestedOneWithoutRoomInput
  }

  export type roomUpdateInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUpdateOneWithoutRoomNestedInput
    management_room?: management_roomUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUpdateOneWithoutRoomNestedInput
    building?: buildingUpdateOneRequiredWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedUpdateOneWithoutRoomNestedInput
    management_room?: management_roomUncheckedUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUncheckedUpdateOneWithoutRoomNestedInput
  }

  export type roomCreateManyInput = {
    building_id: string
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
  }

  export type roomUpdateManyMutationInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type roomUncheckedUpdateManyInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type studentCreateInput = {
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    Dormitory_Card?: Dormitory_CardCreateNestedManyWithoutStudentInput
    relative?: relativeCreateNestedManyWithoutStudentInput
    People: PeopleCreateNestedOneWithoutStudentInput
    living_room?: living_roomCreateNestedOneWithoutStudentInput
    studentDiscipline?: studentDisciplineCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateInput = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    building_id?: string | null
    room_id?: string | null
    Dormitory_Card?: Dormitory_CardUncheckedCreateNestedManyWithoutStudentInput
    relative?: relativeUncheckedCreateNestedManyWithoutStudentInput
    studentDiscipline?: studentDisciplineUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUpdateManyWithoutStudentNestedInput
    relative?: relativeUpdateManyWithoutStudentNestedInput
    People?: PeopleUpdateOneRequiredWithoutStudentNestedInput
    living_room?: living_roomUpdateOneWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUncheckedUpdateManyWithoutStudentNestedInput
    relative?: relativeUncheckedUpdateManyWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentCreateManyInput = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    building_id?: string | null
    room_id?: string | null
  }

  export type studentUpdateManyMutationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentUncheckedUpdateManyInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentDisciplineCreateInput = {
    disciplinaryAction: disciplinaryActionCreateNestedOneWithoutStudentDisciplineInput
    student: studentCreateNestedOneWithoutStudentDisciplineInput
  }

  export type studentDisciplineUncheckedCreateInput = {
    actionId: string
    Sssn: string
  }

  export type studentDisciplineUpdateInput = {
    disciplinaryAction?: disciplinaryActionUpdateOneRequiredWithoutStudentDisciplineNestedInput
    student?: studentUpdateOneRequiredWithoutStudentDisciplineNestedInput
  }

  export type studentDisciplineUncheckedUpdateInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    Sssn?: StringFieldUpdateOperationsInput | string
  }

  export type studentDisciplineCreateManyInput = {
    actionId: string
    Sssn: string
  }

  export type studentDisciplineUpdateManyMutationInput = {

  }

  export type studentDisciplineUncheckedUpdateManyInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    Sssn?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PeopleScalarRelationFilter = {
    is?: PeopleWhereInput
    isNot?: PeopleWhereInput
  }

  export type AddressOrderByRelevanceInput = {
    fields: AddressOrderByRelevanceFieldEnum | AddressOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddressSsnCommuneDistrictProvinceCompoundUniqueInput = {
    ssn: string
    commune: string
    district: string
    province: string
  }

  export type AddressCountOrderByAggregateInput = {
    ssn?: SortOrder
    commune?: SortOrder
    district?: SortOrder
    province?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    ssn?: SortOrder
    commune?: SortOrder
    district?: SortOrder
    province?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    ssn?: SortOrder
    commune?: SortOrder
    district?: SortOrder
    province?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Identity_CardScalarRelationFilter = {
    is?: Identity_CardWhereInput
    isNot?: Identity_CardWhereInput
  }

  export type StudentScalarRelationFilter = {
    is?: studentWhereInput
    isNot?: studentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Dormitory_CardOrderByRelevanceInput = {
    fields: Dormitory_CardOrderByRelevanceFieldEnum | Dormitory_CardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Dormitory_CardCountOrderByAggregateInput = {
    Number?: SortOrder
    Start_Date?: SortOrder
    End_Date?: SortOrder
    ID_Card?: SortOrder
    Validity?: SortOrder
  }

  export type Dormitory_CardMaxOrderByAggregateInput = {
    Number?: SortOrder
    Start_Date?: SortOrder
    End_Date?: SortOrder
    ID_Card?: SortOrder
    Validity?: SortOrder
  }

  export type Dormitory_CardMinOrderByAggregateInput = {
    Number?: SortOrder
    Start_Date?: SortOrder
    End_Date?: SortOrder
    ID_Card?: SortOrder
    Validity?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EmailOrderByRelevanceInput = {
    fields: EmailOrderByRelevanceFieldEnum | EmailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmailSsnEmailCompoundUniqueInput = {
    ssn: string
    email: string
  }

  export type EmailCountOrderByAggregateInput = {
    ssn?: SortOrder
    email?: SortOrder
  }

  export type EmailMaxOrderByAggregateInput = {
    ssn?: SortOrder
    email?: SortOrder
  }

  export type EmailMinOrderByAggregateInput = {
    ssn?: SortOrder
    email?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EmployeeScalarRelationFilter = {
    is?: employeeWhereInput
    isNot?: employeeWhereInput
  }

  export type Employee_CardOrderByRelevanceInput = {
    fields: Employee_CardOrderByRelevanceFieldEnum | Employee_CardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Employee_CardCountOrderByAggregateInput = {
    Number?: SortOrder
    Start_Date?: SortOrder
    End_Date?: SortOrder
    ID_Card?: SortOrder
    Employee_Type?: SortOrder
  }

  export type Employee_CardMaxOrderByAggregateInput = {
    Number?: SortOrder
    Start_Date?: SortOrder
    End_Date?: SortOrder
    ID_Card?: SortOrder
    Employee_Type?: SortOrder
  }

  export type Employee_CardMinOrderByAggregateInput = {
    Number?: SortOrder
    Start_Date?: SortOrder
    End_Date?: SortOrder
    ID_Card?: SortOrder
    Employee_Type?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Dormitory_CardNullableScalarRelationFilter = {
    is?: Dormitory_CardWhereInput | null
    isNot?: Dormitory_CardWhereInput | null
  }

  export type Employee_CardNullableScalarRelationFilter = {
    is?: Employee_CardWhereInput | null
    isNot?: Employee_CardWhereInput | null
  }

  export type Identity_CardOrderByRelevanceInput = {
    fields: Identity_CardOrderByRelevanceFieldEnum | Identity_CardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Identity_CardCountOrderByAggregateInput = {
    ID?: SortOrder
    Issued_Date?: SortOrder
  }

  export type Identity_CardMaxOrderByAggregateInput = {
    ID?: SortOrder
    Issued_Date?: SortOrder
  }

  export type Identity_CardMinOrderByAggregateInput = {
    ID?: SortOrder
    Issued_Date?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type EmailListRelationFilter = {
    every?: EmailWhereInput
    some?: EmailWhereInput
    none?: EmailWhereInput
  }

  export type PhoneNumberListRelationFilter = {
    every?: PhoneNumberWhereInput
    some?: PhoneNumberWhereInput
    none?: PhoneNumberWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: employeeWhereInput | null
    isNot?: employeeWhereInput | null
  }

  export type StudentNullableScalarRelationFilter = {
    is?: studentWhereInput | null
    isNot?: studentWhereInput | null
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhoneNumberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PeopleOrderByRelevanceInput = {
    fields: PeopleOrderByRelevanceFieldEnum | PeopleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PeopleCountOrderByAggregateInput = {
    SSN?: SortOrder
    Full_Name?: SortOrder
    Last_Name?: SortOrder
    Birthday?: SortOrder
    Sex?: SortOrder
    Health_State?: SortOrder
    Ethnic_Group?: SortOrder
  }

  export type PeopleMaxOrderByAggregateInput = {
    SSN?: SortOrder
    Full_Name?: SortOrder
    Last_Name?: SortOrder
    Birthday?: SortOrder
    Sex?: SortOrder
    Health_State?: SortOrder
    Ethnic_Group?: SortOrder
  }

  export type PeopleMinOrderByAggregateInput = {
    SSN?: SortOrder
    Full_Name?: SortOrder
    Last_Name?: SortOrder
    Birthday?: SortOrder
    Sex?: SortOrder
    Health_State?: SortOrder
    Ethnic_Group?: SortOrder
  }

  export type PhoneNumberOrderByRelevanceInput = {
    fields: PhoneNumberOrderByRelevanceFieldEnum | PhoneNumberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PhoneNumberSsnPhoneNumberCompoundUniqueInput = {
    ssn: string
    phoneNumber: string
  }

  export type PhoneNumberCountOrderByAggregateInput = {
    ssn?: SortOrder
    phoneNumber?: SortOrder
  }

  export type PhoneNumberMaxOrderByAggregateInput = {
    ssn?: SortOrder
    phoneNumber?: SortOrder
  }

  export type PhoneNumberMinOrderByAggregateInput = {
    ssn?: SortOrder
    phoneNumber?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Building_equipmentListRelationFilter = {
    every?: building_equipmentWhereInput
    some?: building_equipmentWhereInput
    none?: building_equipmentWhereInput
  }

  export type RoomListRelationFilter = {
    every?: roomWhereInput
    some?: roomWhereInput
    none?: roomWhereInput
  }

  export type building_equipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type buildingOrderByRelevanceInput = {
    fields: buildingOrderByRelevanceFieldEnum | buildingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type buildingCountOrderByAggregateInput = {
    building_id?: SortOrder
    building_name?: SortOrder
    floors?: SortOrder
    rooms?: SortOrder
    has_air_conditioner?: SortOrder
    sponsor?: SortOrder
    construction_date?: SortOrder
    last_renovation?: SortOrder
  }

  export type buildingAvgOrderByAggregateInput = {
    floors?: SortOrder
    rooms?: SortOrder
  }

  export type buildingMaxOrderByAggregateInput = {
    building_id?: SortOrder
    building_name?: SortOrder
    floors?: SortOrder
    rooms?: SortOrder
    has_air_conditioner?: SortOrder
    sponsor?: SortOrder
    construction_date?: SortOrder
    last_renovation?: SortOrder
  }

  export type buildingMinOrderByAggregateInput = {
    building_id?: SortOrder
    building_name?: SortOrder
    floors?: SortOrder
    rooms?: SortOrder
    has_air_conditioner?: SortOrder
    sponsor?: SortOrder
    construction_date?: SortOrder
    last_renovation?: SortOrder
  }

  export type buildingSumOrderByAggregateInput = {
    floors?: SortOrder
    rooms?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BuildingScalarRelationFilter = {
    is?: buildingWhereInput
    isNot?: buildingWhereInput
  }

  export type Large_equipmentScalarRelationFilter = {
    is?: large_equipmentWhereInput
    isNot?: large_equipmentWhereInput
  }

  export type building_equipmentOrderByRelevanceInput = {
    fields: building_equipmentOrderByRelevanceFieldEnum | building_equipmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type building_equipmentBuilding_idEquipment_idCompoundUniqueInput = {
    building_id: string
    equipment_id: string
  }

  export type building_equipmentCountOrderByAggregateInput = {
    building_id?: SortOrder
    equipment_id?: SortOrder
    quantity?: SortOrder
  }

  export type building_equipmentAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type building_equipmentMaxOrderByAggregateInput = {
    building_id?: SortOrder
    equipment_id?: SortOrder
    quantity?: SortOrder
  }

  export type building_equipmentMinOrderByAggregateInput = {
    building_id?: SortOrder
    equipment_id?: SortOrder
    quantity?: SortOrder
  }

  export type building_equipmentSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DisciplineStaffListRelationFilter = {
    every?: disciplineStaffWhereInput
    some?: disciplineStaffWhereInput
    none?: disciplineStaffWhereInput
  }

  export type StudentDisciplineListRelationFilter = {
    every?: studentDisciplineWhereInput
    some?: studentDisciplineWhereInput
    none?: studentDisciplineWhereInput
  }

  export type disciplineStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentDisciplineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type disciplinaryActionOrderByRelevanceInput = {
    fields: disciplinaryActionOrderByRelevanceFieldEnum | disciplinaryActionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type disciplinaryActionCountOrderByAggregateInput = {
    actionId?: SortOrder
    actionType?: SortOrder
    reason?: SortOrder
    decisionDate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    severityLevel?: SortOrder
    status?: SortOrder
  }

  export type disciplinaryActionMaxOrderByAggregateInput = {
    actionId?: SortOrder
    actionType?: SortOrder
    reason?: SortOrder
    decisionDate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    severityLevel?: SortOrder
    status?: SortOrder
  }

  export type disciplinaryActionMinOrderByAggregateInput = {
    actionId?: SortOrder
    actionType?: SortOrder
    reason?: SortOrder
    decisionDate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    severityLevel?: SortOrder
    status?: SortOrder
  }

  export type DisciplinaryActionScalarRelationFilter = {
    is?: disciplinaryActionWhereInput
    isNot?: disciplinaryActionWhereInput
  }

  export type Manager_employeeScalarRelationFilter = {
    is?: manager_employeeWhereInput
    isNot?: manager_employeeWhereInput
  }

  export type disciplineStaffOrderByRelevanceInput = {
    fields: disciplineStaffOrderByRelevanceFieldEnum | disciplineStaffOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type disciplineStaffActionIdEssnCompoundUniqueInput = {
    actionId: string
    essn: string
  }

  export type disciplineStaffCountOrderByAggregateInput = {
    actionId?: SortOrder
    essn?: SortOrder
  }

  export type disciplineStaffMaxOrderByAggregateInput = {
    actionId?: SortOrder
    essn?: SortOrder
  }

  export type disciplineStaffMinOrderByAggregateInput = {
    actionId?: SortOrder
    essn?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Employee_CardListRelationFilter = {
    every?: Employee_CardWhereInput
    some?: Employee_CardWhereInput
    none?: Employee_CardWhereInput
  }

  export type Manager_employeeNullableScalarRelationFilter = {
    is?: manager_employeeWhereInput | null
    isNot?: manager_employeeWhereInput | null
  }

  export type Medical_employeeNullableScalarRelationFilter = {
    is?: medical_employeeWhereInput | null
    isNot?: medical_employeeWhereInput | null
  }

  export type Other_employeeNullableScalarRelationFilter = {
    is?: other_employeeWhereInput | null
    isNot?: other_employeeWhereInput | null
  }

  export type Employee_CardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeeOrderByRelevanceInput = {
    fields: employeeOrderByRelevanceFieldEnum | employeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type employeeCountOrderByAggregateInput = {
    essn?: SortOrder
    salary?: SortOrder
    empId?: SortOrder
  }

  export type employeeAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type employeeMaxOrderByAggregateInput = {
    essn?: SortOrder
    salary?: SortOrder
    empId?: SortOrder
  }

  export type employeeMinOrderByAggregateInput = {
    essn?: SortOrder
    salary?: SortOrder
    empId?: SortOrder
  }

  export type employeeSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type Enumhealth_room_equipment_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.health_room_equipment_status | Enumhealth_room_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.health_room_equipment_status[]
    notIn?: $Enums.health_room_equipment_status[]
    not?: NestedEnumhealth_room_equipment_statusFilter<$PrismaModel> | $Enums.health_room_equipment_status
  }

  export type RoomScalarRelationFilter = {
    is?: roomWhereInput
    isNot?: roomWhereInput
  }

  export type Medical_employeeListRelationFilter = {
    every?: medical_employeeWhereInput
    some?: medical_employeeWhereInput
    none?: medical_employeeWhereInput
  }

  export type medical_employeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type health_roomOrderByRelevanceInput = {
    fields: health_roomOrderByRelevanceFieldEnum | health_roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type health_roomBuilding_idRoom_idCompoundUniqueInput = {
    building_id: string
    room_id: string
  }

  export type health_roomCountOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    equipment_status?: SortOrder
  }

  export type health_roomAvgOrderByAggregateInput = {
    num_of_staff?: SortOrder
  }

  export type health_roomMaxOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    equipment_status?: SortOrder
  }

  export type health_roomMinOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    equipment_status?: SortOrder
  }

  export type health_roomSumOrderByAggregateInput = {
    num_of_staff?: SortOrder
  }

  export type Enumhealth_room_equipment_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.health_room_equipment_status | Enumhealth_room_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.health_room_equipment_status[]
    notIn?: $Enums.health_room_equipment_status[]
    not?: NestedEnumhealth_room_equipment_statusWithAggregatesFilter<$PrismaModel> | $Enums.health_room_equipment_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhealth_room_equipment_statusFilter<$PrismaModel>
    _max?: NestedEnumhealth_room_equipment_statusFilter<$PrismaModel>
  }

  export type Enumlarge_equipment_equipment_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.large_equipment_equipment_status | Enumlarge_equipment_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.large_equipment_equipment_status[]
    notIn?: $Enums.large_equipment_equipment_status[]
    not?: NestedEnumlarge_equipment_equipment_statusFilter<$PrismaModel> | $Enums.large_equipment_equipment_status
  }

  export type large_equipmentOrderByRelevanceInput = {
    fields: large_equipmentOrderByRelevanceFieldEnum | large_equipmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type large_equipmentCountOrderByAggregateInput = {
    equipment_id?: SortOrder
    equipment_name?: SortOrder
    equipment_type?: SortOrder
    equipment_status?: SortOrder
    purchase_date?: SortOrder
    purchase_location?: SortOrder
  }

  export type large_equipmentMaxOrderByAggregateInput = {
    equipment_id?: SortOrder
    equipment_name?: SortOrder
    equipment_type?: SortOrder
    equipment_status?: SortOrder
    purchase_date?: SortOrder
    purchase_location?: SortOrder
  }

  export type large_equipmentMinOrderByAggregateInput = {
    equipment_id?: SortOrder
    equipment_name?: SortOrder
    equipment_type?: SortOrder
    equipment_status?: SortOrder
    purchase_date?: SortOrder
    purchase_location?: SortOrder
  }

  export type Enumlarge_equipment_equipment_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.large_equipment_equipment_status | Enumlarge_equipment_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.large_equipment_equipment_status[]
    notIn?: $Enums.large_equipment_equipment_status[]
    not?: NestedEnumlarge_equipment_equipment_statusWithAggregatesFilter<$PrismaModel> | $Enums.large_equipment_equipment_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlarge_equipment_equipment_statusFilter<$PrismaModel>
    _max?: NestedEnumlarge_equipment_equipment_statusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StudentListRelationFilter = {
    every?: studentWhereInput
    some?: studentWhereInput
    none?: studentWhereInput
  }

  export type studentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type living_roomOrderByRelevanceInput = {
    fields: living_roomOrderByRelevanceFieldEnum | living_roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type living_roomBuilding_idRoom_idCompoundUniqueInput = {
    building_id: string
    room_id: string
  }

  export type living_roomCountOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    max_num_of_students?: SortOrder
    current_num_of_students?: SortOrder
    rental_price?: SortOrder
    occupancy_rate?: SortOrder
  }

  export type living_roomAvgOrderByAggregateInput = {
    max_num_of_students?: SortOrder
    current_num_of_students?: SortOrder
    rental_price?: SortOrder
    occupancy_rate?: SortOrder
  }

  export type living_roomMaxOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    max_num_of_students?: SortOrder
    current_num_of_students?: SortOrder
    rental_price?: SortOrder
    occupancy_rate?: SortOrder
  }

  export type living_roomMinOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    max_num_of_students?: SortOrder
    current_num_of_students?: SortOrder
    rental_price?: SortOrder
    occupancy_rate?: SortOrder
  }

  export type living_roomSumOrderByAggregateInput = {
    max_num_of_students?: SortOrder
    current_num_of_students?: SortOrder
    rental_price?: SortOrder
    occupancy_rate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Manager_employeeListRelationFilter = {
    every?: manager_employeeWhereInput
    some?: manager_employeeWhereInput
    none?: manager_employeeWhereInput
  }

  export type manager_employeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type management_roomOrderByRelevanceInput = {
    fields: management_roomOrderByRelevanceFieldEnum | management_roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type management_roomBuilding_idRoom_idCompoundUniqueInput = {
    building_id: string
    room_id: string
  }

  export type management_roomCountOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type management_roomAvgOrderByAggregateInput = {
    num_of_staff?: SortOrder
  }

  export type management_roomMaxOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type management_roomMinOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type management_roomSumOrderByAggregateInput = {
    num_of_staff?: SortOrder
  }

  export type managerDormOrderByRelevanceInput = {
    fields: managerDormOrderByRelevanceFieldEnum | managerDormOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type managerDormUser_namePasswordCompoundUniqueInput = {
    user_name: string
    password: string
  }

  export type managerDormCountOrderByAggregateInput = {
    user_name?: SortOrder
    password?: SortOrder
  }

  export type managerDormMaxOrderByAggregateInput = {
    user_name?: SortOrder
    password?: SortOrder
  }

  export type managerDormMinOrderByAggregateInput = {
    user_name?: SortOrder
    password?: SortOrder
  }

  export type manager_degreeOrderByRelevanceInput = {
    fields: manager_degreeOrderByRelevanceFieldEnum | manager_degreeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type manager_degreeEssnDegreeCompoundUniqueInput = {
    essn: string
    degree: string
  }

  export type manager_degreeCountOrderByAggregateInput = {
    essn?: SortOrder
    degree?: SortOrder
  }

  export type manager_degreeMaxOrderByAggregateInput = {
    essn?: SortOrder
    degree?: SortOrder
  }

  export type manager_degreeMinOrderByAggregateInput = {
    essn?: SortOrder
    degree?: SortOrder
  }

  export type Manager_degreeListRelationFilter = {
    every?: manager_degreeWhereInput
    some?: manager_degreeWhereInput
    none?: manager_degreeWhereInput
  }

  export type Management_roomNullableScalarRelationFilter = {
    is?: management_roomWhereInput | null
    isNot?: management_roomWhereInput | null
  }

  export type manager_degreeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type manager_employeeOrderByRelevanceInput = {
    fields: manager_employeeOrderByRelevanceFieldEnum | manager_employeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type manager_employeeCountOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    experience?: SortOrder
  }

  export type manager_employeeAvgOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type manager_employeeMaxOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    experience?: SortOrder
  }

  export type manager_employeeMinOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    experience?: SortOrder
  }

  export type manager_employeeSumOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type Medical_employeeScalarRelationFilter = {
    is?: medical_employeeWhereInput
    isNot?: medical_employeeWhereInput
  }

  export type medical_degreeOrderByRelevanceInput = {
    fields: medical_degreeOrderByRelevanceFieldEnum | medical_degreeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type medical_degreeEssnDegreeCompoundUniqueInput = {
    essn: string
    degree: string
  }

  export type medical_degreeCountOrderByAggregateInput = {
    essn?: SortOrder
    degree?: SortOrder
  }

  export type medical_degreeMaxOrderByAggregateInput = {
    essn?: SortOrder
    degree?: SortOrder
  }

  export type medical_degreeMinOrderByAggregateInput = {
    essn?: SortOrder
    degree?: SortOrder
  }

  export type Medical_degreeListRelationFilter = {
    every?: medical_degreeWhereInput
    some?: medical_degreeWhereInput
    none?: medical_degreeWhereInput
  }

  export type Health_roomNullableScalarRelationFilter = {
    is?: health_roomWhereInput | null
    isNot?: health_roomWhereInput | null
  }

  export type medical_degreeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medical_employeeOrderByRelevanceInput = {
    fields: medical_employeeOrderByRelevanceFieldEnum | medical_employeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type medical_employeeCountOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    experience?: SortOrder
  }

  export type medical_employeeAvgOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type medical_employeeMaxOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    experience?: SortOrder
  }

  export type medical_employeeMinOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    experience?: SortOrder
  }

  export type medical_employeeSumOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type Other_roomNullableScalarRelationFilter = {
    is?: other_roomWhereInput | null
    isNot?: other_roomWhereInput | null
  }

  export type Other_employee_time_workListRelationFilter = {
    every?: other_employee_time_workWhereInput
    some?: other_employee_time_workWhereInput
    none?: other_employee_time_workWhereInput
  }

  export type other_employee_time_workOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type other_employeeOrderByRelevanceInput = {
    fields: other_employeeOrderByRelevanceFieldEnum | other_employeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type other_employeeCountOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    typeWork?: SortOrder
  }

  export type other_employeeMaxOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    typeWork?: SortOrder
  }

  export type other_employeeMinOrderByAggregateInput = {
    essn?: SortOrder
    room_id?: SortOrder
    building_id?: SortOrder
    typeWork?: SortOrder
  }

  export type Enumother_employee_time_work_date_workFilter<$PrismaModel = never> = {
    equals?: $Enums.other_employee_time_work_date_work | Enumother_employee_time_work_date_workFieldRefInput<$PrismaModel>
    in?: $Enums.other_employee_time_work_date_work[]
    notIn?: $Enums.other_employee_time_work_date_work[]
    not?: NestedEnumother_employee_time_work_date_workFilter<$PrismaModel> | $Enums.other_employee_time_work_date_work
  }

  export type Other_employeeScalarRelationFilter = {
    is?: other_employeeWhereInput
    isNot?: other_employeeWhereInput
  }

  export type other_employee_time_workOrderByRelevanceInput = {
    fields: other_employee_time_workOrderByRelevanceFieldEnum | other_employee_time_workOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type other_employee_time_workEssnDate_workTime_startTime_endCompoundUniqueInput = {
    essn: string
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date | string
    time_end: Date | string
  }

  export type other_employee_time_workCountOrderByAggregateInput = {
    essn?: SortOrder
    date_work?: SortOrder
    time_start?: SortOrder
    time_end?: SortOrder
  }

  export type other_employee_time_workMaxOrderByAggregateInput = {
    essn?: SortOrder
    date_work?: SortOrder
    time_start?: SortOrder
    time_end?: SortOrder
  }

  export type other_employee_time_workMinOrderByAggregateInput = {
    essn?: SortOrder
    date_work?: SortOrder
    time_start?: SortOrder
    time_end?: SortOrder
  }

  export type Enumother_employee_time_work_date_workWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.other_employee_time_work_date_work | Enumother_employee_time_work_date_workFieldRefInput<$PrismaModel>
    in?: $Enums.other_employee_time_work_date_work[]
    notIn?: $Enums.other_employee_time_work_date_work[]
    not?: NestedEnumother_employee_time_work_date_workWithAggregatesFilter<$PrismaModel> | $Enums.other_employee_time_work_date_work
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumother_employee_time_work_date_workFilter<$PrismaModel>
    _max?: NestedEnumother_employee_time_work_date_workFilter<$PrismaModel>
  }

  export type Other_employeeListRelationFilter = {
    every?: other_employeeWhereInput
    some?: other_employeeWhereInput
    none?: other_employeeWhereInput
  }

  export type other_employeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type other_roomOrderByRelevanceInput = {
    fields: other_roomOrderByRelevanceFieldEnum | other_roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type other_roomBuilding_idRoom_idCompoundUniqueInput = {
    building_id: string
    room_id: string
  }

  export type other_roomCountOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_type?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type other_roomAvgOrderByAggregateInput = {
    num_of_staff?: SortOrder
  }

  export type other_roomMaxOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_type?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type other_roomMinOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_type?: SortOrder
    num_of_staff?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type other_roomSumOrderByAggregateInput = {
    num_of_staff?: SortOrder
  }

  export type relativeOrderByRelevanceInput = {
    fields: relativeOrderByRelevanceFieldEnum | relativeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type relativeSssnFnameLnameCompoundUniqueInput = {
    Sssn: string
    fname: string
    lname: string
  }

  export type relativeCountOrderByAggregateInput = {
    Sssn?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    birthday?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    job?: SortOrder
  }

  export type relativeMaxOrderByAggregateInput = {
    Sssn?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    birthday?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    job?: SortOrder
  }

  export type relativeMinOrderByAggregateInput = {
    Sssn?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    birthday?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    job?: SortOrder
  }

  export type Enumroom_room_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.room_room_status | Enumroom_room_statusFieldRefInput<$PrismaModel>
    in?: $Enums.room_room_status[]
    notIn?: $Enums.room_room_status[]
    not?: NestedEnumroom_room_statusFilter<$PrismaModel> | $Enums.room_room_status
  }

  export type roomOrderByRelevanceInput = {
    fields: roomOrderByRelevanceFieldEnum | roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type roomBuilding_idRoom_idCompoundUniqueInput = {
    building_id: string
    room_id: string
  }

  export type roomCountOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_status?: SortOrder
    room_area?: SortOrder
  }

  export type roomAvgOrderByAggregateInput = {
    room_area?: SortOrder
  }

  export type roomMaxOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_status?: SortOrder
    room_area?: SortOrder
  }

  export type roomMinOrderByAggregateInput = {
    building_id?: SortOrder
    room_id?: SortOrder
    room_status?: SortOrder
    room_area?: SortOrder
  }

  export type roomSumOrderByAggregateInput = {
    room_area?: SortOrder
  }

  export type Enumroom_room_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.room_room_status | Enumroom_room_statusFieldRefInput<$PrismaModel>
    in?: $Enums.room_room_status[]
    notIn?: $Enums.room_room_status[]
    not?: NestedEnumroom_room_statusWithAggregatesFilter<$PrismaModel> | $Enums.room_room_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroom_room_statusFilter<$PrismaModel>
    _max?: NestedEnumroom_room_statusFilter<$PrismaModel>
  }

  export type Dormitory_CardListRelationFilter = {
    every?: Dormitory_CardWhereInput
    some?: Dormitory_CardWhereInput
    none?: Dormitory_CardWhereInput
  }

  export type RelativeListRelationFilter = {
    every?: relativeWhereInput
    some?: relativeWhereInput
    none?: relativeWhereInput
  }

  export type Living_roomNullableScalarRelationFilter = {
    is?: living_roomWhereInput | null
    isNot?: living_roomWhereInput | null
  }

  export type Dormitory_CardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type relativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentOrderByRelevanceInput = {
    fields: studentOrderByRelevanceFieldEnum | studentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type studentCountOrderByAggregateInput = {
    Sssn?: SortOrder
    studentId?: SortOrder
    hasHealthInsurance?: SortOrder
    studyStatus?: SortOrder
    className?: SortOrder
    faculty?: SortOrder
    building_id?: SortOrder
    room_id?: SortOrder
  }

  export type studentMaxOrderByAggregateInput = {
    Sssn?: SortOrder
    studentId?: SortOrder
    hasHealthInsurance?: SortOrder
    studyStatus?: SortOrder
    className?: SortOrder
    faculty?: SortOrder
    building_id?: SortOrder
    room_id?: SortOrder
  }

  export type studentMinOrderByAggregateInput = {
    Sssn?: SortOrder
    studentId?: SortOrder
    hasHealthInsurance?: SortOrder
    studyStatus?: SortOrder
    className?: SortOrder
    faculty?: SortOrder
    building_id?: SortOrder
    room_id?: SortOrder
  }

  export type studentDisciplineOrderByRelevanceInput = {
    fields: studentDisciplineOrderByRelevanceFieldEnum | studentDisciplineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type studentDisciplineActionIdSssnCompoundUniqueInput = {
    actionId: string
    Sssn: string
  }

  export type studentDisciplineCountOrderByAggregateInput = {
    actionId?: SortOrder
    Sssn?: SortOrder
  }

  export type studentDisciplineMaxOrderByAggregateInput = {
    actionId?: SortOrder
    Sssn?: SortOrder
  }

  export type studentDisciplineMinOrderByAggregateInput = {
    actionId?: SortOrder
    Sssn?: SortOrder
  }

  export type PeopleCreateNestedOneWithoutAddressInput = {
    create?: XOR<PeopleCreateWithoutAddressInput, PeopleUncheckedCreateWithoutAddressInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutAddressInput
    connect?: PeopleWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PeopleUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<PeopleCreateWithoutAddressInput, PeopleUncheckedCreateWithoutAddressInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutAddressInput
    upsert?: PeopleUpsertWithoutAddressInput
    connect?: PeopleWhereUniqueInput
    update?: XOR<XOR<PeopleUpdateToOneWithWhereWithoutAddressInput, PeopleUpdateWithoutAddressInput>, PeopleUncheckedUpdateWithoutAddressInput>
  }

  export type Identity_CardCreateNestedOneWithoutDormitory_CardInput = {
    create?: XOR<Identity_CardCreateWithoutDormitory_CardInput, Identity_CardUncheckedCreateWithoutDormitory_CardInput>
    connectOrCreate?: Identity_CardCreateOrConnectWithoutDormitory_CardInput
    connect?: Identity_CardWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutDormitory_CardInput = {
    create?: XOR<studentCreateWithoutDormitory_CardInput, studentUncheckedCreateWithoutDormitory_CardInput>
    connectOrCreate?: studentCreateOrConnectWithoutDormitory_CardInput
    connect?: studentWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type Identity_CardUpdateOneRequiredWithoutDormitory_CardNestedInput = {
    create?: XOR<Identity_CardCreateWithoutDormitory_CardInput, Identity_CardUncheckedCreateWithoutDormitory_CardInput>
    connectOrCreate?: Identity_CardCreateOrConnectWithoutDormitory_CardInput
    upsert?: Identity_CardUpsertWithoutDormitory_CardInput
    connect?: Identity_CardWhereUniqueInput
    update?: XOR<XOR<Identity_CardUpdateToOneWithWhereWithoutDormitory_CardInput, Identity_CardUpdateWithoutDormitory_CardInput>, Identity_CardUncheckedUpdateWithoutDormitory_CardInput>
  }

  export type studentUpdateOneRequiredWithoutDormitory_CardNestedInput = {
    create?: XOR<studentCreateWithoutDormitory_CardInput, studentUncheckedCreateWithoutDormitory_CardInput>
    connectOrCreate?: studentCreateOrConnectWithoutDormitory_CardInput
    upsert?: studentUpsertWithoutDormitory_CardInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutDormitory_CardInput, studentUpdateWithoutDormitory_CardInput>, studentUncheckedUpdateWithoutDormitory_CardInput>
  }

  export type PeopleCreateNestedOneWithoutEmailInput = {
    create?: XOR<PeopleCreateWithoutEmailInput, PeopleUncheckedCreateWithoutEmailInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutEmailInput
    connect?: PeopleWhereUniqueInput
  }

  export type PeopleUpdateOneRequiredWithoutEmailNestedInput = {
    create?: XOR<PeopleCreateWithoutEmailInput, PeopleUncheckedCreateWithoutEmailInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutEmailInput
    upsert?: PeopleUpsertWithoutEmailInput
    connect?: PeopleWhereUniqueInput
    update?: XOR<XOR<PeopleUpdateToOneWithWhereWithoutEmailInput, PeopleUpdateWithoutEmailInput>, PeopleUncheckedUpdateWithoutEmailInput>
  }

  export type Identity_CardCreateNestedOneWithoutEmployee_CardInput = {
    create?: XOR<Identity_CardCreateWithoutEmployee_CardInput, Identity_CardUncheckedCreateWithoutEmployee_CardInput>
    connectOrCreate?: Identity_CardCreateOrConnectWithoutEmployee_CardInput
    connect?: Identity_CardWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutEmployee_CardInput = {
    create?: XOR<employeeCreateWithoutEmployee_CardInput, employeeUncheckedCreateWithoutEmployee_CardInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployee_CardInput
    connect?: employeeWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type Identity_CardUpdateOneRequiredWithoutEmployee_CardNestedInput = {
    create?: XOR<Identity_CardCreateWithoutEmployee_CardInput, Identity_CardUncheckedCreateWithoutEmployee_CardInput>
    connectOrCreate?: Identity_CardCreateOrConnectWithoutEmployee_CardInput
    upsert?: Identity_CardUpsertWithoutEmployee_CardInput
    connect?: Identity_CardWhereUniqueInput
    update?: XOR<XOR<Identity_CardUpdateToOneWithWhereWithoutEmployee_CardInput, Identity_CardUpdateWithoutEmployee_CardInput>, Identity_CardUncheckedUpdateWithoutEmployee_CardInput>
  }

  export type employeeUpdateOneRequiredWithoutEmployee_CardNestedInput = {
    create?: XOR<employeeCreateWithoutEmployee_CardInput, employeeUncheckedCreateWithoutEmployee_CardInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployee_CardInput
    upsert?: employeeUpsertWithoutEmployee_CardInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutEmployee_CardInput, employeeUpdateWithoutEmployee_CardInput>, employeeUncheckedUpdateWithoutEmployee_CardInput>
  }

  export type Dormitory_CardCreateNestedOneWithoutIdentity_CardInput = {
    create?: XOR<Dormitory_CardCreateWithoutIdentity_CardInput, Dormitory_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutIdentity_CardInput
    connect?: Dormitory_CardWhereUniqueInput
  }

  export type Employee_CardCreateNestedOneWithoutIdentity_CardInput = {
    create?: XOR<Employee_CardCreateWithoutIdentity_CardInput, Employee_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Employee_CardCreateOrConnectWithoutIdentity_CardInput
    connect?: Employee_CardWhereUniqueInput
  }

  export type Dormitory_CardUncheckedCreateNestedOneWithoutIdentity_CardInput = {
    create?: XOR<Dormitory_CardCreateWithoutIdentity_CardInput, Dormitory_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutIdentity_CardInput
    connect?: Dormitory_CardWhereUniqueInput
  }

  export type Employee_CardUncheckedCreateNestedOneWithoutIdentity_CardInput = {
    create?: XOR<Employee_CardCreateWithoutIdentity_CardInput, Employee_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Employee_CardCreateOrConnectWithoutIdentity_CardInput
    connect?: Employee_CardWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Dormitory_CardUpdateOneWithoutIdentity_CardNestedInput = {
    create?: XOR<Dormitory_CardCreateWithoutIdentity_CardInput, Dormitory_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutIdentity_CardInput
    upsert?: Dormitory_CardUpsertWithoutIdentity_CardInput
    disconnect?: Dormitory_CardWhereInput | boolean
    delete?: Dormitory_CardWhereInput | boolean
    connect?: Dormitory_CardWhereUniqueInput
    update?: XOR<XOR<Dormitory_CardUpdateToOneWithWhereWithoutIdentity_CardInput, Dormitory_CardUpdateWithoutIdentity_CardInput>, Dormitory_CardUncheckedUpdateWithoutIdentity_CardInput>
  }

  export type Employee_CardUpdateOneWithoutIdentity_CardNestedInput = {
    create?: XOR<Employee_CardCreateWithoutIdentity_CardInput, Employee_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Employee_CardCreateOrConnectWithoutIdentity_CardInput
    upsert?: Employee_CardUpsertWithoutIdentity_CardInput
    disconnect?: Employee_CardWhereInput | boolean
    delete?: Employee_CardWhereInput | boolean
    connect?: Employee_CardWhereUniqueInput
    update?: XOR<XOR<Employee_CardUpdateToOneWithWhereWithoutIdentity_CardInput, Employee_CardUpdateWithoutIdentity_CardInput>, Employee_CardUncheckedUpdateWithoutIdentity_CardInput>
  }

  export type Dormitory_CardUncheckedUpdateOneWithoutIdentity_CardNestedInput = {
    create?: XOR<Dormitory_CardCreateWithoutIdentity_CardInput, Dormitory_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutIdentity_CardInput
    upsert?: Dormitory_CardUpsertWithoutIdentity_CardInput
    disconnect?: Dormitory_CardWhereInput | boolean
    delete?: Dormitory_CardWhereInput | boolean
    connect?: Dormitory_CardWhereUniqueInput
    update?: XOR<XOR<Dormitory_CardUpdateToOneWithWhereWithoutIdentity_CardInput, Dormitory_CardUpdateWithoutIdentity_CardInput>, Dormitory_CardUncheckedUpdateWithoutIdentity_CardInput>
  }

  export type Employee_CardUncheckedUpdateOneWithoutIdentity_CardNestedInput = {
    create?: XOR<Employee_CardCreateWithoutIdentity_CardInput, Employee_CardUncheckedCreateWithoutIdentity_CardInput>
    connectOrCreate?: Employee_CardCreateOrConnectWithoutIdentity_CardInput
    upsert?: Employee_CardUpsertWithoutIdentity_CardInput
    disconnect?: Employee_CardWhereInput | boolean
    delete?: Employee_CardWhereInput | boolean
    connect?: Employee_CardWhereUniqueInput
    update?: XOR<XOR<Employee_CardUpdateToOneWithWhereWithoutIdentity_CardInput, Employee_CardUpdateWithoutIdentity_CardInput>, Employee_CardUncheckedUpdateWithoutIdentity_CardInput>
  }

  export type AddressCreateNestedManyWithoutPeopleInput = {
    create?: XOR<AddressCreateWithoutPeopleInput, AddressUncheckedCreateWithoutPeopleInput> | AddressCreateWithoutPeopleInput[] | AddressUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPeopleInput | AddressCreateOrConnectWithoutPeopleInput[]
    createMany?: AddressCreateManyPeopleInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type EmailCreateNestedManyWithoutPeopleInput = {
    create?: XOR<EmailCreateWithoutPeopleInput, EmailUncheckedCreateWithoutPeopleInput> | EmailCreateWithoutPeopleInput[] | EmailUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutPeopleInput | EmailCreateOrConnectWithoutPeopleInput[]
    createMany?: EmailCreateManyPeopleInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type PhoneNumberCreateNestedManyWithoutPeopleInput = {
    create?: XOR<PhoneNumberCreateWithoutPeopleInput, PhoneNumberUncheckedCreateWithoutPeopleInput> | PhoneNumberCreateWithoutPeopleInput[] | PhoneNumberUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: PhoneNumberCreateOrConnectWithoutPeopleInput | PhoneNumberCreateOrConnectWithoutPeopleInput[]
    createMany?: PhoneNumberCreateManyPeopleInputEnvelope
    connect?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
  }

  export type employeeCreateNestedOneWithoutPeopleInput = {
    create?: XOR<employeeCreateWithoutPeopleInput, employeeUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: employeeCreateOrConnectWithoutPeopleInput
    connect?: employeeWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutPeopleInput = {
    create?: XOR<studentCreateWithoutPeopleInput, studentUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: studentCreateOrConnectWithoutPeopleInput
    connect?: studentWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedManyWithoutPeopleInput = {
    create?: XOR<AddressCreateWithoutPeopleInput, AddressUncheckedCreateWithoutPeopleInput> | AddressCreateWithoutPeopleInput[] | AddressUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPeopleInput | AddressCreateOrConnectWithoutPeopleInput[]
    createMany?: AddressCreateManyPeopleInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutPeopleInput = {
    create?: XOR<EmailCreateWithoutPeopleInput, EmailUncheckedCreateWithoutPeopleInput> | EmailCreateWithoutPeopleInput[] | EmailUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutPeopleInput | EmailCreateOrConnectWithoutPeopleInput[]
    createMany?: EmailCreateManyPeopleInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type PhoneNumberUncheckedCreateNestedManyWithoutPeopleInput = {
    create?: XOR<PhoneNumberCreateWithoutPeopleInput, PhoneNumberUncheckedCreateWithoutPeopleInput> | PhoneNumberCreateWithoutPeopleInput[] | PhoneNumberUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: PhoneNumberCreateOrConnectWithoutPeopleInput | PhoneNumberCreateOrConnectWithoutPeopleInput[]
    createMany?: PhoneNumberCreateManyPeopleInputEnvelope
    connect?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedOneWithoutPeopleInput = {
    create?: XOR<employeeCreateWithoutPeopleInput, employeeUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: employeeCreateOrConnectWithoutPeopleInput
    connect?: employeeWhereUniqueInput
  }

  export type studentUncheckedCreateNestedOneWithoutPeopleInput = {
    create?: XOR<studentCreateWithoutPeopleInput, studentUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: studentCreateOrConnectWithoutPeopleInput
    connect?: studentWhereUniqueInput
  }

  export type AddressUpdateManyWithoutPeopleNestedInput = {
    create?: XOR<AddressCreateWithoutPeopleInput, AddressUncheckedCreateWithoutPeopleInput> | AddressCreateWithoutPeopleInput[] | AddressUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPeopleInput | AddressCreateOrConnectWithoutPeopleInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPeopleInput | AddressUpsertWithWhereUniqueWithoutPeopleInput[]
    createMany?: AddressCreateManyPeopleInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPeopleInput | AddressUpdateWithWhereUniqueWithoutPeopleInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPeopleInput | AddressUpdateManyWithWhereWithoutPeopleInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type EmailUpdateManyWithoutPeopleNestedInput = {
    create?: XOR<EmailCreateWithoutPeopleInput, EmailUncheckedCreateWithoutPeopleInput> | EmailCreateWithoutPeopleInput[] | EmailUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutPeopleInput | EmailCreateOrConnectWithoutPeopleInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutPeopleInput | EmailUpsertWithWhereUniqueWithoutPeopleInput[]
    createMany?: EmailCreateManyPeopleInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutPeopleInput | EmailUpdateWithWhereUniqueWithoutPeopleInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutPeopleInput | EmailUpdateManyWithWhereWithoutPeopleInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type PhoneNumberUpdateManyWithoutPeopleNestedInput = {
    create?: XOR<PhoneNumberCreateWithoutPeopleInput, PhoneNumberUncheckedCreateWithoutPeopleInput> | PhoneNumberCreateWithoutPeopleInput[] | PhoneNumberUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: PhoneNumberCreateOrConnectWithoutPeopleInput | PhoneNumberCreateOrConnectWithoutPeopleInput[]
    upsert?: PhoneNumberUpsertWithWhereUniqueWithoutPeopleInput | PhoneNumberUpsertWithWhereUniqueWithoutPeopleInput[]
    createMany?: PhoneNumberCreateManyPeopleInputEnvelope
    set?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    disconnect?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    delete?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    connect?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    update?: PhoneNumberUpdateWithWhereUniqueWithoutPeopleInput | PhoneNumberUpdateWithWhereUniqueWithoutPeopleInput[]
    updateMany?: PhoneNumberUpdateManyWithWhereWithoutPeopleInput | PhoneNumberUpdateManyWithWhereWithoutPeopleInput[]
    deleteMany?: PhoneNumberScalarWhereInput | PhoneNumberScalarWhereInput[]
  }

  export type employeeUpdateOneWithoutPeopleNestedInput = {
    create?: XOR<employeeCreateWithoutPeopleInput, employeeUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: employeeCreateOrConnectWithoutPeopleInput
    upsert?: employeeUpsertWithoutPeopleInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutPeopleInput, employeeUpdateWithoutPeopleInput>, employeeUncheckedUpdateWithoutPeopleInput>
  }

  export type studentUpdateOneWithoutPeopleNestedInput = {
    create?: XOR<studentCreateWithoutPeopleInput, studentUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: studentCreateOrConnectWithoutPeopleInput
    upsert?: studentUpsertWithoutPeopleInput
    disconnect?: studentWhereInput | boolean
    delete?: studentWhereInput | boolean
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutPeopleInput, studentUpdateWithoutPeopleInput>, studentUncheckedUpdateWithoutPeopleInput>
  }

  export type AddressUncheckedUpdateManyWithoutPeopleNestedInput = {
    create?: XOR<AddressCreateWithoutPeopleInput, AddressUncheckedCreateWithoutPeopleInput> | AddressCreateWithoutPeopleInput[] | AddressUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPeopleInput | AddressCreateOrConnectWithoutPeopleInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPeopleInput | AddressUpsertWithWhereUniqueWithoutPeopleInput[]
    createMany?: AddressCreateManyPeopleInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPeopleInput | AddressUpdateWithWhereUniqueWithoutPeopleInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPeopleInput | AddressUpdateManyWithWhereWithoutPeopleInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutPeopleNestedInput = {
    create?: XOR<EmailCreateWithoutPeopleInput, EmailUncheckedCreateWithoutPeopleInput> | EmailCreateWithoutPeopleInput[] | EmailUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutPeopleInput | EmailCreateOrConnectWithoutPeopleInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutPeopleInput | EmailUpsertWithWhereUniqueWithoutPeopleInput[]
    createMany?: EmailCreateManyPeopleInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutPeopleInput | EmailUpdateWithWhereUniqueWithoutPeopleInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutPeopleInput | EmailUpdateManyWithWhereWithoutPeopleInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type PhoneNumberUncheckedUpdateManyWithoutPeopleNestedInput = {
    create?: XOR<PhoneNumberCreateWithoutPeopleInput, PhoneNumberUncheckedCreateWithoutPeopleInput> | PhoneNumberCreateWithoutPeopleInput[] | PhoneNumberUncheckedCreateWithoutPeopleInput[]
    connectOrCreate?: PhoneNumberCreateOrConnectWithoutPeopleInput | PhoneNumberCreateOrConnectWithoutPeopleInput[]
    upsert?: PhoneNumberUpsertWithWhereUniqueWithoutPeopleInput | PhoneNumberUpsertWithWhereUniqueWithoutPeopleInput[]
    createMany?: PhoneNumberCreateManyPeopleInputEnvelope
    set?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    disconnect?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    delete?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    connect?: PhoneNumberWhereUniqueInput | PhoneNumberWhereUniqueInput[]
    update?: PhoneNumberUpdateWithWhereUniqueWithoutPeopleInput | PhoneNumberUpdateWithWhereUniqueWithoutPeopleInput[]
    updateMany?: PhoneNumberUpdateManyWithWhereWithoutPeopleInput | PhoneNumberUpdateManyWithWhereWithoutPeopleInput[]
    deleteMany?: PhoneNumberScalarWhereInput | PhoneNumberScalarWhereInput[]
  }

  export type employeeUncheckedUpdateOneWithoutPeopleNestedInput = {
    create?: XOR<employeeCreateWithoutPeopleInput, employeeUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: employeeCreateOrConnectWithoutPeopleInput
    upsert?: employeeUpsertWithoutPeopleInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutPeopleInput, employeeUpdateWithoutPeopleInput>, employeeUncheckedUpdateWithoutPeopleInput>
  }

  export type studentUncheckedUpdateOneWithoutPeopleNestedInput = {
    create?: XOR<studentCreateWithoutPeopleInput, studentUncheckedCreateWithoutPeopleInput>
    connectOrCreate?: studentCreateOrConnectWithoutPeopleInput
    upsert?: studentUpsertWithoutPeopleInput
    disconnect?: studentWhereInput | boolean
    delete?: studentWhereInput | boolean
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutPeopleInput, studentUpdateWithoutPeopleInput>, studentUncheckedUpdateWithoutPeopleInput>
  }

  export type PeopleCreateNestedOneWithoutPhoneNumberInput = {
    create?: XOR<PeopleCreateWithoutPhoneNumberInput, PeopleUncheckedCreateWithoutPhoneNumberInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutPhoneNumberInput
    connect?: PeopleWhereUniqueInput
  }

  export type PeopleUpdateOneRequiredWithoutPhoneNumberNestedInput = {
    create?: XOR<PeopleCreateWithoutPhoneNumberInput, PeopleUncheckedCreateWithoutPhoneNumberInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutPhoneNumberInput
    upsert?: PeopleUpsertWithoutPhoneNumberInput
    connect?: PeopleWhereUniqueInput
    update?: XOR<XOR<PeopleUpdateToOneWithWhereWithoutPhoneNumberInput, PeopleUpdateWithoutPhoneNumberInput>, PeopleUncheckedUpdateWithoutPhoneNumberInput>
  }

  export type building_equipmentCreateNestedManyWithoutBuildingInput = {
    create?: XOR<building_equipmentCreateWithoutBuildingInput, building_equipmentUncheckedCreateWithoutBuildingInput> | building_equipmentCreateWithoutBuildingInput[] | building_equipmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutBuildingInput | building_equipmentCreateOrConnectWithoutBuildingInput[]
    createMany?: building_equipmentCreateManyBuildingInputEnvelope
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
  }

  export type roomCreateNestedManyWithoutBuildingInput = {
    create?: XOR<roomCreateWithoutBuildingInput, roomUncheckedCreateWithoutBuildingInput> | roomCreateWithoutBuildingInput[] | roomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: roomCreateOrConnectWithoutBuildingInput | roomCreateOrConnectWithoutBuildingInput[]
    createMany?: roomCreateManyBuildingInputEnvelope
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
  }

  export type building_equipmentUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<building_equipmentCreateWithoutBuildingInput, building_equipmentUncheckedCreateWithoutBuildingInput> | building_equipmentCreateWithoutBuildingInput[] | building_equipmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutBuildingInput | building_equipmentCreateOrConnectWithoutBuildingInput[]
    createMany?: building_equipmentCreateManyBuildingInputEnvelope
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
  }

  export type roomUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<roomCreateWithoutBuildingInput, roomUncheckedCreateWithoutBuildingInput> | roomCreateWithoutBuildingInput[] | roomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: roomCreateOrConnectWithoutBuildingInput | roomCreateOrConnectWithoutBuildingInput[]
    createMany?: roomCreateManyBuildingInputEnvelope
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type building_equipmentUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<building_equipmentCreateWithoutBuildingInput, building_equipmentUncheckedCreateWithoutBuildingInput> | building_equipmentCreateWithoutBuildingInput[] | building_equipmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutBuildingInput | building_equipmentCreateOrConnectWithoutBuildingInput[]
    upsert?: building_equipmentUpsertWithWhereUniqueWithoutBuildingInput | building_equipmentUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: building_equipmentCreateManyBuildingInputEnvelope
    set?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    disconnect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    delete?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    update?: building_equipmentUpdateWithWhereUniqueWithoutBuildingInput | building_equipmentUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: building_equipmentUpdateManyWithWhereWithoutBuildingInput | building_equipmentUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: building_equipmentScalarWhereInput | building_equipmentScalarWhereInput[]
  }

  export type roomUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<roomCreateWithoutBuildingInput, roomUncheckedCreateWithoutBuildingInput> | roomCreateWithoutBuildingInput[] | roomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: roomCreateOrConnectWithoutBuildingInput | roomCreateOrConnectWithoutBuildingInput[]
    upsert?: roomUpsertWithWhereUniqueWithoutBuildingInput | roomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: roomCreateManyBuildingInputEnvelope
    set?: roomWhereUniqueInput | roomWhereUniqueInput[]
    disconnect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    delete?: roomWhereUniqueInput | roomWhereUniqueInput[]
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    update?: roomUpdateWithWhereUniqueWithoutBuildingInput | roomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: roomUpdateManyWithWhereWithoutBuildingInput | roomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: roomScalarWhereInput | roomScalarWhereInput[]
  }

  export type building_equipmentUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<building_equipmentCreateWithoutBuildingInput, building_equipmentUncheckedCreateWithoutBuildingInput> | building_equipmentCreateWithoutBuildingInput[] | building_equipmentUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutBuildingInput | building_equipmentCreateOrConnectWithoutBuildingInput[]
    upsert?: building_equipmentUpsertWithWhereUniqueWithoutBuildingInput | building_equipmentUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: building_equipmentCreateManyBuildingInputEnvelope
    set?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    disconnect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    delete?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    update?: building_equipmentUpdateWithWhereUniqueWithoutBuildingInput | building_equipmentUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: building_equipmentUpdateManyWithWhereWithoutBuildingInput | building_equipmentUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: building_equipmentScalarWhereInput | building_equipmentScalarWhereInput[]
  }

  export type roomUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<roomCreateWithoutBuildingInput, roomUncheckedCreateWithoutBuildingInput> | roomCreateWithoutBuildingInput[] | roomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: roomCreateOrConnectWithoutBuildingInput | roomCreateOrConnectWithoutBuildingInput[]
    upsert?: roomUpsertWithWhereUniqueWithoutBuildingInput | roomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: roomCreateManyBuildingInputEnvelope
    set?: roomWhereUniqueInput | roomWhereUniqueInput[]
    disconnect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    delete?: roomWhereUniqueInput | roomWhereUniqueInput[]
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    update?: roomUpdateWithWhereUniqueWithoutBuildingInput | roomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: roomUpdateManyWithWhereWithoutBuildingInput | roomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: roomScalarWhereInput | roomScalarWhereInput[]
  }

  export type buildingCreateNestedOneWithoutBuilding_equipmentInput = {
    create?: XOR<buildingCreateWithoutBuilding_equipmentInput, buildingUncheckedCreateWithoutBuilding_equipmentInput>
    connectOrCreate?: buildingCreateOrConnectWithoutBuilding_equipmentInput
    connect?: buildingWhereUniqueInput
  }

  export type large_equipmentCreateNestedOneWithoutBuilding_equipmentInput = {
    create?: XOR<large_equipmentCreateWithoutBuilding_equipmentInput, large_equipmentUncheckedCreateWithoutBuilding_equipmentInput>
    connectOrCreate?: large_equipmentCreateOrConnectWithoutBuilding_equipmentInput
    connect?: large_equipmentWhereUniqueInput
  }

  export type buildingUpdateOneRequiredWithoutBuilding_equipmentNestedInput = {
    create?: XOR<buildingCreateWithoutBuilding_equipmentInput, buildingUncheckedCreateWithoutBuilding_equipmentInput>
    connectOrCreate?: buildingCreateOrConnectWithoutBuilding_equipmentInput
    upsert?: buildingUpsertWithoutBuilding_equipmentInput
    connect?: buildingWhereUniqueInput
    update?: XOR<XOR<buildingUpdateToOneWithWhereWithoutBuilding_equipmentInput, buildingUpdateWithoutBuilding_equipmentInput>, buildingUncheckedUpdateWithoutBuilding_equipmentInput>
  }

  export type large_equipmentUpdateOneRequiredWithoutBuilding_equipmentNestedInput = {
    create?: XOR<large_equipmentCreateWithoutBuilding_equipmentInput, large_equipmentUncheckedCreateWithoutBuilding_equipmentInput>
    connectOrCreate?: large_equipmentCreateOrConnectWithoutBuilding_equipmentInput
    upsert?: large_equipmentUpsertWithoutBuilding_equipmentInput
    connect?: large_equipmentWhereUniqueInput
    update?: XOR<XOR<large_equipmentUpdateToOneWithWhereWithoutBuilding_equipmentInput, large_equipmentUpdateWithoutBuilding_equipmentInput>, large_equipmentUncheckedUpdateWithoutBuilding_equipmentInput>
  }

  export type disciplineStaffCreateNestedManyWithoutDisciplinaryActionInput = {
    create?: XOR<disciplineStaffCreateWithoutDisciplinaryActionInput, disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput> | disciplineStaffCreateWithoutDisciplinaryActionInput[] | disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput | disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput[]
    createMany?: disciplineStaffCreateManyDisciplinaryActionInputEnvelope
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
  }

  export type studentDisciplineCreateNestedManyWithoutDisciplinaryActionInput = {
    create?: XOR<studentDisciplineCreateWithoutDisciplinaryActionInput, studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput> | studentDisciplineCreateWithoutDisciplinaryActionInput[] | studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput | studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput[]
    createMany?: studentDisciplineCreateManyDisciplinaryActionInputEnvelope
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
  }

  export type disciplineStaffUncheckedCreateNestedManyWithoutDisciplinaryActionInput = {
    create?: XOR<disciplineStaffCreateWithoutDisciplinaryActionInput, disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput> | disciplineStaffCreateWithoutDisciplinaryActionInput[] | disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput | disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput[]
    createMany?: disciplineStaffCreateManyDisciplinaryActionInputEnvelope
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
  }

  export type studentDisciplineUncheckedCreateNestedManyWithoutDisciplinaryActionInput = {
    create?: XOR<studentDisciplineCreateWithoutDisciplinaryActionInput, studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput> | studentDisciplineCreateWithoutDisciplinaryActionInput[] | studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput | studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput[]
    createMany?: studentDisciplineCreateManyDisciplinaryActionInputEnvelope
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
  }

  export type disciplineStaffUpdateManyWithoutDisciplinaryActionNestedInput = {
    create?: XOR<disciplineStaffCreateWithoutDisciplinaryActionInput, disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput> | disciplineStaffCreateWithoutDisciplinaryActionInput[] | disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput | disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput[]
    upsert?: disciplineStaffUpsertWithWhereUniqueWithoutDisciplinaryActionInput | disciplineStaffUpsertWithWhereUniqueWithoutDisciplinaryActionInput[]
    createMany?: disciplineStaffCreateManyDisciplinaryActionInputEnvelope
    set?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    disconnect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    delete?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    update?: disciplineStaffUpdateWithWhereUniqueWithoutDisciplinaryActionInput | disciplineStaffUpdateWithWhereUniqueWithoutDisciplinaryActionInput[]
    updateMany?: disciplineStaffUpdateManyWithWhereWithoutDisciplinaryActionInput | disciplineStaffUpdateManyWithWhereWithoutDisciplinaryActionInput[]
    deleteMany?: disciplineStaffScalarWhereInput | disciplineStaffScalarWhereInput[]
  }

  export type studentDisciplineUpdateManyWithoutDisciplinaryActionNestedInput = {
    create?: XOR<studentDisciplineCreateWithoutDisciplinaryActionInput, studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput> | studentDisciplineCreateWithoutDisciplinaryActionInput[] | studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput | studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput[]
    upsert?: studentDisciplineUpsertWithWhereUniqueWithoutDisciplinaryActionInput | studentDisciplineUpsertWithWhereUniqueWithoutDisciplinaryActionInput[]
    createMany?: studentDisciplineCreateManyDisciplinaryActionInputEnvelope
    set?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    disconnect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    delete?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    update?: studentDisciplineUpdateWithWhereUniqueWithoutDisciplinaryActionInput | studentDisciplineUpdateWithWhereUniqueWithoutDisciplinaryActionInput[]
    updateMany?: studentDisciplineUpdateManyWithWhereWithoutDisciplinaryActionInput | studentDisciplineUpdateManyWithWhereWithoutDisciplinaryActionInput[]
    deleteMany?: studentDisciplineScalarWhereInput | studentDisciplineScalarWhereInput[]
  }

  export type disciplineStaffUncheckedUpdateManyWithoutDisciplinaryActionNestedInput = {
    create?: XOR<disciplineStaffCreateWithoutDisciplinaryActionInput, disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput> | disciplineStaffCreateWithoutDisciplinaryActionInput[] | disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput | disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput[]
    upsert?: disciplineStaffUpsertWithWhereUniqueWithoutDisciplinaryActionInput | disciplineStaffUpsertWithWhereUniqueWithoutDisciplinaryActionInput[]
    createMany?: disciplineStaffCreateManyDisciplinaryActionInputEnvelope
    set?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    disconnect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    delete?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    update?: disciplineStaffUpdateWithWhereUniqueWithoutDisciplinaryActionInput | disciplineStaffUpdateWithWhereUniqueWithoutDisciplinaryActionInput[]
    updateMany?: disciplineStaffUpdateManyWithWhereWithoutDisciplinaryActionInput | disciplineStaffUpdateManyWithWhereWithoutDisciplinaryActionInput[]
    deleteMany?: disciplineStaffScalarWhereInput | disciplineStaffScalarWhereInput[]
  }

  export type studentDisciplineUncheckedUpdateManyWithoutDisciplinaryActionNestedInput = {
    create?: XOR<studentDisciplineCreateWithoutDisciplinaryActionInput, studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput> | studentDisciplineCreateWithoutDisciplinaryActionInput[] | studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput | studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput[]
    upsert?: studentDisciplineUpsertWithWhereUniqueWithoutDisciplinaryActionInput | studentDisciplineUpsertWithWhereUniqueWithoutDisciplinaryActionInput[]
    createMany?: studentDisciplineCreateManyDisciplinaryActionInputEnvelope
    set?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    disconnect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    delete?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    update?: studentDisciplineUpdateWithWhereUniqueWithoutDisciplinaryActionInput | studentDisciplineUpdateWithWhereUniqueWithoutDisciplinaryActionInput[]
    updateMany?: studentDisciplineUpdateManyWithWhereWithoutDisciplinaryActionInput | studentDisciplineUpdateManyWithWhereWithoutDisciplinaryActionInput[]
    deleteMany?: studentDisciplineScalarWhereInput | studentDisciplineScalarWhereInput[]
  }

  export type disciplinaryActionCreateNestedOneWithoutDisciplineStaffInput = {
    create?: XOR<disciplinaryActionCreateWithoutDisciplineStaffInput, disciplinaryActionUncheckedCreateWithoutDisciplineStaffInput>
    connectOrCreate?: disciplinaryActionCreateOrConnectWithoutDisciplineStaffInput
    connect?: disciplinaryActionWhereUniqueInput
  }

  export type manager_employeeCreateNestedOneWithoutDisciplineStaffInput = {
    create?: XOR<manager_employeeCreateWithoutDisciplineStaffInput, manager_employeeUncheckedCreateWithoutDisciplineStaffInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutDisciplineStaffInput
    connect?: manager_employeeWhereUniqueInput
  }

  export type disciplinaryActionUpdateOneRequiredWithoutDisciplineStaffNestedInput = {
    create?: XOR<disciplinaryActionCreateWithoutDisciplineStaffInput, disciplinaryActionUncheckedCreateWithoutDisciplineStaffInput>
    connectOrCreate?: disciplinaryActionCreateOrConnectWithoutDisciplineStaffInput
    upsert?: disciplinaryActionUpsertWithoutDisciplineStaffInput
    connect?: disciplinaryActionWhereUniqueInput
    update?: XOR<XOR<disciplinaryActionUpdateToOneWithWhereWithoutDisciplineStaffInput, disciplinaryActionUpdateWithoutDisciplineStaffInput>, disciplinaryActionUncheckedUpdateWithoutDisciplineStaffInput>
  }

  export type manager_employeeUpdateOneRequiredWithoutDisciplineStaffNestedInput = {
    create?: XOR<manager_employeeCreateWithoutDisciplineStaffInput, manager_employeeUncheckedCreateWithoutDisciplineStaffInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutDisciplineStaffInput
    upsert?: manager_employeeUpsertWithoutDisciplineStaffInput
    connect?: manager_employeeWhereUniqueInput
    update?: XOR<XOR<manager_employeeUpdateToOneWithWhereWithoutDisciplineStaffInput, manager_employeeUpdateWithoutDisciplineStaffInput>, manager_employeeUncheckedUpdateWithoutDisciplineStaffInput>
  }

  export type Employee_CardCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Employee_CardCreateWithoutEmployeeInput, Employee_CardUncheckedCreateWithoutEmployeeInput> | Employee_CardCreateWithoutEmployeeInput[] | Employee_CardUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: Employee_CardCreateOrConnectWithoutEmployeeInput | Employee_CardCreateOrConnectWithoutEmployeeInput[]
    createMany?: Employee_CardCreateManyEmployeeInputEnvelope
    connect?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
  }

  export type PeopleCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<PeopleCreateWithoutEmployeeInput, PeopleUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutEmployeeInput
    connect?: PeopleWhereUniqueInput
  }

  export type manager_employeeCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<manager_employeeCreateWithoutEmployeeInput, manager_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutEmployeeInput
    connect?: manager_employeeWhereUniqueInput
  }

  export type medical_employeeCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<medical_employeeCreateWithoutEmployeeInput, medical_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: medical_employeeCreateOrConnectWithoutEmployeeInput
    connect?: medical_employeeWhereUniqueInput
  }

  export type other_employeeCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<other_employeeCreateWithoutEmployeeInput, other_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: other_employeeCreateOrConnectWithoutEmployeeInput
    connect?: other_employeeWhereUniqueInput
  }

  export type Employee_CardUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Employee_CardCreateWithoutEmployeeInput, Employee_CardUncheckedCreateWithoutEmployeeInput> | Employee_CardCreateWithoutEmployeeInput[] | Employee_CardUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: Employee_CardCreateOrConnectWithoutEmployeeInput | Employee_CardCreateOrConnectWithoutEmployeeInput[]
    createMany?: Employee_CardCreateManyEmployeeInputEnvelope
    connect?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
  }

  export type manager_employeeUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<manager_employeeCreateWithoutEmployeeInput, manager_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutEmployeeInput
    connect?: manager_employeeWhereUniqueInput
  }

  export type medical_employeeUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<medical_employeeCreateWithoutEmployeeInput, medical_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: medical_employeeCreateOrConnectWithoutEmployeeInput
    connect?: medical_employeeWhereUniqueInput
  }

  export type other_employeeUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<other_employeeCreateWithoutEmployeeInput, other_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: other_employeeCreateOrConnectWithoutEmployeeInput
    connect?: other_employeeWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Employee_CardUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<Employee_CardCreateWithoutEmployeeInput, Employee_CardUncheckedCreateWithoutEmployeeInput> | Employee_CardCreateWithoutEmployeeInput[] | Employee_CardUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: Employee_CardCreateOrConnectWithoutEmployeeInput | Employee_CardCreateOrConnectWithoutEmployeeInput[]
    upsert?: Employee_CardUpsertWithWhereUniqueWithoutEmployeeInput | Employee_CardUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: Employee_CardCreateManyEmployeeInputEnvelope
    set?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    disconnect?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    delete?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    connect?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    update?: Employee_CardUpdateWithWhereUniqueWithoutEmployeeInput | Employee_CardUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: Employee_CardUpdateManyWithWhereWithoutEmployeeInput | Employee_CardUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: Employee_CardScalarWhereInput | Employee_CardScalarWhereInput[]
  }

  export type PeopleUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<PeopleCreateWithoutEmployeeInput, PeopleUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutEmployeeInput
    upsert?: PeopleUpsertWithoutEmployeeInput
    connect?: PeopleWhereUniqueInput
    update?: XOR<XOR<PeopleUpdateToOneWithWhereWithoutEmployeeInput, PeopleUpdateWithoutEmployeeInput>, PeopleUncheckedUpdateWithoutEmployeeInput>
  }

  export type manager_employeeUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<manager_employeeCreateWithoutEmployeeInput, manager_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutEmployeeInput
    upsert?: manager_employeeUpsertWithoutEmployeeInput
    disconnect?: manager_employeeWhereInput | boolean
    delete?: manager_employeeWhereInput | boolean
    connect?: manager_employeeWhereUniqueInput
    update?: XOR<XOR<manager_employeeUpdateToOneWithWhereWithoutEmployeeInput, manager_employeeUpdateWithoutEmployeeInput>, manager_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type medical_employeeUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<medical_employeeCreateWithoutEmployeeInput, medical_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: medical_employeeCreateOrConnectWithoutEmployeeInput
    upsert?: medical_employeeUpsertWithoutEmployeeInput
    disconnect?: medical_employeeWhereInput | boolean
    delete?: medical_employeeWhereInput | boolean
    connect?: medical_employeeWhereUniqueInput
    update?: XOR<XOR<medical_employeeUpdateToOneWithWhereWithoutEmployeeInput, medical_employeeUpdateWithoutEmployeeInput>, medical_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type other_employeeUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<other_employeeCreateWithoutEmployeeInput, other_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: other_employeeCreateOrConnectWithoutEmployeeInput
    upsert?: other_employeeUpsertWithoutEmployeeInput
    disconnect?: other_employeeWhereInput | boolean
    delete?: other_employeeWhereInput | boolean
    connect?: other_employeeWhereUniqueInput
    update?: XOR<XOR<other_employeeUpdateToOneWithWhereWithoutEmployeeInput, other_employeeUpdateWithoutEmployeeInput>, other_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type Employee_CardUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<Employee_CardCreateWithoutEmployeeInput, Employee_CardUncheckedCreateWithoutEmployeeInput> | Employee_CardCreateWithoutEmployeeInput[] | Employee_CardUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: Employee_CardCreateOrConnectWithoutEmployeeInput | Employee_CardCreateOrConnectWithoutEmployeeInput[]
    upsert?: Employee_CardUpsertWithWhereUniqueWithoutEmployeeInput | Employee_CardUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: Employee_CardCreateManyEmployeeInputEnvelope
    set?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    disconnect?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    delete?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    connect?: Employee_CardWhereUniqueInput | Employee_CardWhereUniqueInput[]
    update?: Employee_CardUpdateWithWhereUniqueWithoutEmployeeInput | Employee_CardUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: Employee_CardUpdateManyWithWhereWithoutEmployeeInput | Employee_CardUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: Employee_CardScalarWhereInput | Employee_CardScalarWhereInput[]
  }

  export type manager_employeeUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<manager_employeeCreateWithoutEmployeeInput, manager_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutEmployeeInput
    upsert?: manager_employeeUpsertWithoutEmployeeInput
    disconnect?: manager_employeeWhereInput | boolean
    delete?: manager_employeeWhereInput | boolean
    connect?: manager_employeeWhereUniqueInput
    update?: XOR<XOR<manager_employeeUpdateToOneWithWhereWithoutEmployeeInput, manager_employeeUpdateWithoutEmployeeInput>, manager_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type medical_employeeUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<medical_employeeCreateWithoutEmployeeInput, medical_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: medical_employeeCreateOrConnectWithoutEmployeeInput
    upsert?: medical_employeeUpsertWithoutEmployeeInput
    disconnect?: medical_employeeWhereInput | boolean
    delete?: medical_employeeWhereInput | boolean
    connect?: medical_employeeWhereUniqueInput
    update?: XOR<XOR<medical_employeeUpdateToOneWithWhereWithoutEmployeeInput, medical_employeeUpdateWithoutEmployeeInput>, medical_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type other_employeeUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<other_employeeCreateWithoutEmployeeInput, other_employeeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: other_employeeCreateOrConnectWithoutEmployeeInput
    upsert?: other_employeeUpsertWithoutEmployeeInput
    disconnect?: other_employeeWhereInput | boolean
    delete?: other_employeeWhereInput | boolean
    connect?: other_employeeWhereUniqueInput
    update?: XOR<XOR<other_employeeUpdateToOneWithWhereWithoutEmployeeInput, other_employeeUpdateWithoutEmployeeInput>, other_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type roomCreateNestedOneWithoutHealth_roomInput = {
    create?: XOR<roomCreateWithoutHealth_roomInput, roomUncheckedCreateWithoutHealth_roomInput>
    connectOrCreate?: roomCreateOrConnectWithoutHealth_roomInput
    connect?: roomWhereUniqueInput
  }

  export type medical_employeeCreateNestedManyWithoutHealth_roomInput = {
    create?: XOR<medical_employeeCreateWithoutHealth_roomInput, medical_employeeUncheckedCreateWithoutHealth_roomInput> | medical_employeeCreateWithoutHealth_roomInput[] | medical_employeeUncheckedCreateWithoutHealth_roomInput[]
    connectOrCreate?: medical_employeeCreateOrConnectWithoutHealth_roomInput | medical_employeeCreateOrConnectWithoutHealth_roomInput[]
    createMany?: medical_employeeCreateManyHealth_roomInputEnvelope
    connect?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
  }

  export type medical_employeeUncheckedCreateNestedManyWithoutHealth_roomInput = {
    create?: XOR<medical_employeeCreateWithoutHealth_roomInput, medical_employeeUncheckedCreateWithoutHealth_roomInput> | medical_employeeCreateWithoutHealth_roomInput[] | medical_employeeUncheckedCreateWithoutHealth_roomInput[]
    connectOrCreate?: medical_employeeCreateOrConnectWithoutHealth_roomInput | medical_employeeCreateOrConnectWithoutHealth_roomInput[]
    createMany?: medical_employeeCreateManyHealth_roomInputEnvelope
    connect?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
  }

  export type Enumhealth_room_equipment_statusFieldUpdateOperationsInput = {
    set?: $Enums.health_room_equipment_status
  }

  export type roomUpdateOneRequiredWithoutHealth_roomNestedInput = {
    create?: XOR<roomCreateWithoutHealth_roomInput, roomUncheckedCreateWithoutHealth_roomInput>
    connectOrCreate?: roomCreateOrConnectWithoutHealth_roomInput
    upsert?: roomUpsertWithoutHealth_roomInput
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutHealth_roomInput, roomUpdateWithoutHealth_roomInput>, roomUncheckedUpdateWithoutHealth_roomInput>
  }

  export type medical_employeeUpdateManyWithoutHealth_roomNestedInput = {
    create?: XOR<medical_employeeCreateWithoutHealth_roomInput, medical_employeeUncheckedCreateWithoutHealth_roomInput> | medical_employeeCreateWithoutHealth_roomInput[] | medical_employeeUncheckedCreateWithoutHealth_roomInput[]
    connectOrCreate?: medical_employeeCreateOrConnectWithoutHealth_roomInput | medical_employeeCreateOrConnectWithoutHealth_roomInput[]
    upsert?: medical_employeeUpsertWithWhereUniqueWithoutHealth_roomInput | medical_employeeUpsertWithWhereUniqueWithoutHealth_roomInput[]
    createMany?: medical_employeeCreateManyHealth_roomInputEnvelope
    set?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    disconnect?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    delete?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    connect?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    update?: medical_employeeUpdateWithWhereUniqueWithoutHealth_roomInput | medical_employeeUpdateWithWhereUniqueWithoutHealth_roomInput[]
    updateMany?: medical_employeeUpdateManyWithWhereWithoutHealth_roomInput | medical_employeeUpdateManyWithWhereWithoutHealth_roomInput[]
    deleteMany?: medical_employeeScalarWhereInput | medical_employeeScalarWhereInput[]
  }

  export type medical_employeeUncheckedUpdateManyWithoutHealth_roomNestedInput = {
    create?: XOR<medical_employeeCreateWithoutHealth_roomInput, medical_employeeUncheckedCreateWithoutHealth_roomInput> | medical_employeeCreateWithoutHealth_roomInput[] | medical_employeeUncheckedCreateWithoutHealth_roomInput[]
    connectOrCreate?: medical_employeeCreateOrConnectWithoutHealth_roomInput | medical_employeeCreateOrConnectWithoutHealth_roomInput[]
    upsert?: medical_employeeUpsertWithWhereUniqueWithoutHealth_roomInput | medical_employeeUpsertWithWhereUniqueWithoutHealth_roomInput[]
    createMany?: medical_employeeCreateManyHealth_roomInputEnvelope
    set?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    disconnect?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    delete?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    connect?: medical_employeeWhereUniqueInput | medical_employeeWhereUniqueInput[]
    update?: medical_employeeUpdateWithWhereUniqueWithoutHealth_roomInput | medical_employeeUpdateWithWhereUniqueWithoutHealth_roomInput[]
    updateMany?: medical_employeeUpdateManyWithWhereWithoutHealth_roomInput | medical_employeeUpdateManyWithWhereWithoutHealth_roomInput[]
    deleteMany?: medical_employeeScalarWhereInput | medical_employeeScalarWhereInput[]
  }

  export type building_equipmentCreateNestedManyWithoutLarge_equipmentInput = {
    create?: XOR<building_equipmentCreateWithoutLarge_equipmentInput, building_equipmentUncheckedCreateWithoutLarge_equipmentInput> | building_equipmentCreateWithoutLarge_equipmentInput[] | building_equipmentUncheckedCreateWithoutLarge_equipmentInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutLarge_equipmentInput | building_equipmentCreateOrConnectWithoutLarge_equipmentInput[]
    createMany?: building_equipmentCreateManyLarge_equipmentInputEnvelope
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
  }

  export type building_equipmentUncheckedCreateNestedManyWithoutLarge_equipmentInput = {
    create?: XOR<building_equipmentCreateWithoutLarge_equipmentInput, building_equipmentUncheckedCreateWithoutLarge_equipmentInput> | building_equipmentCreateWithoutLarge_equipmentInput[] | building_equipmentUncheckedCreateWithoutLarge_equipmentInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutLarge_equipmentInput | building_equipmentCreateOrConnectWithoutLarge_equipmentInput[]
    createMany?: building_equipmentCreateManyLarge_equipmentInputEnvelope
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
  }

  export type Enumlarge_equipment_equipment_statusFieldUpdateOperationsInput = {
    set?: $Enums.large_equipment_equipment_status
  }

  export type building_equipmentUpdateManyWithoutLarge_equipmentNestedInput = {
    create?: XOR<building_equipmentCreateWithoutLarge_equipmentInput, building_equipmentUncheckedCreateWithoutLarge_equipmentInput> | building_equipmentCreateWithoutLarge_equipmentInput[] | building_equipmentUncheckedCreateWithoutLarge_equipmentInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutLarge_equipmentInput | building_equipmentCreateOrConnectWithoutLarge_equipmentInput[]
    upsert?: building_equipmentUpsertWithWhereUniqueWithoutLarge_equipmentInput | building_equipmentUpsertWithWhereUniqueWithoutLarge_equipmentInput[]
    createMany?: building_equipmentCreateManyLarge_equipmentInputEnvelope
    set?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    disconnect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    delete?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    update?: building_equipmentUpdateWithWhereUniqueWithoutLarge_equipmentInput | building_equipmentUpdateWithWhereUniqueWithoutLarge_equipmentInput[]
    updateMany?: building_equipmentUpdateManyWithWhereWithoutLarge_equipmentInput | building_equipmentUpdateManyWithWhereWithoutLarge_equipmentInput[]
    deleteMany?: building_equipmentScalarWhereInput | building_equipmentScalarWhereInput[]
  }

  export type building_equipmentUncheckedUpdateManyWithoutLarge_equipmentNestedInput = {
    create?: XOR<building_equipmentCreateWithoutLarge_equipmentInput, building_equipmentUncheckedCreateWithoutLarge_equipmentInput> | building_equipmentCreateWithoutLarge_equipmentInput[] | building_equipmentUncheckedCreateWithoutLarge_equipmentInput[]
    connectOrCreate?: building_equipmentCreateOrConnectWithoutLarge_equipmentInput | building_equipmentCreateOrConnectWithoutLarge_equipmentInput[]
    upsert?: building_equipmentUpsertWithWhereUniqueWithoutLarge_equipmentInput | building_equipmentUpsertWithWhereUniqueWithoutLarge_equipmentInput[]
    createMany?: building_equipmentCreateManyLarge_equipmentInputEnvelope
    set?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    disconnect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    delete?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    connect?: building_equipmentWhereUniqueInput | building_equipmentWhereUniqueInput[]
    update?: building_equipmentUpdateWithWhereUniqueWithoutLarge_equipmentInput | building_equipmentUpdateWithWhereUniqueWithoutLarge_equipmentInput[]
    updateMany?: building_equipmentUpdateManyWithWhereWithoutLarge_equipmentInput | building_equipmentUpdateManyWithWhereWithoutLarge_equipmentInput[]
    deleteMany?: building_equipmentScalarWhereInput | building_equipmentScalarWhereInput[]
  }

  export type studentCreateNestedManyWithoutLiving_roomInput = {
    create?: XOR<studentCreateWithoutLiving_roomInput, studentUncheckedCreateWithoutLiving_roomInput> | studentCreateWithoutLiving_roomInput[] | studentUncheckedCreateWithoutLiving_roomInput[]
    connectOrCreate?: studentCreateOrConnectWithoutLiving_roomInput | studentCreateOrConnectWithoutLiving_roomInput[]
    createMany?: studentCreateManyLiving_roomInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type studentUncheckedCreateNestedManyWithoutLiving_roomInput = {
    create?: XOR<studentCreateWithoutLiving_roomInput, studentUncheckedCreateWithoutLiving_roomInput> | studentCreateWithoutLiving_roomInput[] | studentUncheckedCreateWithoutLiving_roomInput[]
    connectOrCreate?: studentCreateOrConnectWithoutLiving_roomInput | studentCreateOrConnectWithoutLiving_roomInput[]
    createMany?: studentCreateManyLiving_roomInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type studentUpdateManyWithoutLiving_roomNestedInput = {
    create?: XOR<studentCreateWithoutLiving_roomInput, studentUncheckedCreateWithoutLiving_roomInput> | studentCreateWithoutLiving_roomInput[] | studentUncheckedCreateWithoutLiving_roomInput[]
    connectOrCreate?: studentCreateOrConnectWithoutLiving_roomInput | studentCreateOrConnectWithoutLiving_roomInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutLiving_roomInput | studentUpsertWithWhereUniqueWithoutLiving_roomInput[]
    createMany?: studentCreateManyLiving_roomInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutLiving_roomInput | studentUpdateWithWhereUniqueWithoutLiving_roomInput[]
    updateMany?: studentUpdateManyWithWhereWithoutLiving_roomInput | studentUpdateManyWithWhereWithoutLiving_roomInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type studentUncheckedUpdateManyWithoutLiving_roomNestedInput = {
    create?: XOR<studentCreateWithoutLiving_roomInput, studentUncheckedCreateWithoutLiving_roomInput> | studentCreateWithoutLiving_roomInput[] | studentUncheckedCreateWithoutLiving_roomInput[]
    connectOrCreate?: studentCreateOrConnectWithoutLiving_roomInput | studentCreateOrConnectWithoutLiving_roomInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutLiving_roomInput | studentUpsertWithWhereUniqueWithoutLiving_roomInput[]
    createMany?: studentCreateManyLiving_roomInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutLiving_roomInput | studentUpdateWithWhereUniqueWithoutLiving_roomInput[]
    updateMany?: studentUpdateManyWithWhereWithoutLiving_roomInput | studentUpdateManyWithWhereWithoutLiving_roomInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type roomCreateNestedOneWithoutManagement_roomInput = {
    create?: XOR<roomCreateWithoutManagement_roomInput, roomUncheckedCreateWithoutManagement_roomInput>
    connectOrCreate?: roomCreateOrConnectWithoutManagement_roomInput
    connect?: roomWhereUniqueInput
  }

  export type manager_employeeCreateNestedManyWithoutManagement_roomInput = {
    create?: XOR<manager_employeeCreateWithoutManagement_roomInput, manager_employeeUncheckedCreateWithoutManagement_roomInput> | manager_employeeCreateWithoutManagement_roomInput[] | manager_employeeUncheckedCreateWithoutManagement_roomInput[]
    connectOrCreate?: manager_employeeCreateOrConnectWithoutManagement_roomInput | manager_employeeCreateOrConnectWithoutManagement_roomInput[]
    createMany?: manager_employeeCreateManyManagement_roomInputEnvelope
    connect?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
  }

  export type manager_employeeUncheckedCreateNestedManyWithoutManagement_roomInput = {
    create?: XOR<manager_employeeCreateWithoutManagement_roomInput, manager_employeeUncheckedCreateWithoutManagement_roomInput> | manager_employeeCreateWithoutManagement_roomInput[] | manager_employeeUncheckedCreateWithoutManagement_roomInput[]
    connectOrCreate?: manager_employeeCreateOrConnectWithoutManagement_roomInput | manager_employeeCreateOrConnectWithoutManagement_roomInput[]
    createMany?: manager_employeeCreateManyManagement_roomInputEnvelope
    connect?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
  }

  export type roomUpdateOneRequiredWithoutManagement_roomNestedInput = {
    create?: XOR<roomCreateWithoutManagement_roomInput, roomUncheckedCreateWithoutManagement_roomInput>
    connectOrCreate?: roomCreateOrConnectWithoutManagement_roomInput
    upsert?: roomUpsertWithoutManagement_roomInput
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutManagement_roomInput, roomUpdateWithoutManagement_roomInput>, roomUncheckedUpdateWithoutManagement_roomInput>
  }

  export type manager_employeeUpdateManyWithoutManagement_roomNestedInput = {
    create?: XOR<manager_employeeCreateWithoutManagement_roomInput, manager_employeeUncheckedCreateWithoutManagement_roomInput> | manager_employeeCreateWithoutManagement_roomInput[] | manager_employeeUncheckedCreateWithoutManagement_roomInput[]
    connectOrCreate?: manager_employeeCreateOrConnectWithoutManagement_roomInput | manager_employeeCreateOrConnectWithoutManagement_roomInput[]
    upsert?: manager_employeeUpsertWithWhereUniqueWithoutManagement_roomInput | manager_employeeUpsertWithWhereUniqueWithoutManagement_roomInput[]
    createMany?: manager_employeeCreateManyManagement_roomInputEnvelope
    set?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    disconnect?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    delete?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    connect?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    update?: manager_employeeUpdateWithWhereUniqueWithoutManagement_roomInput | manager_employeeUpdateWithWhereUniqueWithoutManagement_roomInput[]
    updateMany?: manager_employeeUpdateManyWithWhereWithoutManagement_roomInput | manager_employeeUpdateManyWithWhereWithoutManagement_roomInput[]
    deleteMany?: manager_employeeScalarWhereInput | manager_employeeScalarWhereInput[]
  }

  export type manager_employeeUncheckedUpdateManyWithoutManagement_roomNestedInput = {
    create?: XOR<manager_employeeCreateWithoutManagement_roomInput, manager_employeeUncheckedCreateWithoutManagement_roomInput> | manager_employeeCreateWithoutManagement_roomInput[] | manager_employeeUncheckedCreateWithoutManagement_roomInput[]
    connectOrCreate?: manager_employeeCreateOrConnectWithoutManagement_roomInput | manager_employeeCreateOrConnectWithoutManagement_roomInput[]
    upsert?: manager_employeeUpsertWithWhereUniqueWithoutManagement_roomInput | manager_employeeUpsertWithWhereUniqueWithoutManagement_roomInput[]
    createMany?: manager_employeeCreateManyManagement_roomInputEnvelope
    set?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    disconnect?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    delete?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    connect?: manager_employeeWhereUniqueInput | manager_employeeWhereUniqueInput[]
    update?: manager_employeeUpdateWithWhereUniqueWithoutManagement_roomInput | manager_employeeUpdateWithWhereUniqueWithoutManagement_roomInput[]
    updateMany?: manager_employeeUpdateManyWithWhereWithoutManagement_roomInput | manager_employeeUpdateManyWithWhereWithoutManagement_roomInput[]
    deleteMany?: manager_employeeScalarWhereInput | manager_employeeScalarWhereInput[]
  }

  export type manager_employeeCreateNestedOneWithoutManager_degreeInput = {
    create?: XOR<manager_employeeCreateWithoutManager_degreeInput, manager_employeeUncheckedCreateWithoutManager_degreeInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutManager_degreeInput
    connect?: manager_employeeWhereUniqueInput
  }

  export type manager_employeeUpdateOneRequiredWithoutManager_degreeNestedInput = {
    create?: XOR<manager_employeeCreateWithoutManager_degreeInput, manager_employeeUncheckedCreateWithoutManager_degreeInput>
    connectOrCreate?: manager_employeeCreateOrConnectWithoutManager_degreeInput
    upsert?: manager_employeeUpsertWithoutManager_degreeInput
    connect?: manager_employeeWhereUniqueInput
    update?: XOR<XOR<manager_employeeUpdateToOneWithWhereWithoutManager_degreeInput, manager_employeeUpdateWithoutManager_degreeInput>, manager_employeeUncheckedUpdateWithoutManager_degreeInput>
  }

  export type disciplineStaffCreateNestedManyWithoutManager_employeeInput = {
    create?: XOR<disciplineStaffCreateWithoutManager_employeeInput, disciplineStaffUncheckedCreateWithoutManager_employeeInput> | disciplineStaffCreateWithoutManager_employeeInput[] | disciplineStaffUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutManager_employeeInput | disciplineStaffCreateOrConnectWithoutManager_employeeInput[]
    createMany?: disciplineStaffCreateManyManager_employeeInputEnvelope
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
  }

  export type manager_degreeCreateNestedManyWithoutManager_employeeInput = {
    create?: XOR<manager_degreeCreateWithoutManager_employeeInput, manager_degreeUncheckedCreateWithoutManager_employeeInput> | manager_degreeCreateWithoutManager_employeeInput[] | manager_degreeUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: manager_degreeCreateOrConnectWithoutManager_employeeInput | manager_degreeCreateOrConnectWithoutManager_employeeInput[]
    createMany?: manager_degreeCreateManyManager_employeeInputEnvelope
    connect?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
  }

  export type management_roomCreateNestedOneWithoutManager_employeeInput = {
    create?: XOR<management_roomCreateWithoutManager_employeeInput, management_roomUncheckedCreateWithoutManager_employeeInput>
    connectOrCreate?: management_roomCreateOrConnectWithoutManager_employeeInput
    connect?: management_roomWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutManager_employeeInput = {
    create?: XOR<employeeCreateWithoutManager_employeeInput, employeeUncheckedCreateWithoutManager_employeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutManager_employeeInput
    connect?: employeeWhereUniqueInput
  }

  export type disciplineStaffUncheckedCreateNestedManyWithoutManager_employeeInput = {
    create?: XOR<disciplineStaffCreateWithoutManager_employeeInput, disciplineStaffUncheckedCreateWithoutManager_employeeInput> | disciplineStaffCreateWithoutManager_employeeInput[] | disciplineStaffUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutManager_employeeInput | disciplineStaffCreateOrConnectWithoutManager_employeeInput[]
    createMany?: disciplineStaffCreateManyManager_employeeInputEnvelope
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
  }

  export type manager_degreeUncheckedCreateNestedManyWithoutManager_employeeInput = {
    create?: XOR<manager_degreeCreateWithoutManager_employeeInput, manager_degreeUncheckedCreateWithoutManager_employeeInput> | manager_degreeCreateWithoutManager_employeeInput[] | manager_degreeUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: manager_degreeCreateOrConnectWithoutManager_employeeInput | manager_degreeCreateOrConnectWithoutManager_employeeInput[]
    createMany?: manager_degreeCreateManyManager_employeeInputEnvelope
    connect?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
  }

  export type disciplineStaffUpdateManyWithoutManager_employeeNestedInput = {
    create?: XOR<disciplineStaffCreateWithoutManager_employeeInput, disciplineStaffUncheckedCreateWithoutManager_employeeInput> | disciplineStaffCreateWithoutManager_employeeInput[] | disciplineStaffUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutManager_employeeInput | disciplineStaffCreateOrConnectWithoutManager_employeeInput[]
    upsert?: disciplineStaffUpsertWithWhereUniqueWithoutManager_employeeInput | disciplineStaffUpsertWithWhereUniqueWithoutManager_employeeInput[]
    createMany?: disciplineStaffCreateManyManager_employeeInputEnvelope
    set?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    disconnect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    delete?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    update?: disciplineStaffUpdateWithWhereUniqueWithoutManager_employeeInput | disciplineStaffUpdateWithWhereUniqueWithoutManager_employeeInput[]
    updateMany?: disciplineStaffUpdateManyWithWhereWithoutManager_employeeInput | disciplineStaffUpdateManyWithWhereWithoutManager_employeeInput[]
    deleteMany?: disciplineStaffScalarWhereInput | disciplineStaffScalarWhereInput[]
  }

  export type manager_degreeUpdateManyWithoutManager_employeeNestedInput = {
    create?: XOR<manager_degreeCreateWithoutManager_employeeInput, manager_degreeUncheckedCreateWithoutManager_employeeInput> | manager_degreeCreateWithoutManager_employeeInput[] | manager_degreeUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: manager_degreeCreateOrConnectWithoutManager_employeeInput | manager_degreeCreateOrConnectWithoutManager_employeeInput[]
    upsert?: manager_degreeUpsertWithWhereUniqueWithoutManager_employeeInput | manager_degreeUpsertWithWhereUniqueWithoutManager_employeeInput[]
    createMany?: manager_degreeCreateManyManager_employeeInputEnvelope
    set?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    disconnect?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    delete?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    connect?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    update?: manager_degreeUpdateWithWhereUniqueWithoutManager_employeeInput | manager_degreeUpdateWithWhereUniqueWithoutManager_employeeInput[]
    updateMany?: manager_degreeUpdateManyWithWhereWithoutManager_employeeInput | manager_degreeUpdateManyWithWhereWithoutManager_employeeInput[]
    deleteMany?: manager_degreeScalarWhereInput | manager_degreeScalarWhereInput[]
  }

  export type management_roomUpdateOneWithoutManager_employeeNestedInput = {
    create?: XOR<management_roomCreateWithoutManager_employeeInput, management_roomUncheckedCreateWithoutManager_employeeInput>
    connectOrCreate?: management_roomCreateOrConnectWithoutManager_employeeInput
    upsert?: management_roomUpsertWithoutManager_employeeInput
    disconnect?: management_roomWhereInput | boolean
    delete?: management_roomWhereInput | boolean
    connect?: management_roomWhereUniqueInput
    update?: XOR<XOR<management_roomUpdateToOneWithWhereWithoutManager_employeeInput, management_roomUpdateWithoutManager_employeeInput>, management_roomUncheckedUpdateWithoutManager_employeeInput>
  }

  export type employeeUpdateOneRequiredWithoutManager_employeeNestedInput = {
    create?: XOR<employeeCreateWithoutManager_employeeInput, employeeUncheckedCreateWithoutManager_employeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutManager_employeeInput
    upsert?: employeeUpsertWithoutManager_employeeInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutManager_employeeInput, employeeUpdateWithoutManager_employeeInput>, employeeUncheckedUpdateWithoutManager_employeeInput>
  }

  export type disciplineStaffUncheckedUpdateManyWithoutManager_employeeNestedInput = {
    create?: XOR<disciplineStaffCreateWithoutManager_employeeInput, disciplineStaffUncheckedCreateWithoutManager_employeeInput> | disciplineStaffCreateWithoutManager_employeeInput[] | disciplineStaffUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: disciplineStaffCreateOrConnectWithoutManager_employeeInput | disciplineStaffCreateOrConnectWithoutManager_employeeInput[]
    upsert?: disciplineStaffUpsertWithWhereUniqueWithoutManager_employeeInput | disciplineStaffUpsertWithWhereUniqueWithoutManager_employeeInput[]
    createMany?: disciplineStaffCreateManyManager_employeeInputEnvelope
    set?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    disconnect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    delete?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    connect?: disciplineStaffWhereUniqueInput | disciplineStaffWhereUniqueInput[]
    update?: disciplineStaffUpdateWithWhereUniqueWithoutManager_employeeInput | disciplineStaffUpdateWithWhereUniqueWithoutManager_employeeInput[]
    updateMany?: disciplineStaffUpdateManyWithWhereWithoutManager_employeeInput | disciplineStaffUpdateManyWithWhereWithoutManager_employeeInput[]
    deleteMany?: disciplineStaffScalarWhereInput | disciplineStaffScalarWhereInput[]
  }

  export type manager_degreeUncheckedUpdateManyWithoutManager_employeeNestedInput = {
    create?: XOR<manager_degreeCreateWithoutManager_employeeInput, manager_degreeUncheckedCreateWithoutManager_employeeInput> | manager_degreeCreateWithoutManager_employeeInput[] | manager_degreeUncheckedCreateWithoutManager_employeeInput[]
    connectOrCreate?: manager_degreeCreateOrConnectWithoutManager_employeeInput | manager_degreeCreateOrConnectWithoutManager_employeeInput[]
    upsert?: manager_degreeUpsertWithWhereUniqueWithoutManager_employeeInput | manager_degreeUpsertWithWhereUniqueWithoutManager_employeeInput[]
    createMany?: manager_degreeCreateManyManager_employeeInputEnvelope
    set?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    disconnect?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    delete?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    connect?: manager_degreeWhereUniqueInput | manager_degreeWhereUniqueInput[]
    update?: manager_degreeUpdateWithWhereUniqueWithoutManager_employeeInput | manager_degreeUpdateWithWhereUniqueWithoutManager_employeeInput[]
    updateMany?: manager_degreeUpdateManyWithWhereWithoutManager_employeeInput | manager_degreeUpdateManyWithWhereWithoutManager_employeeInput[]
    deleteMany?: manager_degreeScalarWhereInput | manager_degreeScalarWhereInput[]
  }

  export type medical_employeeCreateNestedOneWithoutMedical_degreeInput = {
    create?: XOR<medical_employeeCreateWithoutMedical_degreeInput, medical_employeeUncheckedCreateWithoutMedical_degreeInput>
    connectOrCreate?: medical_employeeCreateOrConnectWithoutMedical_degreeInput
    connect?: medical_employeeWhereUniqueInput
  }

  export type medical_employeeUpdateOneRequiredWithoutMedical_degreeNestedInput = {
    create?: XOR<medical_employeeCreateWithoutMedical_degreeInput, medical_employeeUncheckedCreateWithoutMedical_degreeInput>
    connectOrCreate?: medical_employeeCreateOrConnectWithoutMedical_degreeInput
    upsert?: medical_employeeUpsertWithoutMedical_degreeInput
    connect?: medical_employeeWhereUniqueInput
    update?: XOR<XOR<medical_employeeUpdateToOneWithWhereWithoutMedical_degreeInput, medical_employeeUpdateWithoutMedical_degreeInput>, medical_employeeUncheckedUpdateWithoutMedical_degreeInput>
  }

  export type medical_degreeCreateNestedManyWithoutMedical_employeeInput = {
    create?: XOR<medical_degreeCreateWithoutMedical_employeeInput, medical_degreeUncheckedCreateWithoutMedical_employeeInput> | medical_degreeCreateWithoutMedical_employeeInput[] | medical_degreeUncheckedCreateWithoutMedical_employeeInput[]
    connectOrCreate?: medical_degreeCreateOrConnectWithoutMedical_employeeInput | medical_degreeCreateOrConnectWithoutMedical_employeeInput[]
    createMany?: medical_degreeCreateManyMedical_employeeInputEnvelope
    connect?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
  }

  export type employeeCreateNestedOneWithoutMedical_employeeInput = {
    create?: XOR<employeeCreateWithoutMedical_employeeInput, employeeUncheckedCreateWithoutMedical_employeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutMedical_employeeInput
    connect?: employeeWhereUniqueInput
  }

  export type health_roomCreateNestedOneWithoutMedical_employeeInput = {
    create?: XOR<health_roomCreateWithoutMedical_employeeInput, health_roomUncheckedCreateWithoutMedical_employeeInput>
    connectOrCreate?: health_roomCreateOrConnectWithoutMedical_employeeInput
    connect?: health_roomWhereUniqueInput
  }

  export type medical_degreeUncheckedCreateNestedManyWithoutMedical_employeeInput = {
    create?: XOR<medical_degreeCreateWithoutMedical_employeeInput, medical_degreeUncheckedCreateWithoutMedical_employeeInput> | medical_degreeCreateWithoutMedical_employeeInput[] | medical_degreeUncheckedCreateWithoutMedical_employeeInput[]
    connectOrCreate?: medical_degreeCreateOrConnectWithoutMedical_employeeInput | medical_degreeCreateOrConnectWithoutMedical_employeeInput[]
    createMany?: medical_degreeCreateManyMedical_employeeInputEnvelope
    connect?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
  }

  export type medical_degreeUpdateManyWithoutMedical_employeeNestedInput = {
    create?: XOR<medical_degreeCreateWithoutMedical_employeeInput, medical_degreeUncheckedCreateWithoutMedical_employeeInput> | medical_degreeCreateWithoutMedical_employeeInput[] | medical_degreeUncheckedCreateWithoutMedical_employeeInput[]
    connectOrCreate?: medical_degreeCreateOrConnectWithoutMedical_employeeInput | medical_degreeCreateOrConnectWithoutMedical_employeeInput[]
    upsert?: medical_degreeUpsertWithWhereUniqueWithoutMedical_employeeInput | medical_degreeUpsertWithWhereUniqueWithoutMedical_employeeInput[]
    createMany?: medical_degreeCreateManyMedical_employeeInputEnvelope
    set?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    disconnect?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    delete?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    connect?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    update?: medical_degreeUpdateWithWhereUniqueWithoutMedical_employeeInput | medical_degreeUpdateWithWhereUniqueWithoutMedical_employeeInput[]
    updateMany?: medical_degreeUpdateManyWithWhereWithoutMedical_employeeInput | medical_degreeUpdateManyWithWhereWithoutMedical_employeeInput[]
    deleteMany?: medical_degreeScalarWhereInput | medical_degreeScalarWhereInput[]
  }

  export type employeeUpdateOneRequiredWithoutMedical_employeeNestedInput = {
    create?: XOR<employeeCreateWithoutMedical_employeeInput, employeeUncheckedCreateWithoutMedical_employeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutMedical_employeeInput
    upsert?: employeeUpsertWithoutMedical_employeeInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutMedical_employeeInput, employeeUpdateWithoutMedical_employeeInput>, employeeUncheckedUpdateWithoutMedical_employeeInput>
  }

  export type health_roomUpdateOneWithoutMedical_employeeNestedInput = {
    create?: XOR<health_roomCreateWithoutMedical_employeeInput, health_roomUncheckedCreateWithoutMedical_employeeInput>
    connectOrCreate?: health_roomCreateOrConnectWithoutMedical_employeeInput
    upsert?: health_roomUpsertWithoutMedical_employeeInput
    disconnect?: health_roomWhereInput | boolean
    delete?: health_roomWhereInput | boolean
    connect?: health_roomWhereUniqueInput
    update?: XOR<XOR<health_roomUpdateToOneWithWhereWithoutMedical_employeeInput, health_roomUpdateWithoutMedical_employeeInput>, health_roomUncheckedUpdateWithoutMedical_employeeInput>
  }

  export type medical_degreeUncheckedUpdateManyWithoutMedical_employeeNestedInput = {
    create?: XOR<medical_degreeCreateWithoutMedical_employeeInput, medical_degreeUncheckedCreateWithoutMedical_employeeInput> | medical_degreeCreateWithoutMedical_employeeInput[] | medical_degreeUncheckedCreateWithoutMedical_employeeInput[]
    connectOrCreate?: medical_degreeCreateOrConnectWithoutMedical_employeeInput | medical_degreeCreateOrConnectWithoutMedical_employeeInput[]
    upsert?: medical_degreeUpsertWithWhereUniqueWithoutMedical_employeeInput | medical_degreeUpsertWithWhereUniqueWithoutMedical_employeeInput[]
    createMany?: medical_degreeCreateManyMedical_employeeInputEnvelope
    set?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    disconnect?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    delete?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    connect?: medical_degreeWhereUniqueInput | medical_degreeWhereUniqueInput[]
    update?: medical_degreeUpdateWithWhereUniqueWithoutMedical_employeeInput | medical_degreeUpdateWithWhereUniqueWithoutMedical_employeeInput[]
    updateMany?: medical_degreeUpdateManyWithWhereWithoutMedical_employeeInput | medical_degreeUpdateManyWithWhereWithoutMedical_employeeInput[]
    deleteMany?: medical_degreeScalarWhereInput | medical_degreeScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutOther_employeeInput = {
    create?: XOR<employeeCreateWithoutOther_employeeInput, employeeUncheckedCreateWithoutOther_employeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutOther_employeeInput
    connect?: employeeWhereUniqueInput
  }

  export type other_roomCreateNestedOneWithoutOther_employeeInput = {
    create?: XOR<other_roomCreateWithoutOther_employeeInput, other_roomUncheckedCreateWithoutOther_employeeInput>
    connectOrCreate?: other_roomCreateOrConnectWithoutOther_employeeInput
    connect?: other_roomWhereUniqueInput
  }

  export type other_employee_time_workCreateNestedManyWithoutOther_employeeInput = {
    create?: XOR<other_employee_time_workCreateWithoutOther_employeeInput, other_employee_time_workUncheckedCreateWithoutOther_employeeInput> | other_employee_time_workCreateWithoutOther_employeeInput[] | other_employee_time_workUncheckedCreateWithoutOther_employeeInput[]
    connectOrCreate?: other_employee_time_workCreateOrConnectWithoutOther_employeeInput | other_employee_time_workCreateOrConnectWithoutOther_employeeInput[]
    createMany?: other_employee_time_workCreateManyOther_employeeInputEnvelope
    connect?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
  }

  export type other_employee_time_workUncheckedCreateNestedManyWithoutOther_employeeInput = {
    create?: XOR<other_employee_time_workCreateWithoutOther_employeeInput, other_employee_time_workUncheckedCreateWithoutOther_employeeInput> | other_employee_time_workCreateWithoutOther_employeeInput[] | other_employee_time_workUncheckedCreateWithoutOther_employeeInput[]
    connectOrCreate?: other_employee_time_workCreateOrConnectWithoutOther_employeeInput | other_employee_time_workCreateOrConnectWithoutOther_employeeInput[]
    createMany?: other_employee_time_workCreateManyOther_employeeInputEnvelope
    connect?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
  }

  export type employeeUpdateOneRequiredWithoutOther_employeeNestedInput = {
    create?: XOR<employeeCreateWithoutOther_employeeInput, employeeUncheckedCreateWithoutOther_employeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutOther_employeeInput
    upsert?: employeeUpsertWithoutOther_employeeInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutOther_employeeInput, employeeUpdateWithoutOther_employeeInput>, employeeUncheckedUpdateWithoutOther_employeeInput>
  }

  export type other_roomUpdateOneWithoutOther_employeeNestedInput = {
    create?: XOR<other_roomCreateWithoutOther_employeeInput, other_roomUncheckedCreateWithoutOther_employeeInput>
    connectOrCreate?: other_roomCreateOrConnectWithoutOther_employeeInput
    upsert?: other_roomUpsertWithoutOther_employeeInput
    disconnect?: other_roomWhereInput | boolean
    delete?: other_roomWhereInput | boolean
    connect?: other_roomWhereUniqueInput
    update?: XOR<XOR<other_roomUpdateToOneWithWhereWithoutOther_employeeInput, other_roomUpdateWithoutOther_employeeInput>, other_roomUncheckedUpdateWithoutOther_employeeInput>
  }

  export type other_employee_time_workUpdateManyWithoutOther_employeeNestedInput = {
    create?: XOR<other_employee_time_workCreateWithoutOther_employeeInput, other_employee_time_workUncheckedCreateWithoutOther_employeeInput> | other_employee_time_workCreateWithoutOther_employeeInput[] | other_employee_time_workUncheckedCreateWithoutOther_employeeInput[]
    connectOrCreate?: other_employee_time_workCreateOrConnectWithoutOther_employeeInput | other_employee_time_workCreateOrConnectWithoutOther_employeeInput[]
    upsert?: other_employee_time_workUpsertWithWhereUniqueWithoutOther_employeeInput | other_employee_time_workUpsertWithWhereUniqueWithoutOther_employeeInput[]
    createMany?: other_employee_time_workCreateManyOther_employeeInputEnvelope
    set?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    disconnect?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    delete?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    connect?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    update?: other_employee_time_workUpdateWithWhereUniqueWithoutOther_employeeInput | other_employee_time_workUpdateWithWhereUniqueWithoutOther_employeeInput[]
    updateMany?: other_employee_time_workUpdateManyWithWhereWithoutOther_employeeInput | other_employee_time_workUpdateManyWithWhereWithoutOther_employeeInput[]
    deleteMany?: other_employee_time_workScalarWhereInput | other_employee_time_workScalarWhereInput[]
  }

  export type other_employee_time_workUncheckedUpdateManyWithoutOther_employeeNestedInput = {
    create?: XOR<other_employee_time_workCreateWithoutOther_employeeInput, other_employee_time_workUncheckedCreateWithoutOther_employeeInput> | other_employee_time_workCreateWithoutOther_employeeInput[] | other_employee_time_workUncheckedCreateWithoutOther_employeeInput[]
    connectOrCreate?: other_employee_time_workCreateOrConnectWithoutOther_employeeInput | other_employee_time_workCreateOrConnectWithoutOther_employeeInput[]
    upsert?: other_employee_time_workUpsertWithWhereUniqueWithoutOther_employeeInput | other_employee_time_workUpsertWithWhereUniqueWithoutOther_employeeInput[]
    createMany?: other_employee_time_workCreateManyOther_employeeInputEnvelope
    set?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    disconnect?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    delete?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    connect?: other_employee_time_workWhereUniqueInput | other_employee_time_workWhereUniqueInput[]
    update?: other_employee_time_workUpdateWithWhereUniqueWithoutOther_employeeInput | other_employee_time_workUpdateWithWhereUniqueWithoutOther_employeeInput[]
    updateMany?: other_employee_time_workUpdateManyWithWhereWithoutOther_employeeInput | other_employee_time_workUpdateManyWithWhereWithoutOther_employeeInput[]
    deleteMany?: other_employee_time_workScalarWhereInput | other_employee_time_workScalarWhereInput[]
  }

  export type other_employeeCreateNestedOneWithoutOther_employee_time_workInput = {
    create?: XOR<other_employeeCreateWithoutOther_employee_time_workInput, other_employeeUncheckedCreateWithoutOther_employee_time_workInput>
    connectOrCreate?: other_employeeCreateOrConnectWithoutOther_employee_time_workInput
    connect?: other_employeeWhereUniqueInput
  }

  export type Enumother_employee_time_work_date_workFieldUpdateOperationsInput = {
    set?: $Enums.other_employee_time_work_date_work
  }

  export type other_employeeUpdateOneRequiredWithoutOther_employee_time_workNestedInput = {
    create?: XOR<other_employeeCreateWithoutOther_employee_time_workInput, other_employeeUncheckedCreateWithoutOther_employee_time_workInput>
    connectOrCreate?: other_employeeCreateOrConnectWithoutOther_employee_time_workInput
    upsert?: other_employeeUpsertWithoutOther_employee_time_workInput
    connect?: other_employeeWhereUniqueInput
    update?: XOR<XOR<other_employeeUpdateToOneWithWhereWithoutOther_employee_time_workInput, other_employeeUpdateWithoutOther_employee_time_workInput>, other_employeeUncheckedUpdateWithoutOther_employee_time_workInput>
  }

  export type other_employeeCreateNestedManyWithoutOther_roomInput = {
    create?: XOR<other_employeeCreateWithoutOther_roomInput, other_employeeUncheckedCreateWithoutOther_roomInput> | other_employeeCreateWithoutOther_roomInput[] | other_employeeUncheckedCreateWithoutOther_roomInput[]
    connectOrCreate?: other_employeeCreateOrConnectWithoutOther_roomInput | other_employeeCreateOrConnectWithoutOther_roomInput[]
    createMany?: other_employeeCreateManyOther_roomInputEnvelope
    connect?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
  }

  export type roomCreateNestedOneWithoutOther_roomInput = {
    create?: XOR<roomCreateWithoutOther_roomInput, roomUncheckedCreateWithoutOther_roomInput>
    connectOrCreate?: roomCreateOrConnectWithoutOther_roomInput
    connect?: roomWhereUniqueInput
  }

  export type other_employeeUncheckedCreateNestedManyWithoutOther_roomInput = {
    create?: XOR<other_employeeCreateWithoutOther_roomInput, other_employeeUncheckedCreateWithoutOther_roomInput> | other_employeeCreateWithoutOther_roomInput[] | other_employeeUncheckedCreateWithoutOther_roomInput[]
    connectOrCreate?: other_employeeCreateOrConnectWithoutOther_roomInput | other_employeeCreateOrConnectWithoutOther_roomInput[]
    createMany?: other_employeeCreateManyOther_roomInputEnvelope
    connect?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
  }

  export type other_employeeUpdateManyWithoutOther_roomNestedInput = {
    create?: XOR<other_employeeCreateWithoutOther_roomInput, other_employeeUncheckedCreateWithoutOther_roomInput> | other_employeeCreateWithoutOther_roomInput[] | other_employeeUncheckedCreateWithoutOther_roomInput[]
    connectOrCreate?: other_employeeCreateOrConnectWithoutOther_roomInput | other_employeeCreateOrConnectWithoutOther_roomInput[]
    upsert?: other_employeeUpsertWithWhereUniqueWithoutOther_roomInput | other_employeeUpsertWithWhereUniqueWithoutOther_roomInput[]
    createMany?: other_employeeCreateManyOther_roomInputEnvelope
    set?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    disconnect?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    delete?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    connect?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    update?: other_employeeUpdateWithWhereUniqueWithoutOther_roomInput | other_employeeUpdateWithWhereUniqueWithoutOther_roomInput[]
    updateMany?: other_employeeUpdateManyWithWhereWithoutOther_roomInput | other_employeeUpdateManyWithWhereWithoutOther_roomInput[]
    deleteMany?: other_employeeScalarWhereInput | other_employeeScalarWhereInput[]
  }

  export type roomUpdateOneRequiredWithoutOther_roomNestedInput = {
    create?: XOR<roomCreateWithoutOther_roomInput, roomUncheckedCreateWithoutOther_roomInput>
    connectOrCreate?: roomCreateOrConnectWithoutOther_roomInput
    upsert?: roomUpsertWithoutOther_roomInput
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutOther_roomInput, roomUpdateWithoutOther_roomInput>, roomUncheckedUpdateWithoutOther_roomInput>
  }

  export type other_employeeUncheckedUpdateManyWithoutOther_roomNestedInput = {
    create?: XOR<other_employeeCreateWithoutOther_roomInput, other_employeeUncheckedCreateWithoutOther_roomInput> | other_employeeCreateWithoutOther_roomInput[] | other_employeeUncheckedCreateWithoutOther_roomInput[]
    connectOrCreate?: other_employeeCreateOrConnectWithoutOther_roomInput | other_employeeCreateOrConnectWithoutOther_roomInput[]
    upsert?: other_employeeUpsertWithWhereUniqueWithoutOther_roomInput | other_employeeUpsertWithWhereUniqueWithoutOther_roomInput[]
    createMany?: other_employeeCreateManyOther_roomInputEnvelope
    set?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    disconnect?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    delete?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    connect?: other_employeeWhereUniqueInput | other_employeeWhereUniqueInput[]
    update?: other_employeeUpdateWithWhereUniqueWithoutOther_roomInput | other_employeeUpdateWithWhereUniqueWithoutOther_roomInput[]
    updateMany?: other_employeeUpdateManyWithWhereWithoutOther_roomInput | other_employeeUpdateManyWithWhereWithoutOther_roomInput[]
    deleteMany?: other_employeeScalarWhereInput | other_employeeScalarWhereInput[]
  }

  export type studentCreateNestedOneWithoutRelativeInput = {
    create?: XOR<studentCreateWithoutRelativeInput, studentUncheckedCreateWithoutRelativeInput>
    connectOrCreate?: studentCreateOrConnectWithoutRelativeInput
    connect?: studentWhereUniqueInput
  }

  export type studentUpdateOneRequiredWithoutRelativeNestedInput = {
    create?: XOR<studentCreateWithoutRelativeInput, studentUncheckedCreateWithoutRelativeInput>
    connectOrCreate?: studentCreateOrConnectWithoutRelativeInput
    upsert?: studentUpsertWithoutRelativeInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutRelativeInput, studentUpdateWithoutRelativeInput>, studentUncheckedUpdateWithoutRelativeInput>
  }

  export type health_roomCreateNestedOneWithoutRoomInput = {
    create?: XOR<health_roomCreateWithoutRoomInput, health_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: health_roomCreateOrConnectWithoutRoomInput
    connect?: health_roomWhereUniqueInput
  }

  export type management_roomCreateNestedOneWithoutRoomInput = {
    create?: XOR<management_roomCreateWithoutRoomInput, management_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: management_roomCreateOrConnectWithoutRoomInput
    connect?: management_roomWhereUniqueInput
  }

  export type other_roomCreateNestedOneWithoutRoomInput = {
    create?: XOR<other_roomCreateWithoutRoomInput, other_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: other_roomCreateOrConnectWithoutRoomInput
    connect?: other_roomWhereUniqueInput
  }

  export type buildingCreateNestedOneWithoutRoomInput = {
    create?: XOR<buildingCreateWithoutRoomInput, buildingUncheckedCreateWithoutRoomInput>
    connectOrCreate?: buildingCreateOrConnectWithoutRoomInput
    connect?: buildingWhereUniqueInput
  }

  export type health_roomUncheckedCreateNestedOneWithoutRoomInput = {
    create?: XOR<health_roomCreateWithoutRoomInput, health_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: health_roomCreateOrConnectWithoutRoomInput
    connect?: health_roomWhereUniqueInput
  }

  export type management_roomUncheckedCreateNestedOneWithoutRoomInput = {
    create?: XOR<management_roomCreateWithoutRoomInput, management_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: management_roomCreateOrConnectWithoutRoomInput
    connect?: management_roomWhereUniqueInput
  }

  export type other_roomUncheckedCreateNestedOneWithoutRoomInput = {
    create?: XOR<other_roomCreateWithoutRoomInput, other_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: other_roomCreateOrConnectWithoutRoomInput
    connect?: other_roomWhereUniqueInput
  }

  export type Enumroom_room_statusFieldUpdateOperationsInput = {
    set?: $Enums.room_room_status
  }

  export type health_roomUpdateOneWithoutRoomNestedInput = {
    create?: XOR<health_roomCreateWithoutRoomInput, health_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: health_roomCreateOrConnectWithoutRoomInput
    upsert?: health_roomUpsertWithoutRoomInput
    disconnect?: health_roomWhereInput | boolean
    delete?: health_roomWhereInput | boolean
    connect?: health_roomWhereUniqueInput
    update?: XOR<XOR<health_roomUpdateToOneWithWhereWithoutRoomInput, health_roomUpdateWithoutRoomInput>, health_roomUncheckedUpdateWithoutRoomInput>
  }

  export type management_roomUpdateOneWithoutRoomNestedInput = {
    create?: XOR<management_roomCreateWithoutRoomInput, management_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: management_roomCreateOrConnectWithoutRoomInput
    upsert?: management_roomUpsertWithoutRoomInput
    disconnect?: management_roomWhereInput | boolean
    delete?: management_roomWhereInput | boolean
    connect?: management_roomWhereUniqueInput
    update?: XOR<XOR<management_roomUpdateToOneWithWhereWithoutRoomInput, management_roomUpdateWithoutRoomInput>, management_roomUncheckedUpdateWithoutRoomInput>
  }

  export type other_roomUpdateOneWithoutRoomNestedInput = {
    create?: XOR<other_roomCreateWithoutRoomInput, other_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: other_roomCreateOrConnectWithoutRoomInput
    upsert?: other_roomUpsertWithoutRoomInput
    disconnect?: other_roomWhereInput | boolean
    delete?: other_roomWhereInput | boolean
    connect?: other_roomWhereUniqueInput
    update?: XOR<XOR<other_roomUpdateToOneWithWhereWithoutRoomInput, other_roomUpdateWithoutRoomInput>, other_roomUncheckedUpdateWithoutRoomInput>
  }

  export type buildingUpdateOneRequiredWithoutRoomNestedInput = {
    create?: XOR<buildingCreateWithoutRoomInput, buildingUncheckedCreateWithoutRoomInput>
    connectOrCreate?: buildingCreateOrConnectWithoutRoomInput
    upsert?: buildingUpsertWithoutRoomInput
    connect?: buildingWhereUniqueInput
    update?: XOR<XOR<buildingUpdateToOneWithWhereWithoutRoomInput, buildingUpdateWithoutRoomInput>, buildingUncheckedUpdateWithoutRoomInput>
  }

  export type health_roomUncheckedUpdateOneWithoutRoomNestedInput = {
    create?: XOR<health_roomCreateWithoutRoomInput, health_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: health_roomCreateOrConnectWithoutRoomInput
    upsert?: health_roomUpsertWithoutRoomInput
    disconnect?: health_roomWhereInput | boolean
    delete?: health_roomWhereInput | boolean
    connect?: health_roomWhereUniqueInput
    update?: XOR<XOR<health_roomUpdateToOneWithWhereWithoutRoomInput, health_roomUpdateWithoutRoomInput>, health_roomUncheckedUpdateWithoutRoomInput>
  }

  export type management_roomUncheckedUpdateOneWithoutRoomNestedInput = {
    create?: XOR<management_roomCreateWithoutRoomInput, management_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: management_roomCreateOrConnectWithoutRoomInput
    upsert?: management_roomUpsertWithoutRoomInput
    disconnect?: management_roomWhereInput | boolean
    delete?: management_roomWhereInput | boolean
    connect?: management_roomWhereUniqueInput
    update?: XOR<XOR<management_roomUpdateToOneWithWhereWithoutRoomInput, management_roomUpdateWithoutRoomInput>, management_roomUncheckedUpdateWithoutRoomInput>
  }

  export type other_roomUncheckedUpdateOneWithoutRoomNestedInput = {
    create?: XOR<other_roomCreateWithoutRoomInput, other_roomUncheckedCreateWithoutRoomInput>
    connectOrCreate?: other_roomCreateOrConnectWithoutRoomInput
    upsert?: other_roomUpsertWithoutRoomInput
    disconnect?: other_roomWhereInput | boolean
    delete?: other_roomWhereInput | boolean
    connect?: other_roomWhereUniqueInput
    update?: XOR<XOR<other_roomUpdateToOneWithWhereWithoutRoomInput, other_roomUpdateWithoutRoomInput>, other_roomUncheckedUpdateWithoutRoomInput>
  }

  export type Dormitory_CardCreateNestedManyWithoutStudentInput = {
    create?: XOR<Dormitory_CardCreateWithoutStudentInput, Dormitory_CardUncheckedCreateWithoutStudentInput> | Dormitory_CardCreateWithoutStudentInput[] | Dormitory_CardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutStudentInput | Dormitory_CardCreateOrConnectWithoutStudentInput[]
    createMany?: Dormitory_CardCreateManyStudentInputEnvelope
    connect?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
  }

  export type relativeCreateNestedManyWithoutStudentInput = {
    create?: XOR<relativeCreateWithoutStudentInput, relativeUncheckedCreateWithoutStudentInput> | relativeCreateWithoutStudentInput[] | relativeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: relativeCreateOrConnectWithoutStudentInput | relativeCreateOrConnectWithoutStudentInput[]
    createMany?: relativeCreateManyStudentInputEnvelope
    connect?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
  }

  export type PeopleCreateNestedOneWithoutStudentInput = {
    create?: XOR<PeopleCreateWithoutStudentInput, PeopleUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutStudentInput
    connect?: PeopleWhereUniqueInput
  }

  export type living_roomCreateNestedOneWithoutStudentInput = {
    create?: XOR<living_roomCreateWithoutStudentInput, living_roomUncheckedCreateWithoutStudentInput>
    connectOrCreate?: living_roomCreateOrConnectWithoutStudentInput
    connect?: living_roomWhereUniqueInput
  }

  export type studentDisciplineCreateNestedManyWithoutStudentInput = {
    create?: XOR<studentDisciplineCreateWithoutStudentInput, studentDisciplineUncheckedCreateWithoutStudentInput> | studentDisciplineCreateWithoutStudentInput[] | studentDisciplineUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutStudentInput | studentDisciplineCreateOrConnectWithoutStudentInput[]
    createMany?: studentDisciplineCreateManyStudentInputEnvelope
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
  }

  export type Dormitory_CardUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Dormitory_CardCreateWithoutStudentInput, Dormitory_CardUncheckedCreateWithoutStudentInput> | Dormitory_CardCreateWithoutStudentInput[] | Dormitory_CardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutStudentInput | Dormitory_CardCreateOrConnectWithoutStudentInput[]
    createMany?: Dormitory_CardCreateManyStudentInputEnvelope
    connect?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
  }

  export type relativeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<relativeCreateWithoutStudentInput, relativeUncheckedCreateWithoutStudentInput> | relativeCreateWithoutStudentInput[] | relativeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: relativeCreateOrConnectWithoutStudentInput | relativeCreateOrConnectWithoutStudentInput[]
    createMany?: relativeCreateManyStudentInputEnvelope
    connect?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
  }

  export type studentDisciplineUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<studentDisciplineCreateWithoutStudentInput, studentDisciplineUncheckedCreateWithoutStudentInput> | studentDisciplineCreateWithoutStudentInput[] | studentDisciplineUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutStudentInput | studentDisciplineCreateOrConnectWithoutStudentInput[]
    createMany?: studentDisciplineCreateManyStudentInputEnvelope
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
  }

  export type Dormitory_CardUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Dormitory_CardCreateWithoutStudentInput, Dormitory_CardUncheckedCreateWithoutStudentInput> | Dormitory_CardCreateWithoutStudentInput[] | Dormitory_CardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutStudentInput | Dormitory_CardCreateOrConnectWithoutStudentInput[]
    upsert?: Dormitory_CardUpsertWithWhereUniqueWithoutStudentInput | Dormitory_CardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: Dormitory_CardCreateManyStudentInputEnvelope
    set?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    disconnect?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    delete?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    connect?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    update?: Dormitory_CardUpdateWithWhereUniqueWithoutStudentInput | Dormitory_CardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: Dormitory_CardUpdateManyWithWhereWithoutStudentInput | Dormitory_CardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: Dormitory_CardScalarWhereInput | Dormitory_CardScalarWhereInput[]
  }

  export type relativeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<relativeCreateWithoutStudentInput, relativeUncheckedCreateWithoutStudentInput> | relativeCreateWithoutStudentInput[] | relativeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: relativeCreateOrConnectWithoutStudentInput | relativeCreateOrConnectWithoutStudentInput[]
    upsert?: relativeUpsertWithWhereUniqueWithoutStudentInput | relativeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: relativeCreateManyStudentInputEnvelope
    set?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    disconnect?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    delete?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    connect?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    update?: relativeUpdateWithWhereUniqueWithoutStudentInput | relativeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: relativeUpdateManyWithWhereWithoutStudentInput | relativeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: relativeScalarWhereInput | relativeScalarWhereInput[]
  }

  export type PeopleUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<PeopleCreateWithoutStudentInput, PeopleUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PeopleCreateOrConnectWithoutStudentInput
    upsert?: PeopleUpsertWithoutStudentInput
    connect?: PeopleWhereUniqueInput
    update?: XOR<XOR<PeopleUpdateToOneWithWhereWithoutStudentInput, PeopleUpdateWithoutStudentInput>, PeopleUncheckedUpdateWithoutStudentInput>
  }

  export type living_roomUpdateOneWithoutStudentNestedInput = {
    create?: XOR<living_roomCreateWithoutStudentInput, living_roomUncheckedCreateWithoutStudentInput>
    connectOrCreate?: living_roomCreateOrConnectWithoutStudentInput
    upsert?: living_roomUpsertWithoutStudentInput
    disconnect?: living_roomWhereInput | boolean
    delete?: living_roomWhereInput | boolean
    connect?: living_roomWhereUniqueInput
    update?: XOR<XOR<living_roomUpdateToOneWithWhereWithoutStudentInput, living_roomUpdateWithoutStudentInput>, living_roomUncheckedUpdateWithoutStudentInput>
  }

  export type studentDisciplineUpdateManyWithoutStudentNestedInput = {
    create?: XOR<studentDisciplineCreateWithoutStudentInput, studentDisciplineUncheckedCreateWithoutStudentInput> | studentDisciplineCreateWithoutStudentInput[] | studentDisciplineUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutStudentInput | studentDisciplineCreateOrConnectWithoutStudentInput[]
    upsert?: studentDisciplineUpsertWithWhereUniqueWithoutStudentInput | studentDisciplineUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: studentDisciplineCreateManyStudentInputEnvelope
    set?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    disconnect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    delete?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    update?: studentDisciplineUpdateWithWhereUniqueWithoutStudentInput | studentDisciplineUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: studentDisciplineUpdateManyWithWhereWithoutStudentInput | studentDisciplineUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: studentDisciplineScalarWhereInput | studentDisciplineScalarWhereInput[]
  }

  export type Dormitory_CardUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Dormitory_CardCreateWithoutStudentInput, Dormitory_CardUncheckedCreateWithoutStudentInput> | Dormitory_CardCreateWithoutStudentInput[] | Dormitory_CardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: Dormitory_CardCreateOrConnectWithoutStudentInput | Dormitory_CardCreateOrConnectWithoutStudentInput[]
    upsert?: Dormitory_CardUpsertWithWhereUniqueWithoutStudentInput | Dormitory_CardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: Dormitory_CardCreateManyStudentInputEnvelope
    set?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    disconnect?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    delete?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    connect?: Dormitory_CardWhereUniqueInput | Dormitory_CardWhereUniqueInput[]
    update?: Dormitory_CardUpdateWithWhereUniqueWithoutStudentInput | Dormitory_CardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: Dormitory_CardUpdateManyWithWhereWithoutStudentInput | Dormitory_CardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: Dormitory_CardScalarWhereInput | Dormitory_CardScalarWhereInput[]
  }

  export type relativeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<relativeCreateWithoutStudentInput, relativeUncheckedCreateWithoutStudentInput> | relativeCreateWithoutStudentInput[] | relativeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: relativeCreateOrConnectWithoutStudentInput | relativeCreateOrConnectWithoutStudentInput[]
    upsert?: relativeUpsertWithWhereUniqueWithoutStudentInput | relativeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: relativeCreateManyStudentInputEnvelope
    set?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    disconnect?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    delete?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    connect?: relativeWhereUniqueInput | relativeWhereUniqueInput[]
    update?: relativeUpdateWithWhereUniqueWithoutStudentInput | relativeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: relativeUpdateManyWithWhereWithoutStudentInput | relativeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: relativeScalarWhereInput | relativeScalarWhereInput[]
  }

  export type studentDisciplineUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<studentDisciplineCreateWithoutStudentInput, studentDisciplineUncheckedCreateWithoutStudentInput> | studentDisciplineCreateWithoutStudentInput[] | studentDisciplineUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: studentDisciplineCreateOrConnectWithoutStudentInput | studentDisciplineCreateOrConnectWithoutStudentInput[]
    upsert?: studentDisciplineUpsertWithWhereUniqueWithoutStudentInput | studentDisciplineUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: studentDisciplineCreateManyStudentInputEnvelope
    set?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    disconnect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    delete?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    connect?: studentDisciplineWhereUniqueInput | studentDisciplineWhereUniqueInput[]
    update?: studentDisciplineUpdateWithWhereUniqueWithoutStudentInput | studentDisciplineUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: studentDisciplineUpdateManyWithWhereWithoutStudentInput | studentDisciplineUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: studentDisciplineScalarWhereInput | studentDisciplineScalarWhereInput[]
  }

  export type disciplinaryActionCreateNestedOneWithoutStudentDisciplineInput = {
    create?: XOR<disciplinaryActionCreateWithoutStudentDisciplineInput, disciplinaryActionUncheckedCreateWithoutStudentDisciplineInput>
    connectOrCreate?: disciplinaryActionCreateOrConnectWithoutStudentDisciplineInput
    connect?: disciplinaryActionWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutStudentDisciplineInput = {
    create?: XOR<studentCreateWithoutStudentDisciplineInput, studentUncheckedCreateWithoutStudentDisciplineInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudentDisciplineInput
    connect?: studentWhereUniqueInput
  }

  export type disciplinaryActionUpdateOneRequiredWithoutStudentDisciplineNestedInput = {
    create?: XOR<disciplinaryActionCreateWithoutStudentDisciplineInput, disciplinaryActionUncheckedCreateWithoutStudentDisciplineInput>
    connectOrCreate?: disciplinaryActionCreateOrConnectWithoutStudentDisciplineInput
    upsert?: disciplinaryActionUpsertWithoutStudentDisciplineInput
    connect?: disciplinaryActionWhereUniqueInput
    update?: XOR<XOR<disciplinaryActionUpdateToOneWithWhereWithoutStudentDisciplineInput, disciplinaryActionUpdateWithoutStudentDisciplineInput>, disciplinaryActionUncheckedUpdateWithoutStudentDisciplineInput>
  }

  export type studentUpdateOneRequiredWithoutStudentDisciplineNestedInput = {
    create?: XOR<studentCreateWithoutStudentDisciplineInput, studentUncheckedCreateWithoutStudentDisciplineInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudentDisciplineInput
    upsert?: studentUpsertWithoutStudentDisciplineInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutStudentDisciplineInput, studentUpdateWithoutStudentDisciplineInput>, studentUncheckedUpdateWithoutStudentDisciplineInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumhealth_room_equipment_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.health_room_equipment_status | Enumhealth_room_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.health_room_equipment_status[]
    notIn?: $Enums.health_room_equipment_status[]
    not?: NestedEnumhealth_room_equipment_statusFilter<$PrismaModel> | $Enums.health_room_equipment_status
  }

  export type NestedEnumhealth_room_equipment_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.health_room_equipment_status | Enumhealth_room_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.health_room_equipment_status[]
    notIn?: $Enums.health_room_equipment_status[]
    not?: NestedEnumhealth_room_equipment_statusWithAggregatesFilter<$PrismaModel> | $Enums.health_room_equipment_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhealth_room_equipment_statusFilter<$PrismaModel>
    _max?: NestedEnumhealth_room_equipment_statusFilter<$PrismaModel>
  }

  export type NestedEnumlarge_equipment_equipment_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.large_equipment_equipment_status | Enumlarge_equipment_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.large_equipment_equipment_status[]
    notIn?: $Enums.large_equipment_equipment_status[]
    not?: NestedEnumlarge_equipment_equipment_statusFilter<$PrismaModel> | $Enums.large_equipment_equipment_status
  }

  export type NestedEnumlarge_equipment_equipment_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.large_equipment_equipment_status | Enumlarge_equipment_equipment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.large_equipment_equipment_status[]
    notIn?: $Enums.large_equipment_equipment_status[]
    not?: NestedEnumlarge_equipment_equipment_statusWithAggregatesFilter<$PrismaModel> | $Enums.large_equipment_equipment_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlarge_equipment_equipment_statusFilter<$PrismaModel>
    _max?: NestedEnumlarge_equipment_equipment_statusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumother_employee_time_work_date_workFilter<$PrismaModel = never> = {
    equals?: $Enums.other_employee_time_work_date_work | Enumother_employee_time_work_date_workFieldRefInput<$PrismaModel>
    in?: $Enums.other_employee_time_work_date_work[]
    notIn?: $Enums.other_employee_time_work_date_work[]
    not?: NestedEnumother_employee_time_work_date_workFilter<$PrismaModel> | $Enums.other_employee_time_work_date_work
  }

  export type NestedEnumother_employee_time_work_date_workWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.other_employee_time_work_date_work | Enumother_employee_time_work_date_workFieldRefInput<$PrismaModel>
    in?: $Enums.other_employee_time_work_date_work[]
    notIn?: $Enums.other_employee_time_work_date_work[]
    not?: NestedEnumother_employee_time_work_date_workWithAggregatesFilter<$PrismaModel> | $Enums.other_employee_time_work_date_work
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumother_employee_time_work_date_workFilter<$PrismaModel>
    _max?: NestedEnumother_employee_time_work_date_workFilter<$PrismaModel>
  }

  export type NestedEnumroom_room_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.room_room_status | Enumroom_room_statusFieldRefInput<$PrismaModel>
    in?: $Enums.room_room_status[]
    notIn?: $Enums.room_room_status[]
    not?: NestedEnumroom_room_statusFilter<$PrismaModel> | $Enums.room_room_status
  }

  export type NestedEnumroom_room_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.room_room_status | Enumroom_room_statusFieldRefInput<$PrismaModel>
    in?: $Enums.room_room_status[]
    notIn?: $Enums.room_room_status[]
    not?: NestedEnumroom_room_statusWithAggregatesFilter<$PrismaModel> | $Enums.room_room_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroom_room_statusFilter<$PrismaModel>
    _max?: NestedEnumroom_room_statusFilter<$PrismaModel>
  }

  export type PeopleCreateWithoutAddressInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Email?: EmailCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberCreateNestedManyWithoutPeopleInput
    employee?: employeeCreateNestedOneWithoutPeopleInput
    student?: studentCreateNestedOneWithoutPeopleInput
  }

  export type PeopleUncheckedCreateWithoutAddressInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Email?: EmailUncheckedCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberUncheckedCreateNestedManyWithoutPeopleInput
    employee?: employeeUncheckedCreateNestedOneWithoutPeopleInput
    student?: studentUncheckedCreateNestedOneWithoutPeopleInput
  }

  export type PeopleCreateOrConnectWithoutAddressInput = {
    where: PeopleWhereUniqueInput
    create: XOR<PeopleCreateWithoutAddressInput, PeopleUncheckedCreateWithoutAddressInput>
  }

  export type PeopleUpsertWithoutAddressInput = {
    update: XOR<PeopleUpdateWithoutAddressInput, PeopleUncheckedUpdateWithoutAddressInput>
    create: XOR<PeopleCreateWithoutAddressInput, PeopleUncheckedCreateWithoutAddressInput>
    where?: PeopleWhereInput
  }

  export type PeopleUpdateToOneWithWhereWithoutAddressInput = {
    where?: PeopleWhereInput
    data: XOR<PeopleUpdateWithoutAddressInput, PeopleUncheckedUpdateWithoutAddressInput>
  }

  export type PeopleUpdateWithoutAddressInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: EmailUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUpdateManyWithoutPeopleNestedInput
    employee?: employeeUpdateOneWithoutPeopleNestedInput
    student?: studentUpdateOneWithoutPeopleNestedInput
  }

  export type PeopleUncheckedUpdateWithoutAddressInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: EmailUncheckedUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUncheckedUpdateManyWithoutPeopleNestedInput
    employee?: employeeUncheckedUpdateOneWithoutPeopleNestedInput
    student?: studentUncheckedUpdateOneWithoutPeopleNestedInput
  }

  export type Identity_CardCreateWithoutDormitory_CardInput = {
    ID: string
    Issued_Date: Date | string
    Employee_Card?: Employee_CardCreateNestedOneWithoutIdentity_CardInput
  }

  export type Identity_CardUncheckedCreateWithoutDormitory_CardInput = {
    ID: string
    Issued_Date: Date | string
    Employee_Card?: Employee_CardUncheckedCreateNestedOneWithoutIdentity_CardInput
  }

  export type Identity_CardCreateOrConnectWithoutDormitory_CardInput = {
    where: Identity_CardWhereUniqueInput
    create: XOR<Identity_CardCreateWithoutDormitory_CardInput, Identity_CardUncheckedCreateWithoutDormitory_CardInput>
  }

  export type studentCreateWithoutDormitory_CardInput = {
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    relative?: relativeCreateNestedManyWithoutStudentInput
    People: PeopleCreateNestedOneWithoutStudentInput
    living_room?: living_roomCreateNestedOneWithoutStudentInput
    studentDiscipline?: studentDisciplineCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutDormitory_CardInput = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    building_id?: string | null
    room_id?: string | null
    relative?: relativeUncheckedCreateNestedManyWithoutStudentInput
    studentDiscipline?: studentDisciplineUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutDormitory_CardInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutDormitory_CardInput, studentUncheckedCreateWithoutDormitory_CardInput>
  }

  export type Identity_CardUpsertWithoutDormitory_CardInput = {
    update: XOR<Identity_CardUpdateWithoutDormitory_CardInput, Identity_CardUncheckedUpdateWithoutDormitory_CardInput>
    create: XOR<Identity_CardCreateWithoutDormitory_CardInput, Identity_CardUncheckedCreateWithoutDormitory_CardInput>
    where?: Identity_CardWhereInput
  }

  export type Identity_CardUpdateToOneWithWhereWithoutDormitory_CardInput = {
    where?: Identity_CardWhereInput
    data: XOR<Identity_CardUpdateWithoutDormitory_CardInput, Identity_CardUncheckedUpdateWithoutDormitory_CardInput>
  }

  export type Identity_CardUpdateWithoutDormitory_CardInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee_Card?: Employee_CardUpdateOneWithoutIdentity_CardNestedInput
  }

  export type Identity_CardUncheckedUpdateWithoutDormitory_CardInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee_Card?: Employee_CardUncheckedUpdateOneWithoutIdentity_CardNestedInput
  }

  export type studentUpsertWithoutDormitory_CardInput = {
    update: XOR<studentUpdateWithoutDormitory_CardInput, studentUncheckedUpdateWithoutDormitory_CardInput>
    create: XOR<studentCreateWithoutDormitory_CardInput, studentUncheckedCreateWithoutDormitory_CardInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutDormitory_CardInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutDormitory_CardInput, studentUncheckedUpdateWithoutDormitory_CardInput>
  }

  export type studentUpdateWithoutDormitory_CardInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    relative?: relativeUpdateManyWithoutStudentNestedInput
    People?: PeopleUpdateOneRequiredWithoutStudentNestedInput
    living_room?: living_roomUpdateOneWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutDormitory_CardInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    relative?: relativeUncheckedUpdateManyWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PeopleCreateWithoutEmailInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberCreateNestedManyWithoutPeopleInput
    employee?: employeeCreateNestedOneWithoutPeopleInput
    student?: studentCreateNestedOneWithoutPeopleInput
  }

  export type PeopleUncheckedCreateWithoutEmailInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressUncheckedCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberUncheckedCreateNestedManyWithoutPeopleInput
    employee?: employeeUncheckedCreateNestedOneWithoutPeopleInput
    student?: studentUncheckedCreateNestedOneWithoutPeopleInput
  }

  export type PeopleCreateOrConnectWithoutEmailInput = {
    where: PeopleWhereUniqueInput
    create: XOR<PeopleCreateWithoutEmailInput, PeopleUncheckedCreateWithoutEmailInput>
  }

  export type PeopleUpsertWithoutEmailInput = {
    update: XOR<PeopleUpdateWithoutEmailInput, PeopleUncheckedUpdateWithoutEmailInput>
    create: XOR<PeopleCreateWithoutEmailInput, PeopleUncheckedCreateWithoutEmailInput>
    where?: PeopleWhereInput
  }

  export type PeopleUpdateToOneWithWhereWithoutEmailInput = {
    where?: PeopleWhereInput
    data: XOR<PeopleUpdateWithoutEmailInput, PeopleUncheckedUpdateWithoutEmailInput>
  }

  export type PeopleUpdateWithoutEmailInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUpdateManyWithoutPeopleNestedInput
    employee?: employeeUpdateOneWithoutPeopleNestedInput
    student?: studentUpdateOneWithoutPeopleNestedInput
  }

  export type PeopleUncheckedUpdateWithoutEmailInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUncheckedUpdateManyWithoutPeopleNestedInput
    employee?: employeeUncheckedUpdateOneWithoutPeopleNestedInput
    student?: studentUncheckedUpdateOneWithoutPeopleNestedInput
  }

  export type Identity_CardCreateWithoutEmployee_CardInput = {
    ID: string
    Issued_Date: Date | string
    Dormitory_Card?: Dormitory_CardCreateNestedOneWithoutIdentity_CardInput
  }

  export type Identity_CardUncheckedCreateWithoutEmployee_CardInput = {
    ID: string
    Issued_Date: Date | string
    Dormitory_Card?: Dormitory_CardUncheckedCreateNestedOneWithoutIdentity_CardInput
  }

  export type Identity_CardCreateOrConnectWithoutEmployee_CardInput = {
    where: Identity_CardWhereUniqueInput
    create: XOR<Identity_CardCreateWithoutEmployee_CardInput, Identity_CardUncheckedCreateWithoutEmployee_CardInput>
  }

  export type employeeCreateWithoutEmployee_CardInput = {
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    People: PeopleCreateNestedOneWithoutEmployeeInput
    manager_employee?: manager_employeeCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutEmployee_CardInput = {
    essn: string
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    manager_employee?: manager_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutEmployee_CardInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutEmployee_CardInput, employeeUncheckedCreateWithoutEmployee_CardInput>
  }

  export type Identity_CardUpsertWithoutEmployee_CardInput = {
    update: XOR<Identity_CardUpdateWithoutEmployee_CardInput, Identity_CardUncheckedUpdateWithoutEmployee_CardInput>
    create: XOR<Identity_CardCreateWithoutEmployee_CardInput, Identity_CardUncheckedCreateWithoutEmployee_CardInput>
    where?: Identity_CardWhereInput
  }

  export type Identity_CardUpdateToOneWithWhereWithoutEmployee_CardInput = {
    where?: Identity_CardWhereInput
    data: XOR<Identity_CardUpdateWithoutEmployee_CardInput, Identity_CardUncheckedUpdateWithoutEmployee_CardInput>
  }

  export type Identity_CardUpdateWithoutEmployee_CardInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Dormitory_Card?: Dormitory_CardUpdateOneWithoutIdentity_CardNestedInput
  }

  export type Identity_CardUncheckedUpdateWithoutEmployee_CardInput = {
    ID?: StringFieldUpdateOperationsInput | string
    Issued_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Dormitory_Card?: Dormitory_CardUncheckedUpdateOneWithoutIdentity_CardNestedInput
  }

  export type employeeUpsertWithoutEmployee_CardInput = {
    update: XOR<employeeUpdateWithoutEmployee_CardInput, employeeUncheckedUpdateWithoutEmployee_CardInput>
    create: XOR<employeeCreateWithoutEmployee_CardInput, employeeUncheckedCreateWithoutEmployee_CardInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutEmployee_CardInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutEmployee_CardInput, employeeUncheckedUpdateWithoutEmployee_CardInput>
  }

  export type employeeUpdateWithoutEmployee_CardInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    People?: PeopleUpdateOneRequiredWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUpdateOneWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutEmployee_CardInput = {
    essn?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    manager_employee?: manager_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type Dormitory_CardCreateWithoutIdentity_CardInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Validity?: boolean | null
    student: studentCreateNestedOneWithoutDormitory_CardInput
  }

  export type Dormitory_CardUncheckedCreateWithoutIdentity_CardInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    ID_Card: string
    Validity?: boolean | null
  }

  export type Dormitory_CardCreateOrConnectWithoutIdentity_CardInput = {
    where: Dormitory_CardWhereUniqueInput
    create: XOR<Dormitory_CardCreateWithoutIdentity_CardInput, Dormitory_CardUncheckedCreateWithoutIdentity_CardInput>
  }

  export type Employee_CardCreateWithoutIdentity_CardInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Employee_Type?: string | null
    employee: employeeCreateNestedOneWithoutEmployee_CardInput
  }

  export type Employee_CardUncheckedCreateWithoutIdentity_CardInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    ID_Card: string
    Employee_Type?: string | null
  }

  export type Employee_CardCreateOrConnectWithoutIdentity_CardInput = {
    where: Employee_CardWhereUniqueInput
    create: XOR<Employee_CardCreateWithoutIdentity_CardInput, Employee_CardUncheckedCreateWithoutIdentity_CardInput>
  }

  export type Dormitory_CardUpsertWithoutIdentity_CardInput = {
    update: XOR<Dormitory_CardUpdateWithoutIdentity_CardInput, Dormitory_CardUncheckedUpdateWithoutIdentity_CardInput>
    create: XOR<Dormitory_CardCreateWithoutIdentity_CardInput, Dormitory_CardUncheckedCreateWithoutIdentity_CardInput>
    where?: Dormitory_CardWhereInput
  }

  export type Dormitory_CardUpdateToOneWithWhereWithoutIdentity_CardInput = {
    where?: Dormitory_CardWhereInput
    data: XOR<Dormitory_CardUpdateWithoutIdentity_CardInput, Dormitory_CardUncheckedUpdateWithoutIdentity_CardInput>
  }

  export type Dormitory_CardUpdateWithoutIdentity_CardInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
    student?: studentUpdateOneRequiredWithoutDormitory_CardNestedInput
  }

  export type Dormitory_CardUncheckedUpdateWithoutIdentity_CardInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ID_Card?: StringFieldUpdateOperationsInput | string
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type Employee_CardUpsertWithoutIdentity_CardInput = {
    update: XOR<Employee_CardUpdateWithoutIdentity_CardInput, Employee_CardUncheckedUpdateWithoutIdentity_CardInput>
    create: XOR<Employee_CardCreateWithoutIdentity_CardInput, Employee_CardUncheckedCreateWithoutIdentity_CardInput>
    where?: Employee_CardWhereInput
  }

  export type Employee_CardUpdateToOneWithWhereWithoutIdentity_CardInput = {
    where?: Employee_CardWhereInput
    data: XOR<Employee_CardUpdateWithoutIdentity_CardInput, Employee_CardUncheckedUpdateWithoutIdentity_CardInput>
  }

  export type Employee_CardUpdateWithoutIdentity_CardInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: employeeUpdateOneRequiredWithoutEmployee_CardNestedInput
  }

  export type Employee_CardUncheckedUpdateWithoutIdentity_CardInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ID_Card?: StringFieldUpdateOperationsInput | string
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateWithoutPeopleInput = {
    commune: string
    district: string
    province: string
  }

  export type AddressUncheckedCreateWithoutPeopleInput = {
    commune: string
    district: string
    province: string
  }

  export type AddressCreateOrConnectWithoutPeopleInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutPeopleInput, AddressUncheckedCreateWithoutPeopleInput>
  }

  export type AddressCreateManyPeopleInputEnvelope = {
    data: AddressCreateManyPeopleInput | AddressCreateManyPeopleInput[]
    skipDuplicates?: boolean
  }

  export type EmailCreateWithoutPeopleInput = {
    email: string
  }

  export type EmailUncheckedCreateWithoutPeopleInput = {
    email: string
  }

  export type EmailCreateOrConnectWithoutPeopleInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutPeopleInput, EmailUncheckedCreateWithoutPeopleInput>
  }

  export type EmailCreateManyPeopleInputEnvelope = {
    data: EmailCreateManyPeopleInput | EmailCreateManyPeopleInput[]
    skipDuplicates?: boolean
  }

  export type PhoneNumberCreateWithoutPeopleInput = {
    phoneNumber: string
  }

  export type PhoneNumberUncheckedCreateWithoutPeopleInput = {
    phoneNumber: string
  }

  export type PhoneNumberCreateOrConnectWithoutPeopleInput = {
    where: PhoneNumberWhereUniqueInput
    create: XOR<PhoneNumberCreateWithoutPeopleInput, PhoneNumberUncheckedCreateWithoutPeopleInput>
  }

  export type PhoneNumberCreateManyPeopleInputEnvelope = {
    data: PhoneNumberCreateManyPeopleInput | PhoneNumberCreateManyPeopleInput[]
    skipDuplicates?: boolean
  }

  export type employeeCreateWithoutPeopleInput = {
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardCreateNestedManyWithoutEmployeeInput
    manager_employee?: manager_employeeCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutPeopleInput = {
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardUncheckedCreateNestedManyWithoutEmployeeInput
    manager_employee?: manager_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutPeopleInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutPeopleInput, employeeUncheckedCreateWithoutPeopleInput>
  }

  export type studentCreateWithoutPeopleInput = {
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    Dormitory_Card?: Dormitory_CardCreateNestedManyWithoutStudentInput
    relative?: relativeCreateNestedManyWithoutStudentInput
    living_room?: living_roomCreateNestedOneWithoutStudentInput
    studentDiscipline?: studentDisciplineCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutPeopleInput = {
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    building_id?: string | null
    room_id?: string | null
    Dormitory_Card?: Dormitory_CardUncheckedCreateNestedManyWithoutStudentInput
    relative?: relativeUncheckedCreateNestedManyWithoutStudentInput
    studentDiscipline?: studentDisciplineUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutPeopleInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutPeopleInput, studentUncheckedCreateWithoutPeopleInput>
  }

  export type AddressUpsertWithWhereUniqueWithoutPeopleInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutPeopleInput, AddressUncheckedUpdateWithoutPeopleInput>
    create: XOR<AddressCreateWithoutPeopleInput, AddressUncheckedCreateWithoutPeopleInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutPeopleInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutPeopleInput, AddressUncheckedUpdateWithoutPeopleInput>
  }

  export type AddressUpdateManyWithWhereWithoutPeopleInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutPeopleInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    ssn?: StringFilter<"Address"> | string
    commune?: StringFilter<"Address"> | string
    district?: StringFilter<"Address"> | string
    province?: StringFilter<"Address"> | string
  }

  export type EmailUpsertWithWhereUniqueWithoutPeopleInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutPeopleInput, EmailUncheckedUpdateWithoutPeopleInput>
    create: XOR<EmailCreateWithoutPeopleInput, EmailUncheckedCreateWithoutPeopleInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutPeopleInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutPeopleInput, EmailUncheckedUpdateWithoutPeopleInput>
  }

  export type EmailUpdateManyWithWhereWithoutPeopleInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutPeopleInput>
  }

  export type EmailScalarWhereInput = {
    AND?: EmailScalarWhereInput | EmailScalarWhereInput[]
    OR?: EmailScalarWhereInput[]
    NOT?: EmailScalarWhereInput | EmailScalarWhereInput[]
    ssn?: StringFilter<"Email"> | string
    email?: StringFilter<"Email"> | string
  }

  export type PhoneNumberUpsertWithWhereUniqueWithoutPeopleInput = {
    where: PhoneNumberWhereUniqueInput
    update: XOR<PhoneNumberUpdateWithoutPeopleInput, PhoneNumberUncheckedUpdateWithoutPeopleInput>
    create: XOR<PhoneNumberCreateWithoutPeopleInput, PhoneNumberUncheckedCreateWithoutPeopleInput>
  }

  export type PhoneNumberUpdateWithWhereUniqueWithoutPeopleInput = {
    where: PhoneNumberWhereUniqueInput
    data: XOR<PhoneNumberUpdateWithoutPeopleInput, PhoneNumberUncheckedUpdateWithoutPeopleInput>
  }

  export type PhoneNumberUpdateManyWithWhereWithoutPeopleInput = {
    where: PhoneNumberScalarWhereInput
    data: XOR<PhoneNumberUpdateManyMutationInput, PhoneNumberUncheckedUpdateManyWithoutPeopleInput>
  }

  export type PhoneNumberScalarWhereInput = {
    AND?: PhoneNumberScalarWhereInput | PhoneNumberScalarWhereInput[]
    OR?: PhoneNumberScalarWhereInput[]
    NOT?: PhoneNumberScalarWhereInput | PhoneNumberScalarWhereInput[]
    ssn?: StringFilter<"PhoneNumber"> | string
    phoneNumber?: StringFilter<"PhoneNumber"> | string
  }

  export type employeeUpsertWithoutPeopleInput = {
    update: XOR<employeeUpdateWithoutPeopleInput, employeeUncheckedUpdateWithoutPeopleInput>
    create: XOR<employeeCreateWithoutPeopleInput, employeeUncheckedCreateWithoutPeopleInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutPeopleInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutPeopleInput, employeeUncheckedUpdateWithoutPeopleInput>
  }

  export type employeeUpdateWithoutPeopleInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUpdateManyWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUpdateOneWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutPeopleInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUncheckedUpdateManyWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type studentUpsertWithoutPeopleInput = {
    update: XOR<studentUpdateWithoutPeopleInput, studentUncheckedUpdateWithoutPeopleInput>
    create: XOR<studentCreateWithoutPeopleInput, studentUncheckedCreateWithoutPeopleInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutPeopleInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutPeopleInput, studentUncheckedUpdateWithoutPeopleInput>
  }

  export type studentUpdateWithoutPeopleInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUpdateManyWithoutStudentNestedInput
    relative?: relativeUpdateManyWithoutStudentNestedInput
    living_room?: living_roomUpdateOneWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutPeopleInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUncheckedUpdateManyWithoutStudentNestedInput
    relative?: relativeUncheckedUpdateManyWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PeopleCreateWithoutPhoneNumberInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressCreateNestedManyWithoutPeopleInput
    Email?: EmailCreateNestedManyWithoutPeopleInput
    employee?: employeeCreateNestedOneWithoutPeopleInput
    student?: studentCreateNestedOneWithoutPeopleInput
  }

  export type PeopleUncheckedCreateWithoutPhoneNumberInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressUncheckedCreateNestedManyWithoutPeopleInput
    Email?: EmailUncheckedCreateNestedManyWithoutPeopleInput
    employee?: employeeUncheckedCreateNestedOneWithoutPeopleInput
    student?: studentUncheckedCreateNestedOneWithoutPeopleInput
  }

  export type PeopleCreateOrConnectWithoutPhoneNumberInput = {
    where: PeopleWhereUniqueInput
    create: XOR<PeopleCreateWithoutPhoneNumberInput, PeopleUncheckedCreateWithoutPhoneNumberInput>
  }

  export type PeopleUpsertWithoutPhoneNumberInput = {
    update: XOR<PeopleUpdateWithoutPhoneNumberInput, PeopleUncheckedUpdateWithoutPhoneNumberInput>
    create: XOR<PeopleCreateWithoutPhoneNumberInput, PeopleUncheckedCreateWithoutPhoneNumberInput>
    where?: PeopleWhereInput
  }

  export type PeopleUpdateToOneWithWhereWithoutPhoneNumberInput = {
    where?: PeopleWhereInput
    data: XOR<PeopleUpdateWithoutPhoneNumberInput, PeopleUncheckedUpdateWithoutPhoneNumberInput>
  }

  export type PeopleUpdateWithoutPhoneNumberInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUpdateManyWithoutPeopleNestedInput
    Email?: EmailUpdateManyWithoutPeopleNestedInput
    employee?: employeeUpdateOneWithoutPeopleNestedInput
    student?: studentUpdateOneWithoutPeopleNestedInput
  }

  export type PeopleUncheckedUpdateWithoutPhoneNumberInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateManyWithoutPeopleNestedInput
    Email?: EmailUncheckedUpdateManyWithoutPeopleNestedInput
    employee?: employeeUncheckedUpdateOneWithoutPeopleNestedInput
    student?: studentUncheckedUpdateOneWithoutPeopleNestedInput
  }

  export type building_equipmentCreateWithoutBuildingInput = {
    quantity: number
    large_equipment: large_equipmentCreateNestedOneWithoutBuilding_equipmentInput
  }

  export type building_equipmentUncheckedCreateWithoutBuildingInput = {
    equipment_id: string
    quantity: number
  }

  export type building_equipmentCreateOrConnectWithoutBuildingInput = {
    where: building_equipmentWhereUniqueInput
    create: XOR<building_equipmentCreateWithoutBuildingInput, building_equipmentUncheckedCreateWithoutBuildingInput>
  }

  export type building_equipmentCreateManyBuildingInputEnvelope = {
    data: building_equipmentCreateManyBuildingInput | building_equipmentCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type roomCreateWithoutBuildingInput = {
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomCreateNestedOneWithoutRoomInput
    management_room?: management_roomCreateNestedOneWithoutRoomInput
    other_room?: other_roomCreateNestedOneWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutBuildingInput = {
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedCreateNestedOneWithoutRoomInput
    management_room?: management_roomUncheckedCreateNestedOneWithoutRoomInput
    other_room?: other_roomUncheckedCreateNestedOneWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutBuildingInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutBuildingInput, roomUncheckedCreateWithoutBuildingInput>
  }

  export type roomCreateManyBuildingInputEnvelope = {
    data: roomCreateManyBuildingInput | roomCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type building_equipmentUpsertWithWhereUniqueWithoutBuildingInput = {
    where: building_equipmentWhereUniqueInput
    update: XOR<building_equipmentUpdateWithoutBuildingInput, building_equipmentUncheckedUpdateWithoutBuildingInput>
    create: XOR<building_equipmentCreateWithoutBuildingInput, building_equipmentUncheckedCreateWithoutBuildingInput>
  }

  export type building_equipmentUpdateWithWhereUniqueWithoutBuildingInput = {
    where: building_equipmentWhereUniqueInput
    data: XOR<building_equipmentUpdateWithoutBuildingInput, building_equipmentUncheckedUpdateWithoutBuildingInput>
  }

  export type building_equipmentUpdateManyWithWhereWithoutBuildingInput = {
    where: building_equipmentScalarWhereInput
    data: XOR<building_equipmentUpdateManyMutationInput, building_equipmentUncheckedUpdateManyWithoutBuildingInput>
  }

  export type building_equipmentScalarWhereInput = {
    AND?: building_equipmentScalarWhereInput | building_equipmentScalarWhereInput[]
    OR?: building_equipmentScalarWhereInput[]
    NOT?: building_equipmentScalarWhereInput | building_equipmentScalarWhereInput[]
    building_id?: StringFilter<"building_equipment"> | string
    equipment_id?: StringFilter<"building_equipment"> | string
    quantity?: IntFilter<"building_equipment"> | number
  }

  export type roomUpsertWithWhereUniqueWithoutBuildingInput = {
    where: roomWhereUniqueInput
    update: XOR<roomUpdateWithoutBuildingInput, roomUncheckedUpdateWithoutBuildingInput>
    create: XOR<roomCreateWithoutBuildingInput, roomUncheckedCreateWithoutBuildingInput>
  }

  export type roomUpdateWithWhereUniqueWithoutBuildingInput = {
    where: roomWhereUniqueInput
    data: XOR<roomUpdateWithoutBuildingInput, roomUncheckedUpdateWithoutBuildingInput>
  }

  export type roomUpdateManyWithWhereWithoutBuildingInput = {
    where: roomScalarWhereInput
    data: XOR<roomUpdateManyMutationInput, roomUncheckedUpdateManyWithoutBuildingInput>
  }

  export type roomScalarWhereInput = {
    AND?: roomScalarWhereInput | roomScalarWhereInput[]
    OR?: roomScalarWhereInput[]
    NOT?: roomScalarWhereInput | roomScalarWhereInput[]
    building_id?: StringFilter<"room"> | string
    room_id?: StringFilter<"room"> | string
    room_status?: Enumroom_room_statusFilter<"room"> | $Enums.room_room_status
    room_area?: DecimalFilter<"room"> | Decimal | DecimalJsLike | number | string
  }

  export type buildingCreateWithoutBuilding_equipmentInput = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor?: string | null
    construction_date: Date | string
    last_renovation?: Date | string | null
    room?: roomCreateNestedManyWithoutBuildingInput
  }

  export type buildingUncheckedCreateWithoutBuilding_equipmentInput = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor?: string | null
    construction_date: Date | string
    last_renovation?: Date | string | null
    room?: roomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type buildingCreateOrConnectWithoutBuilding_equipmentInput = {
    where: buildingWhereUniqueInput
    create: XOR<buildingCreateWithoutBuilding_equipmentInput, buildingUncheckedCreateWithoutBuilding_equipmentInput>
  }

  export type large_equipmentCreateWithoutBuilding_equipmentInput = {
    equipment_id: string
    equipment_name: string
    equipment_type: string
    equipment_status: $Enums.large_equipment_equipment_status
    purchase_date: Date | string
    purchase_location?: string | null
  }

  export type large_equipmentUncheckedCreateWithoutBuilding_equipmentInput = {
    equipment_id: string
    equipment_name: string
    equipment_type: string
    equipment_status: $Enums.large_equipment_equipment_status
    purchase_date: Date | string
    purchase_location?: string | null
  }

  export type large_equipmentCreateOrConnectWithoutBuilding_equipmentInput = {
    where: large_equipmentWhereUniqueInput
    create: XOR<large_equipmentCreateWithoutBuilding_equipmentInput, large_equipmentUncheckedCreateWithoutBuilding_equipmentInput>
  }

  export type buildingUpsertWithoutBuilding_equipmentInput = {
    update: XOR<buildingUpdateWithoutBuilding_equipmentInput, buildingUncheckedUpdateWithoutBuilding_equipmentInput>
    create: XOR<buildingCreateWithoutBuilding_equipmentInput, buildingUncheckedCreateWithoutBuilding_equipmentInput>
    where?: buildingWhereInput
  }

  export type buildingUpdateToOneWithWhereWithoutBuilding_equipmentInput = {
    where?: buildingWhereInput
    data: XOR<buildingUpdateWithoutBuilding_equipmentInput, buildingUncheckedUpdateWithoutBuilding_equipmentInput>
  }

  export type buildingUpdateWithoutBuilding_equipmentInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: roomUpdateManyWithoutBuildingNestedInput
  }

  export type buildingUncheckedUpdateWithoutBuilding_equipmentInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: roomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type large_equipmentUpsertWithoutBuilding_equipmentInput = {
    update: XOR<large_equipmentUpdateWithoutBuilding_equipmentInput, large_equipmentUncheckedUpdateWithoutBuilding_equipmentInput>
    create: XOR<large_equipmentCreateWithoutBuilding_equipmentInput, large_equipmentUncheckedCreateWithoutBuilding_equipmentInput>
    where?: large_equipmentWhereInput
  }

  export type large_equipmentUpdateToOneWithWhereWithoutBuilding_equipmentInput = {
    where?: large_equipmentWhereInput
    data: XOR<large_equipmentUpdateWithoutBuilding_equipmentInput, large_equipmentUncheckedUpdateWithoutBuilding_equipmentInput>
  }

  export type large_equipmentUpdateWithoutBuilding_equipmentInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    equipment_name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    equipment_status?: Enumlarge_equipment_equipment_statusFieldUpdateOperationsInput | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type large_equipmentUncheckedUpdateWithoutBuilding_equipmentInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    equipment_name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    equipment_status?: Enumlarge_equipment_equipment_statusFieldUpdateOperationsInput | $Enums.large_equipment_equipment_status
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type disciplineStaffCreateWithoutDisciplinaryActionInput = {
    manager_employee: manager_employeeCreateNestedOneWithoutDisciplineStaffInput
  }

  export type disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput = {
    essn: string
  }

  export type disciplineStaffCreateOrConnectWithoutDisciplinaryActionInput = {
    where: disciplineStaffWhereUniqueInput
    create: XOR<disciplineStaffCreateWithoutDisciplinaryActionInput, disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput>
  }

  export type disciplineStaffCreateManyDisciplinaryActionInputEnvelope = {
    data: disciplineStaffCreateManyDisciplinaryActionInput | disciplineStaffCreateManyDisciplinaryActionInput[]
    skipDuplicates?: boolean
  }

  export type studentDisciplineCreateWithoutDisciplinaryActionInput = {
    student: studentCreateNestedOneWithoutStudentDisciplineInput
  }

  export type studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput = {
    Sssn: string
  }

  export type studentDisciplineCreateOrConnectWithoutDisciplinaryActionInput = {
    where: studentDisciplineWhereUniqueInput
    create: XOR<studentDisciplineCreateWithoutDisciplinaryActionInput, studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput>
  }

  export type studentDisciplineCreateManyDisciplinaryActionInputEnvelope = {
    data: studentDisciplineCreateManyDisciplinaryActionInput | studentDisciplineCreateManyDisciplinaryActionInput[]
    skipDuplicates?: boolean
  }

  export type disciplineStaffUpsertWithWhereUniqueWithoutDisciplinaryActionInput = {
    where: disciplineStaffWhereUniqueInput
    update: XOR<disciplineStaffUpdateWithoutDisciplinaryActionInput, disciplineStaffUncheckedUpdateWithoutDisciplinaryActionInput>
    create: XOR<disciplineStaffCreateWithoutDisciplinaryActionInput, disciplineStaffUncheckedCreateWithoutDisciplinaryActionInput>
  }

  export type disciplineStaffUpdateWithWhereUniqueWithoutDisciplinaryActionInput = {
    where: disciplineStaffWhereUniqueInput
    data: XOR<disciplineStaffUpdateWithoutDisciplinaryActionInput, disciplineStaffUncheckedUpdateWithoutDisciplinaryActionInput>
  }

  export type disciplineStaffUpdateManyWithWhereWithoutDisciplinaryActionInput = {
    where: disciplineStaffScalarWhereInput
    data: XOR<disciplineStaffUpdateManyMutationInput, disciplineStaffUncheckedUpdateManyWithoutDisciplinaryActionInput>
  }

  export type disciplineStaffScalarWhereInput = {
    AND?: disciplineStaffScalarWhereInput | disciplineStaffScalarWhereInput[]
    OR?: disciplineStaffScalarWhereInput[]
    NOT?: disciplineStaffScalarWhereInput | disciplineStaffScalarWhereInput[]
    actionId?: StringFilter<"disciplineStaff"> | string
    essn?: StringFilter<"disciplineStaff"> | string
  }

  export type studentDisciplineUpsertWithWhereUniqueWithoutDisciplinaryActionInput = {
    where: studentDisciplineWhereUniqueInput
    update: XOR<studentDisciplineUpdateWithoutDisciplinaryActionInput, studentDisciplineUncheckedUpdateWithoutDisciplinaryActionInput>
    create: XOR<studentDisciplineCreateWithoutDisciplinaryActionInput, studentDisciplineUncheckedCreateWithoutDisciplinaryActionInput>
  }

  export type studentDisciplineUpdateWithWhereUniqueWithoutDisciplinaryActionInput = {
    where: studentDisciplineWhereUniqueInput
    data: XOR<studentDisciplineUpdateWithoutDisciplinaryActionInput, studentDisciplineUncheckedUpdateWithoutDisciplinaryActionInput>
  }

  export type studentDisciplineUpdateManyWithWhereWithoutDisciplinaryActionInput = {
    where: studentDisciplineScalarWhereInput
    data: XOR<studentDisciplineUpdateManyMutationInput, studentDisciplineUncheckedUpdateManyWithoutDisciplinaryActionInput>
  }

  export type studentDisciplineScalarWhereInput = {
    AND?: studentDisciplineScalarWhereInput | studentDisciplineScalarWhereInput[]
    OR?: studentDisciplineScalarWhereInput[]
    NOT?: studentDisciplineScalarWhereInput | studentDisciplineScalarWhereInput[]
    actionId?: StringFilter<"studentDiscipline"> | string
    Sssn?: StringFilter<"studentDiscipline"> | string
  }

  export type disciplinaryActionCreateWithoutDisciplineStaffInput = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date | string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    severityLevel?: string | null
    status?: string | null
    studentDiscipline?: studentDisciplineCreateNestedManyWithoutDisciplinaryActionInput
  }

  export type disciplinaryActionUncheckedCreateWithoutDisciplineStaffInput = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date | string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    severityLevel?: string | null
    status?: string | null
    studentDiscipline?: studentDisciplineUncheckedCreateNestedManyWithoutDisciplinaryActionInput
  }

  export type disciplinaryActionCreateOrConnectWithoutDisciplineStaffInput = {
    where: disciplinaryActionWhereUniqueInput
    create: XOR<disciplinaryActionCreateWithoutDisciplineStaffInput, disciplinaryActionUncheckedCreateWithoutDisciplineStaffInput>
  }

  export type manager_employeeCreateWithoutDisciplineStaffInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    manager_degree?: manager_degreeCreateNestedManyWithoutManager_employeeInput
    management_room?: management_roomCreateNestedOneWithoutManager_employeeInput
    employee: employeeCreateNestedOneWithoutManager_employeeInput
  }

  export type manager_employeeUncheckedCreateWithoutDisciplineStaffInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
    manager_degree?: manager_degreeUncheckedCreateNestedManyWithoutManager_employeeInput
  }

  export type manager_employeeCreateOrConnectWithoutDisciplineStaffInput = {
    where: manager_employeeWhereUniqueInput
    create: XOR<manager_employeeCreateWithoutDisciplineStaffInput, manager_employeeUncheckedCreateWithoutDisciplineStaffInput>
  }

  export type disciplinaryActionUpsertWithoutDisciplineStaffInput = {
    update: XOR<disciplinaryActionUpdateWithoutDisciplineStaffInput, disciplinaryActionUncheckedUpdateWithoutDisciplineStaffInput>
    create: XOR<disciplinaryActionCreateWithoutDisciplineStaffInput, disciplinaryActionUncheckedCreateWithoutDisciplineStaffInput>
    where?: disciplinaryActionWhereInput
  }

  export type disciplinaryActionUpdateToOneWithWhereWithoutDisciplineStaffInput = {
    where?: disciplinaryActionWhereInput
    data: XOR<disciplinaryActionUpdateWithoutDisciplineStaffInput, disciplinaryActionUncheckedUpdateWithoutDisciplineStaffInput>
  }

  export type disciplinaryActionUpdateWithoutDisciplineStaffInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studentDiscipline?: studentDisciplineUpdateManyWithoutDisciplinaryActionNestedInput
  }

  export type disciplinaryActionUncheckedUpdateWithoutDisciplineStaffInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studentDiscipline?: studentDisciplineUncheckedUpdateManyWithoutDisciplinaryActionNestedInput
  }

  export type manager_employeeUpsertWithoutDisciplineStaffInput = {
    update: XOR<manager_employeeUpdateWithoutDisciplineStaffInput, manager_employeeUncheckedUpdateWithoutDisciplineStaffInput>
    create: XOR<manager_employeeCreateWithoutDisciplineStaffInput, manager_employeeUncheckedCreateWithoutDisciplineStaffInput>
    where?: manager_employeeWhereInput
  }

  export type manager_employeeUpdateToOneWithWhereWithoutDisciplineStaffInput = {
    where?: manager_employeeWhereInput
    data: XOR<manager_employeeUpdateWithoutDisciplineStaffInput, manager_employeeUncheckedUpdateWithoutDisciplineStaffInput>
  }

  export type manager_employeeUpdateWithoutDisciplineStaffInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manager_degree?: manager_degreeUpdateManyWithoutManager_employeeNestedInput
    management_room?: management_roomUpdateOneWithoutManager_employeeNestedInput
    employee?: employeeUpdateOneRequiredWithoutManager_employeeNestedInput
  }

  export type manager_employeeUncheckedUpdateWithoutDisciplineStaffInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manager_degree?: manager_degreeUncheckedUpdateManyWithoutManager_employeeNestedInput
  }

  export type Employee_CardCreateWithoutEmployeeInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Employee_Type?: string | null
    Identity_Card: Identity_CardCreateNestedOneWithoutEmployee_CardInput
  }

  export type Employee_CardUncheckedCreateWithoutEmployeeInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Employee_Type?: string | null
  }

  export type Employee_CardCreateOrConnectWithoutEmployeeInput = {
    where: Employee_CardWhereUniqueInput
    create: XOR<Employee_CardCreateWithoutEmployeeInput, Employee_CardUncheckedCreateWithoutEmployeeInput>
  }

  export type Employee_CardCreateManyEmployeeInputEnvelope = {
    data: Employee_CardCreateManyEmployeeInput | Employee_CardCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PeopleCreateWithoutEmployeeInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressCreateNestedManyWithoutPeopleInput
    Email?: EmailCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberCreateNestedManyWithoutPeopleInput
    student?: studentCreateNestedOneWithoutPeopleInput
  }

  export type PeopleUncheckedCreateWithoutEmployeeInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressUncheckedCreateNestedManyWithoutPeopleInput
    Email?: EmailUncheckedCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberUncheckedCreateNestedManyWithoutPeopleInput
    student?: studentUncheckedCreateNestedOneWithoutPeopleInput
  }

  export type PeopleCreateOrConnectWithoutEmployeeInput = {
    where: PeopleWhereUniqueInput
    create: XOR<PeopleCreateWithoutEmployeeInput, PeopleUncheckedCreateWithoutEmployeeInput>
  }

  export type manager_employeeCreateWithoutEmployeeInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffCreateNestedManyWithoutManager_employeeInput
    manager_degree?: manager_degreeCreateNestedManyWithoutManager_employeeInput
    management_room?: management_roomCreateNestedOneWithoutManager_employeeInput
  }

  export type manager_employeeUncheckedCreateWithoutEmployeeInput = {
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedCreateNestedManyWithoutManager_employeeInput
    manager_degree?: manager_degreeUncheckedCreateNestedManyWithoutManager_employeeInput
  }

  export type manager_employeeCreateOrConnectWithoutEmployeeInput = {
    where: manager_employeeWhereUniqueInput
    create: XOR<manager_employeeCreateWithoutEmployeeInput, manager_employeeUncheckedCreateWithoutEmployeeInput>
  }

  export type medical_employeeCreateWithoutEmployeeInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeCreateNestedManyWithoutMedical_employeeInput
    health_room?: health_roomCreateNestedOneWithoutMedical_employeeInput
  }

  export type medical_employeeUncheckedCreateWithoutEmployeeInput = {
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUncheckedCreateNestedManyWithoutMedical_employeeInput
  }

  export type medical_employeeCreateOrConnectWithoutEmployeeInput = {
    where: medical_employeeWhereUniqueInput
    create: XOR<medical_employeeCreateWithoutEmployeeInput, medical_employeeUncheckedCreateWithoutEmployeeInput>
  }

  export type other_employeeCreateWithoutEmployeeInput = {
    typeWork?: string | null
    other_room?: other_roomCreateNestedOneWithoutOther_employeeInput
    other_employee_time_work?: other_employee_time_workCreateNestedManyWithoutOther_employeeInput
  }

  export type other_employeeUncheckedCreateWithoutEmployeeInput = {
    room_id?: string | null
    building_id?: string | null
    typeWork?: string | null
    other_employee_time_work?: other_employee_time_workUncheckedCreateNestedManyWithoutOther_employeeInput
  }

  export type other_employeeCreateOrConnectWithoutEmployeeInput = {
    where: other_employeeWhereUniqueInput
    create: XOR<other_employeeCreateWithoutEmployeeInput, other_employeeUncheckedCreateWithoutEmployeeInput>
  }

  export type Employee_CardUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: Employee_CardWhereUniqueInput
    update: XOR<Employee_CardUpdateWithoutEmployeeInput, Employee_CardUncheckedUpdateWithoutEmployeeInput>
    create: XOR<Employee_CardCreateWithoutEmployeeInput, Employee_CardUncheckedCreateWithoutEmployeeInput>
  }

  export type Employee_CardUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: Employee_CardWhereUniqueInput
    data: XOR<Employee_CardUpdateWithoutEmployeeInput, Employee_CardUncheckedUpdateWithoutEmployeeInput>
  }

  export type Employee_CardUpdateManyWithWhereWithoutEmployeeInput = {
    where: Employee_CardScalarWhereInput
    data: XOR<Employee_CardUpdateManyMutationInput, Employee_CardUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type Employee_CardScalarWhereInput = {
    AND?: Employee_CardScalarWhereInput | Employee_CardScalarWhereInput[]
    OR?: Employee_CardScalarWhereInput[]
    NOT?: Employee_CardScalarWhereInput | Employee_CardScalarWhereInput[]
    Number?: StringFilter<"Employee_Card"> | string
    Start_Date?: DateTimeNullableFilter<"Employee_Card"> | Date | string | null
    End_Date?: DateTimeNullableFilter<"Employee_Card"> | Date | string | null
    ID_Card?: StringFilter<"Employee_Card"> | string
    Employee_Type?: StringNullableFilter<"Employee_Card"> | string | null
  }

  export type PeopleUpsertWithoutEmployeeInput = {
    update: XOR<PeopleUpdateWithoutEmployeeInput, PeopleUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PeopleCreateWithoutEmployeeInput, PeopleUncheckedCreateWithoutEmployeeInput>
    where?: PeopleWhereInput
  }

  export type PeopleUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: PeopleWhereInput
    data: XOR<PeopleUpdateWithoutEmployeeInput, PeopleUncheckedUpdateWithoutEmployeeInput>
  }

  export type PeopleUpdateWithoutEmployeeInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUpdateManyWithoutPeopleNestedInput
    Email?: EmailUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUpdateManyWithoutPeopleNestedInput
    student?: studentUpdateOneWithoutPeopleNestedInput
  }

  export type PeopleUncheckedUpdateWithoutEmployeeInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateManyWithoutPeopleNestedInput
    Email?: EmailUncheckedUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUncheckedUpdateManyWithoutPeopleNestedInput
    student?: studentUncheckedUpdateOneWithoutPeopleNestedInput
  }

  export type manager_employeeUpsertWithoutEmployeeInput = {
    update: XOR<manager_employeeUpdateWithoutEmployeeInput, manager_employeeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<manager_employeeCreateWithoutEmployeeInput, manager_employeeUncheckedCreateWithoutEmployeeInput>
    where?: manager_employeeWhereInput
  }

  export type manager_employeeUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: manager_employeeWhereInput
    data: XOR<manager_employeeUpdateWithoutEmployeeInput, manager_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type manager_employeeUpdateWithoutEmployeeInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUpdateManyWithoutManager_employeeNestedInput
    manager_degree?: manager_degreeUpdateManyWithoutManager_employeeNestedInput
    management_room?: management_roomUpdateOneWithoutManager_employeeNestedInput
  }

  export type manager_employeeUncheckedUpdateWithoutEmployeeInput = {
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedUpdateManyWithoutManager_employeeNestedInput
    manager_degree?: manager_degreeUncheckedUpdateManyWithoutManager_employeeNestedInput
  }

  export type medical_employeeUpsertWithoutEmployeeInput = {
    update: XOR<medical_employeeUpdateWithoutEmployeeInput, medical_employeeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<medical_employeeCreateWithoutEmployeeInput, medical_employeeUncheckedCreateWithoutEmployeeInput>
    where?: medical_employeeWhereInput
  }

  export type medical_employeeUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: medical_employeeWhereInput
    data: XOR<medical_employeeUpdateWithoutEmployeeInput, medical_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type medical_employeeUpdateWithoutEmployeeInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUpdateManyWithoutMedical_employeeNestedInput
    health_room?: health_roomUpdateOneWithoutMedical_employeeNestedInput
  }

  export type medical_employeeUncheckedUpdateWithoutEmployeeInput = {
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUncheckedUpdateManyWithoutMedical_employeeNestedInput
  }

  export type other_employeeUpsertWithoutEmployeeInput = {
    update: XOR<other_employeeUpdateWithoutEmployeeInput, other_employeeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<other_employeeCreateWithoutEmployeeInput, other_employeeUncheckedCreateWithoutEmployeeInput>
    where?: other_employeeWhereInput
  }

  export type other_employeeUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: other_employeeWhereInput
    data: XOR<other_employeeUpdateWithoutEmployeeInput, other_employeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type other_employeeUpdateWithoutEmployeeInput = {
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
    other_room?: other_roomUpdateOneWithoutOther_employeeNestedInput
    other_employee_time_work?: other_employee_time_workUpdateManyWithoutOther_employeeNestedInput
  }

  export type other_employeeUncheckedUpdateWithoutEmployeeInput = {
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
    other_employee_time_work?: other_employee_time_workUncheckedUpdateManyWithoutOther_employeeNestedInput
  }

  export type roomCreateWithoutHealth_roomInput = {
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    management_room?: management_roomCreateNestedOneWithoutRoomInput
    other_room?: other_roomCreateNestedOneWithoutRoomInput
    building: buildingCreateNestedOneWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutHealth_roomInput = {
    building_id: string
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    management_room?: management_roomUncheckedCreateNestedOneWithoutRoomInput
    other_room?: other_roomUncheckedCreateNestedOneWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutHealth_roomInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutHealth_roomInput, roomUncheckedCreateWithoutHealth_roomInput>
  }

  export type medical_employeeCreateWithoutHealth_roomInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeCreateNestedManyWithoutMedical_employeeInput
    employee: employeeCreateNestedOneWithoutMedical_employeeInput
  }

  export type medical_employeeUncheckedCreateWithoutHealth_roomInput = {
    essn: string
    experience?: Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUncheckedCreateNestedManyWithoutMedical_employeeInput
  }

  export type medical_employeeCreateOrConnectWithoutHealth_roomInput = {
    where: medical_employeeWhereUniqueInput
    create: XOR<medical_employeeCreateWithoutHealth_roomInput, medical_employeeUncheckedCreateWithoutHealth_roomInput>
  }

  export type medical_employeeCreateManyHealth_roomInputEnvelope = {
    data: medical_employeeCreateManyHealth_roomInput | medical_employeeCreateManyHealth_roomInput[]
    skipDuplicates?: boolean
  }

  export type roomUpsertWithoutHealth_roomInput = {
    update: XOR<roomUpdateWithoutHealth_roomInput, roomUncheckedUpdateWithoutHealth_roomInput>
    create: XOR<roomCreateWithoutHealth_roomInput, roomUncheckedCreateWithoutHealth_roomInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutHealth_roomInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutHealth_roomInput, roomUncheckedUpdateWithoutHealth_roomInput>
  }

  export type roomUpdateWithoutHealth_roomInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    management_room?: management_roomUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUpdateOneWithoutRoomNestedInput
    building?: buildingUpdateOneRequiredWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutHealth_roomInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    management_room?: management_roomUncheckedUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUncheckedUpdateOneWithoutRoomNestedInput
  }

  export type medical_employeeUpsertWithWhereUniqueWithoutHealth_roomInput = {
    where: medical_employeeWhereUniqueInput
    update: XOR<medical_employeeUpdateWithoutHealth_roomInput, medical_employeeUncheckedUpdateWithoutHealth_roomInput>
    create: XOR<medical_employeeCreateWithoutHealth_roomInput, medical_employeeUncheckedCreateWithoutHealth_roomInput>
  }

  export type medical_employeeUpdateWithWhereUniqueWithoutHealth_roomInput = {
    where: medical_employeeWhereUniqueInput
    data: XOR<medical_employeeUpdateWithoutHealth_roomInput, medical_employeeUncheckedUpdateWithoutHealth_roomInput>
  }

  export type medical_employeeUpdateManyWithWhereWithoutHealth_roomInput = {
    where: medical_employeeScalarWhereInput
    data: XOR<medical_employeeUpdateManyMutationInput, medical_employeeUncheckedUpdateManyWithoutHealth_roomInput>
  }

  export type medical_employeeScalarWhereInput = {
    AND?: medical_employeeScalarWhereInput | medical_employeeScalarWhereInput[]
    OR?: medical_employeeScalarWhereInput[]
    NOT?: medical_employeeScalarWhereInput | medical_employeeScalarWhereInput[]
    essn?: StringFilter<"medical_employee"> | string
    room_id?: StringNullableFilter<"medical_employee"> | string | null
    building_id?: StringNullableFilter<"medical_employee"> | string | null
    experience?: DecimalNullableFilter<"medical_employee"> | Decimal | DecimalJsLike | number | string | null
  }

  export type building_equipmentCreateWithoutLarge_equipmentInput = {
    quantity: number
    building: buildingCreateNestedOneWithoutBuilding_equipmentInput
  }

  export type building_equipmentUncheckedCreateWithoutLarge_equipmentInput = {
    building_id: string
    quantity: number
  }

  export type building_equipmentCreateOrConnectWithoutLarge_equipmentInput = {
    where: building_equipmentWhereUniqueInput
    create: XOR<building_equipmentCreateWithoutLarge_equipmentInput, building_equipmentUncheckedCreateWithoutLarge_equipmentInput>
  }

  export type building_equipmentCreateManyLarge_equipmentInputEnvelope = {
    data: building_equipmentCreateManyLarge_equipmentInput | building_equipmentCreateManyLarge_equipmentInput[]
    skipDuplicates?: boolean
  }

  export type building_equipmentUpsertWithWhereUniqueWithoutLarge_equipmentInput = {
    where: building_equipmentWhereUniqueInput
    update: XOR<building_equipmentUpdateWithoutLarge_equipmentInput, building_equipmentUncheckedUpdateWithoutLarge_equipmentInput>
    create: XOR<building_equipmentCreateWithoutLarge_equipmentInput, building_equipmentUncheckedCreateWithoutLarge_equipmentInput>
  }

  export type building_equipmentUpdateWithWhereUniqueWithoutLarge_equipmentInput = {
    where: building_equipmentWhereUniqueInput
    data: XOR<building_equipmentUpdateWithoutLarge_equipmentInput, building_equipmentUncheckedUpdateWithoutLarge_equipmentInput>
  }

  export type building_equipmentUpdateManyWithWhereWithoutLarge_equipmentInput = {
    where: building_equipmentScalarWhereInput
    data: XOR<building_equipmentUpdateManyMutationInput, building_equipmentUncheckedUpdateManyWithoutLarge_equipmentInput>
  }

  export type studentCreateWithoutLiving_roomInput = {
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    Dormitory_Card?: Dormitory_CardCreateNestedManyWithoutStudentInput
    relative?: relativeCreateNestedManyWithoutStudentInput
    People: PeopleCreateNestedOneWithoutStudentInput
    studentDiscipline?: studentDisciplineCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutLiving_roomInput = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    Dormitory_Card?: Dormitory_CardUncheckedCreateNestedManyWithoutStudentInput
    relative?: relativeUncheckedCreateNestedManyWithoutStudentInput
    studentDiscipline?: studentDisciplineUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutLiving_roomInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutLiving_roomInput, studentUncheckedCreateWithoutLiving_roomInput>
  }

  export type studentCreateManyLiving_roomInputEnvelope = {
    data: studentCreateManyLiving_roomInput | studentCreateManyLiving_roomInput[]
    skipDuplicates?: boolean
  }

  export type studentUpsertWithWhereUniqueWithoutLiving_roomInput = {
    where: studentWhereUniqueInput
    update: XOR<studentUpdateWithoutLiving_roomInput, studentUncheckedUpdateWithoutLiving_roomInput>
    create: XOR<studentCreateWithoutLiving_roomInput, studentUncheckedCreateWithoutLiving_roomInput>
  }

  export type studentUpdateWithWhereUniqueWithoutLiving_roomInput = {
    where: studentWhereUniqueInput
    data: XOR<studentUpdateWithoutLiving_roomInput, studentUncheckedUpdateWithoutLiving_roomInput>
  }

  export type studentUpdateManyWithWhereWithoutLiving_roomInput = {
    where: studentScalarWhereInput
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyWithoutLiving_roomInput>
  }

  export type studentScalarWhereInput = {
    AND?: studentScalarWhereInput | studentScalarWhereInput[]
    OR?: studentScalarWhereInput[]
    NOT?: studentScalarWhereInput | studentScalarWhereInput[]
    Sssn?: StringFilter<"student"> | string
    studentId?: StringFilter<"student"> | string
    hasHealthInsurance?: BoolFilter<"student"> | boolean
    studyStatus?: StringNullableFilter<"student"> | string | null
    className?: StringNullableFilter<"student"> | string | null
    faculty?: StringNullableFilter<"student"> | string | null
    building_id?: StringNullableFilter<"student"> | string | null
    room_id?: StringNullableFilter<"student"> | string | null
  }

  export type roomCreateWithoutManagement_roomInput = {
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomCreateNestedOneWithoutRoomInput
    other_room?: other_roomCreateNestedOneWithoutRoomInput
    building: buildingCreateNestedOneWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutManagement_roomInput = {
    building_id: string
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedCreateNestedOneWithoutRoomInput
    other_room?: other_roomUncheckedCreateNestedOneWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutManagement_roomInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutManagement_roomInput, roomUncheckedCreateWithoutManagement_roomInput>
  }

  export type manager_employeeCreateWithoutManagement_roomInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffCreateNestedManyWithoutManager_employeeInput
    manager_degree?: manager_degreeCreateNestedManyWithoutManager_employeeInput
    employee: employeeCreateNestedOneWithoutManager_employeeInput
  }

  export type manager_employeeUncheckedCreateWithoutManagement_roomInput = {
    essn: string
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedCreateNestedManyWithoutManager_employeeInput
    manager_degree?: manager_degreeUncheckedCreateNestedManyWithoutManager_employeeInput
  }

  export type manager_employeeCreateOrConnectWithoutManagement_roomInput = {
    where: manager_employeeWhereUniqueInput
    create: XOR<manager_employeeCreateWithoutManagement_roomInput, manager_employeeUncheckedCreateWithoutManagement_roomInput>
  }

  export type manager_employeeCreateManyManagement_roomInputEnvelope = {
    data: manager_employeeCreateManyManagement_roomInput | manager_employeeCreateManyManagement_roomInput[]
    skipDuplicates?: boolean
  }

  export type roomUpsertWithoutManagement_roomInput = {
    update: XOR<roomUpdateWithoutManagement_roomInput, roomUncheckedUpdateWithoutManagement_roomInput>
    create: XOR<roomCreateWithoutManagement_roomInput, roomUncheckedCreateWithoutManagement_roomInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutManagement_roomInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutManagement_roomInput, roomUncheckedUpdateWithoutManagement_roomInput>
  }

  export type roomUpdateWithoutManagement_roomInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUpdateOneWithoutRoomNestedInput
    building?: buildingUpdateOneRequiredWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutManagement_roomInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUncheckedUpdateOneWithoutRoomNestedInput
  }

  export type manager_employeeUpsertWithWhereUniqueWithoutManagement_roomInput = {
    where: manager_employeeWhereUniqueInput
    update: XOR<manager_employeeUpdateWithoutManagement_roomInput, manager_employeeUncheckedUpdateWithoutManagement_roomInput>
    create: XOR<manager_employeeCreateWithoutManagement_roomInput, manager_employeeUncheckedCreateWithoutManagement_roomInput>
  }

  export type manager_employeeUpdateWithWhereUniqueWithoutManagement_roomInput = {
    where: manager_employeeWhereUniqueInput
    data: XOR<manager_employeeUpdateWithoutManagement_roomInput, manager_employeeUncheckedUpdateWithoutManagement_roomInput>
  }

  export type manager_employeeUpdateManyWithWhereWithoutManagement_roomInput = {
    where: manager_employeeScalarWhereInput
    data: XOR<manager_employeeUpdateManyMutationInput, manager_employeeUncheckedUpdateManyWithoutManagement_roomInput>
  }

  export type manager_employeeScalarWhereInput = {
    AND?: manager_employeeScalarWhereInput | manager_employeeScalarWhereInput[]
    OR?: manager_employeeScalarWhereInput[]
    NOT?: manager_employeeScalarWhereInput | manager_employeeScalarWhereInput[]
    essn?: StringFilter<"manager_employee"> | string
    room_id?: StringNullableFilter<"manager_employee"> | string | null
    building_id?: StringNullableFilter<"manager_employee"> | string | null
    experience?: DecimalNullableFilter<"manager_employee"> | Decimal | DecimalJsLike | number | string | null
  }

  export type manager_employeeCreateWithoutManager_degreeInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffCreateNestedManyWithoutManager_employeeInput
    management_room?: management_roomCreateNestedOneWithoutManager_employeeInput
    employee: employeeCreateNestedOneWithoutManager_employeeInput
  }

  export type manager_employeeUncheckedCreateWithoutManager_degreeInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedCreateNestedManyWithoutManager_employeeInput
  }

  export type manager_employeeCreateOrConnectWithoutManager_degreeInput = {
    where: manager_employeeWhereUniqueInput
    create: XOR<manager_employeeCreateWithoutManager_degreeInput, manager_employeeUncheckedCreateWithoutManager_degreeInput>
  }

  export type manager_employeeUpsertWithoutManager_degreeInput = {
    update: XOR<manager_employeeUpdateWithoutManager_degreeInput, manager_employeeUncheckedUpdateWithoutManager_degreeInput>
    create: XOR<manager_employeeCreateWithoutManager_degreeInput, manager_employeeUncheckedCreateWithoutManager_degreeInput>
    where?: manager_employeeWhereInput
  }

  export type manager_employeeUpdateToOneWithWhereWithoutManager_degreeInput = {
    where?: manager_employeeWhereInput
    data: XOR<manager_employeeUpdateWithoutManager_degreeInput, manager_employeeUncheckedUpdateWithoutManager_degreeInput>
  }

  export type manager_employeeUpdateWithoutManager_degreeInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUpdateManyWithoutManager_employeeNestedInput
    management_room?: management_roomUpdateOneWithoutManager_employeeNestedInput
    employee?: employeeUpdateOneRequiredWithoutManager_employeeNestedInput
  }

  export type manager_employeeUncheckedUpdateWithoutManager_degreeInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedUpdateManyWithoutManager_employeeNestedInput
  }

  export type disciplineStaffCreateWithoutManager_employeeInput = {
    disciplinaryAction: disciplinaryActionCreateNestedOneWithoutDisciplineStaffInput
  }

  export type disciplineStaffUncheckedCreateWithoutManager_employeeInput = {
    actionId: string
  }

  export type disciplineStaffCreateOrConnectWithoutManager_employeeInput = {
    where: disciplineStaffWhereUniqueInput
    create: XOR<disciplineStaffCreateWithoutManager_employeeInput, disciplineStaffUncheckedCreateWithoutManager_employeeInput>
  }

  export type disciplineStaffCreateManyManager_employeeInputEnvelope = {
    data: disciplineStaffCreateManyManager_employeeInput | disciplineStaffCreateManyManager_employeeInput[]
    skipDuplicates?: boolean
  }

  export type manager_degreeCreateWithoutManager_employeeInput = {
    degree: string
  }

  export type manager_degreeUncheckedCreateWithoutManager_employeeInput = {
    degree: string
  }

  export type manager_degreeCreateOrConnectWithoutManager_employeeInput = {
    where: manager_degreeWhereUniqueInput
    create: XOR<manager_degreeCreateWithoutManager_employeeInput, manager_degreeUncheckedCreateWithoutManager_employeeInput>
  }

  export type manager_degreeCreateManyManager_employeeInputEnvelope = {
    data: manager_degreeCreateManyManager_employeeInput | manager_degreeCreateManyManager_employeeInput[]
    skipDuplicates?: boolean
  }

  export type management_roomCreateWithoutManager_employeeInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    room: roomCreateNestedOneWithoutManagement_roomInput
  }

  export type management_roomUncheckedCreateWithoutManager_employeeInput = {
    building_id: string
    room_id: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
  }

  export type management_roomCreateOrConnectWithoutManager_employeeInput = {
    where: management_roomWhereUniqueInput
    create: XOR<management_roomCreateWithoutManager_employeeInput, management_roomUncheckedCreateWithoutManager_employeeInput>
  }

  export type employeeCreateWithoutManager_employeeInput = {
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardCreateNestedManyWithoutEmployeeInput
    People: PeopleCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutManager_employeeInput = {
    essn: string
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardUncheckedCreateNestedManyWithoutEmployeeInput
    medical_employee?: medical_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutManager_employeeInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutManager_employeeInput, employeeUncheckedCreateWithoutManager_employeeInput>
  }

  export type disciplineStaffUpsertWithWhereUniqueWithoutManager_employeeInput = {
    where: disciplineStaffWhereUniqueInput
    update: XOR<disciplineStaffUpdateWithoutManager_employeeInput, disciplineStaffUncheckedUpdateWithoutManager_employeeInput>
    create: XOR<disciplineStaffCreateWithoutManager_employeeInput, disciplineStaffUncheckedCreateWithoutManager_employeeInput>
  }

  export type disciplineStaffUpdateWithWhereUniqueWithoutManager_employeeInput = {
    where: disciplineStaffWhereUniqueInput
    data: XOR<disciplineStaffUpdateWithoutManager_employeeInput, disciplineStaffUncheckedUpdateWithoutManager_employeeInput>
  }

  export type disciplineStaffUpdateManyWithWhereWithoutManager_employeeInput = {
    where: disciplineStaffScalarWhereInput
    data: XOR<disciplineStaffUpdateManyMutationInput, disciplineStaffUncheckedUpdateManyWithoutManager_employeeInput>
  }

  export type manager_degreeUpsertWithWhereUniqueWithoutManager_employeeInput = {
    where: manager_degreeWhereUniqueInput
    update: XOR<manager_degreeUpdateWithoutManager_employeeInput, manager_degreeUncheckedUpdateWithoutManager_employeeInput>
    create: XOR<manager_degreeCreateWithoutManager_employeeInput, manager_degreeUncheckedCreateWithoutManager_employeeInput>
  }

  export type manager_degreeUpdateWithWhereUniqueWithoutManager_employeeInput = {
    where: manager_degreeWhereUniqueInput
    data: XOR<manager_degreeUpdateWithoutManager_employeeInput, manager_degreeUncheckedUpdateWithoutManager_employeeInput>
  }

  export type manager_degreeUpdateManyWithWhereWithoutManager_employeeInput = {
    where: manager_degreeScalarWhereInput
    data: XOR<manager_degreeUpdateManyMutationInput, manager_degreeUncheckedUpdateManyWithoutManager_employeeInput>
  }

  export type manager_degreeScalarWhereInput = {
    AND?: manager_degreeScalarWhereInput | manager_degreeScalarWhereInput[]
    OR?: manager_degreeScalarWhereInput[]
    NOT?: manager_degreeScalarWhereInput | manager_degreeScalarWhereInput[]
    essn?: StringFilter<"manager_degree"> | string
    degree?: StringFilter<"manager_degree"> | string
  }

  export type management_roomUpsertWithoutManager_employeeInput = {
    update: XOR<management_roomUpdateWithoutManager_employeeInput, management_roomUncheckedUpdateWithoutManager_employeeInput>
    create: XOR<management_roomCreateWithoutManager_employeeInput, management_roomUncheckedCreateWithoutManager_employeeInput>
    where?: management_roomWhereInput
  }

  export type management_roomUpdateToOneWithWhereWithoutManager_employeeInput = {
    where?: management_roomWhereInput
    data: XOR<management_roomUpdateWithoutManager_employeeInput, management_roomUncheckedUpdateWithoutManager_employeeInput>
  }

  export type management_roomUpdateWithoutManager_employeeInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: roomUpdateOneRequiredWithoutManagement_roomNestedInput
  }

  export type management_roomUncheckedUpdateWithoutManager_employeeInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employeeUpsertWithoutManager_employeeInput = {
    update: XOR<employeeUpdateWithoutManager_employeeInput, employeeUncheckedUpdateWithoutManager_employeeInput>
    create: XOR<employeeCreateWithoutManager_employeeInput, employeeUncheckedCreateWithoutManager_employeeInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutManager_employeeInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutManager_employeeInput, employeeUncheckedUpdateWithoutManager_employeeInput>
  }

  export type employeeUpdateWithoutManager_employeeInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUpdateManyWithoutEmployeeNestedInput
    People?: PeopleUpdateOneRequiredWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUpdateOneWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutManager_employeeInput = {
    essn?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUncheckedUpdateManyWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type medical_employeeCreateWithoutMedical_degreeInput = {
    experience?: Decimal | DecimalJsLike | number | string | null
    employee: employeeCreateNestedOneWithoutMedical_employeeInput
    health_room?: health_roomCreateNestedOneWithoutMedical_employeeInput
  }

  export type medical_employeeUncheckedCreateWithoutMedical_degreeInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    experience?: Decimal | DecimalJsLike | number | string | null
  }

  export type medical_employeeCreateOrConnectWithoutMedical_degreeInput = {
    where: medical_employeeWhereUniqueInput
    create: XOR<medical_employeeCreateWithoutMedical_degreeInput, medical_employeeUncheckedCreateWithoutMedical_degreeInput>
  }

  export type medical_employeeUpsertWithoutMedical_degreeInput = {
    update: XOR<medical_employeeUpdateWithoutMedical_degreeInput, medical_employeeUncheckedUpdateWithoutMedical_degreeInput>
    create: XOR<medical_employeeCreateWithoutMedical_degreeInput, medical_employeeUncheckedCreateWithoutMedical_degreeInput>
    where?: medical_employeeWhereInput
  }

  export type medical_employeeUpdateToOneWithWhereWithoutMedical_degreeInput = {
    where?: medical_employeeWhereInput
    data: XOR<medical_employeeUpdateWithoutMedical_degreeInput, medical_employeeUncheckedUpdateWithoutMedical_degreeInput>
  }

  export type medical_employeeUpdateWithoutMedical_degreeInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employee?: employeeUpdateOneRequiredWithoutMedical_employeeNestedInput
    health_room?: health_roomUpdateOneWithoutMedical_employeeNestedInput
  }

  export type medical_employeeUncheckedUpdateWithoutMedical_degreeInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type medical_degreeCreateWithoutMedical_employeeInput = {
    degree: string
  }

  export type medical_degreeUncheckedCreateWithoutMedical_employeeInput = {
    degree: string
  }

  export type medical_degreeCreateOrConnectWithoutMedical_employeeInput = {
    where: medical_degreeWhereUniqueInput
    create: XOR<medical_degreeCreateWithoutMedical_employeeInput, medical_degreeUncheckedCreateWithoutMedical_employeeInput>
  }

  export type medical_degreeCreateManyMedical_employeeInputEnvelope = {
    data: medical_degreeCreateManyMedical_employeeInput | medical_degreeCreateManyMedical_employeeInput[]
    skipDuplicates?: boolean
  }

  export type employeeCreateWithoutMedical_employeeInput = {
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardCreateNestedManyWithoutEmployeeInput
    People: PeopleCreateNestedOneWithoutEmployeeInput
    manager_employee?: manager_employeeCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutMedical_employeeInput = {
    essn: string
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardUncheckedCreateNestedManyWithoutEmployeeInput
    manager_employee?: manager_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    other_employee?: other_employeeUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutMedical_employeeInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutMedical_employeeInput, employeeUncheckedCreateWithoutMedical_employeeInput>
  }

  export type health_roomCreateWithoutMedical_employeeInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    equipment_status: $Enums.health_room_equipment_status
    room: roomCreateNestedOneWithoutHealth_roomInput
  }

  export type health_roomUncheckedCreateWithoutMedical_employeeInput = {
    building_id: string
    room_id: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    equipment_status: $Enums.health_room_equipment_status
  }

  export type health_roomCreateOrConnectWithoutMedical_employeeInput = {
    where: health_roomWhereUniqueInput
    create: XOR<health_roomCreateWithoutMedical_employeeInput, health_roomUncheckedCreateWithoutMedical_employeeInput>
  }

  export type medical_degreeUpsertWithWhereUniqueWithoutMedical_employeeInput = {
    where: medical_degreeWhereUniqueInput
    update: XOR<medical_degreeUpdateWithoutMedical_employeeInput, medical_degreeUncheckedUpdateWithoutMedical_employeeInput>
    create: XOR<medical_degreeCreateWithoutMedical_employeeInput, medical_degreeUncheckedCreateWithoutMedical_employeeInput>
  }

  export type medical_degreeUpdateWithWhereUniqueWithoutMedical_employeeInput = {
    where: medical_degreeWhereUniqueInput
    data: XOR<medical_degreeUpdateWithoutMedical_employeeInput, medical_degreeUncheckedUpdateWithoutMedical_employeeInput>
  }

  export type medical_degreeUpdateManyWithWhereWithoutMedical_employeeInput = {
    where: medical_degreeScalarWhereInput
    data: XOR<medical_degreeUpdateManyMutationInput, medical_degreeUncheckedUpdateManyWithoutMedical_employeeInput>
  }

  export type medical_degreeScalarWhereInput = {
    AND?: medical_degreeScalarWhereInput | medical_degreeScalarWhereInput[]
    OR?: medical_degreeScalarWhereInput[]
    NOT?: medical_degreeScalarWhereInput | medical_degreeScalarWhereInput[]
    essn?: StringFilter<"medical_degree"> | string
    degree?: StringFilter<"medical_degree"> | string
  }

  export type employeeUpsertWithoutMedical_employeeInput = {
    update: XOR<employeeUpdateWithoutMedical_employeeInput, employeeUncheckedUpdateWithoutMedical_employeeInput>
    create: XOR<employeeCreateWithoutMedical_employeeInput, employeeUncheckedCreateWithoutMedical_employeeInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutMedical_employeeInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutMedical_employeeInput, employeeUncheckedUpdateWithoutMedical_employeeInput>
  }

  export type employeeUpdateWithoutMedical_employeeInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUpdateManyWithoutEmployeeNestedInput
    People?: PeopleUpdateOneRequiredWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUpdateOneWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutMedical_employeeInput = {
    essn?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUncheckedUpdateManyWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    other_employee?: other_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type health_roomUpsertWithoutMedical_employeeInput = {
    update: XOR<health_roomUpdateWithoutMedical_employeeInput, health_roomUncheckedUpdateWithoutMedical_employeeInput>
    create: XOR<health_roomCreateWithoutMedical_employeeInput, health_roomUncheckedCreateWithoutMedical_employeeInput>
    where?: health_roomWhereInput
  }

  export type health_roomUpdateToOneWithWhereWithoutMedical_employeeInput = {
    where?: health_roomWhereInput
    data: XOR<health_roomUpdateWithoutMedical_employeeInput, health_roomUncheckedUpdateWithoutMedical_employeeInput>
  }

  export type health_roomUpdateWithoutMedical_employeeInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
    room?: roomUpdateOneRequiredWithoutHealth_roomNestedInput
  }

  export type health_roomUncheckedUpdateWithoutMedical_employeeInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
  }

  export type employeeCreateWithoutOther_employeeInput = {
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardCreateNestedManyWithoutEmployeeInput
    People: PeopleCreateNestedOneWithoutEmployeeInput
    manager_employee?: manager_employeeCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutOther_employeeInput = {
    essn: string
    salary?: Decimal | DecimalJsLike | number | string | null
    empId?: string | null
    Employee_Card?: Employee_CardUncheckedCreateNestedManyWithoutEmployeeInput
    manager_employee?: manager_employeeUncheckedCreateNestedOneWithoutEmployeeInput
    medical_employee?: medical_employeeUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutOther_employeeInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutOther_employeeInput, employeeUncheckedCreateWithoutOther_employeeInput>
  }

  export type other_roomCreateWithoutOther_employeeInput = {
    room_type: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    room: roomCreateNestedOneWithoutOther_roomInput
  }

  export type other_roomUncheckedCreateWithoutOther_employeeInput = {
    building_id: string
    room_id: string
    room_type: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
  }

  export type other_roomCreateOrConnectWithoutOther_employeeInput = {
    where: other_roomWhereUniqueInput
    create: XOR<other_roomCreateWithoutOther_employeeInput, other_roomUncheckedCreateWithoutOther_employeeInput>
  }

  export type other_employee_time_workCreateWithoutOther_employeeInput = {
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date | string
    time_end: Date | string
  }

  export type other_employee_time_workUncheckedCreateWithoutOther_employeeInput = {
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date | string
    time_end: Date | string
  }

  export type other_employee_time_workCreateOrConnectWithoutOther_employeeInput = {
    where: other_employee_time_workWhereUniqueInput
    create: XOR<other_employee_time_workCreateWithoutOther_employeeInput, other_employee_time_workUncheckedCreateWithoutOther_employeeInput>
  }

  export type other_employee_time_workCreateManyOther_employeeInputEnvelope = {
    data: other_employee_time_workCreateManyOther_employeeInput | other_employee_time_workCreateManyOther_employeeInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithoutOther_employeeInput = {
    update: XOR<employeeUpdateWithoutOther_employeeInput, employeeUncheckedUpdateWithoutOther_employeeInput>
    create: XOR<employeeCreateWithoutOther_employeeInput, employeeUncheckedCreateWithoutOther_employeeInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutOther_employeeInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutOther_employeeInput, employeeUncheckedUpdateWithoutOther_employeeInput>
  }

  export type employeeUpdateWithoutOther_employeeInput = {
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUpdateManyWithoutEmployeeNestedInput
    People?: PeopleUpdateOneRequiredWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUpdateOneWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutOther_employeeInput = {
    essn?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    Employee_Card?: Employee_CardUncheckedUpdateManyWithoutEmployeeNestedInput
    manager_employee?: manager_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
    medical_employee?: medical_employeeUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type other_roomUpsertWithoutOther_employeeInput = {
    update: XOR<other_roomUpdateWithoutOther_employeeInput, other_roomUncheckedUpdateWithoutOther_employeeInput>
    create: XOR<other_roomCreateWithoutOther_employeeInput, other_roomUncheckedCreateWithoutOther_employeeInput>
    where?: other_roomWhereInput
  }

  export type other_roomUpdateToOneWithWhereWithoutOther_employeeInput = {
    where?: other_roomWhereInput
    data: XOR<other_roomUpdateWithoutOther_employeeInput, other_roomUncheckedUpdateWithoutOther_employeeInput>
  }

  export type other_roomUpdateWithoutOther_employeeInput = {
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: roomUpdateOneRequiredWithoutOther_roomNestedInput
  }

  export type other_roomUncheckedUpdateWithoutOther_employeeInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_employee_time_workUpsertWithWhereUniqueWithoutOther_employeeInput = {
    where: other_employee_time_workWhereUniqueInput
    update: XOR<other_employee_time_workUpdateWithoutOther_employeeInput, other_employee_time_workUncheckedUpdateWithoutOther_employeeInput>
    create: XOR<other_employee_time_workCreateWithoutOther_employeeInput, other_employee_time_workUncheckedCreateWithoutOther_employeeInput>
  }

  export type other_employee_time_workUpdateWithWhereUniqueWithoutOther_employeeInput = {
    where: other_employee_time_workWhereUniqueInput
    data: XOR<other_employee_time_workUpdateWithoutOther_employeeInput, other_employee_time_workUncheckedUpdateWithoutOther_employeeInput>
  }

  export type other_employee_time_workUpdateManyWithWhereWithoutOther_employeeInput = {
    where: other_employee_time_workScalarWhereInput
    data: XOR<other_employee_time_workUpdateManyMutationInput, other_employee_time_workUncheckedUpdateManyWithoutOther_employeeInput>
  }

  export type other_employee_time_workScalarWhereInput = {
    AND?: other_employee_time_workScalarWhereInput | other_employee_time_workScalarWhereInput[]
    OR?: other_employee_time_workScalarWhereInput[]
    NOT?: other_employee_time_workScalarWhereInput | other_employee_time_workScalarWhereInput[]
    essn?: StringFilter<"other_employee_time_work"> | string
    date_work?: Enumother_employee_time_work_date_workFilter<"other_employee_time_work"> | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFilter<"other_employee_time_work"> | Date | string
    time_end?: DateTimeFilter<"other_employee_time_work"> | Date | string
  }

  export type other_employeeCreateWithoutOther_employee_time_workInput = {
    typeWork?: string | null
    employee: employeeCreateNestedOneWithoutOther_employeeInput
    other_room?: other_roomCreateNestedOneWithoutOther_employeeInput
  }

  export type other_employeeUncheckedCreateWithoutOther_employee_time_workInput = {
    essn: string
    room_id?: string | null
    building_id?: string | null
    typeWork?: string | null
  }

  export type other_employeeCreateOrConnectWithoutOther_employee_time_workInput = {
    where: other_employeeWhereUniqueInput
    create: XOR<other_employeeCreateWithoutOther_employee_time_workInput, other_employeeUncheckedCreateWithoutOther_employee_time_workInput>
  }

  export type other_employeeUpsertWithoutOther_employee_time_workInput = {
    update: XOR<other_employeeUpdateWithoutOther_employee_time_workInput, other_employeeUncheckedUpdateWithoutOther_employee_time_workInput>
    create: XOR<other_employeeCreateWithoutOther_employee_time_workInput, other_employeeUncheckedCreateWithoutOther_employee_time_workInput>
    where?: other_employeeWhereInput
  }

  export type other_employeeUpdateToOneWithWhereWithoutOther_employee_time_workInput = {
    where?: other_employeeWhereInput
    data: XOR<other_employeeUpdateWithoutOther_employee_time_workInput, other_employeeUncheckedUpdateWithoutOther_employee_time_workInput>
  }

  export type other_employeeUpdateWithoutOther_employee_time_workInput = {
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: employeeUpdateOneRequiredWithoutOther_employeeNestedInput
    other_room?: other_roomUpdateOneWithoutOther_employeeNestedInput
  }

  export type other_employeeUncheckedUpdateWithoutOther_employee_time_workInput = {
    essn?: StringFieldUpdateOperationsInput | string
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type other_employeeCreateWithoutOther_roomInput = {
    typeWork?: string | null
    employee: employeeCreateNestedOneWithoutOther_employeeInput
    other_employee_time_work?: other_employee_time_workCreateNestedManyWithoutOther_employeeInput
  }

  export type other_employeeUncheckedCreateWithoutOther_roomInput = {
    essn: string
    typeWork?: string | null
    other_employee_time_work?: other_employee_time_workUncheckedCreateNestedManyWithoutOther_employeeInput
  }

  export type other_employeeCreateOrConnectWithoutOther_roomInput = {
    where: other_employeeWhereUniqueInput
    create: XOR<other_employeeCreateWithoutOther_roomInput, other_employeeUncheckedCreateWithoutOther_roomInput>
  }

  export type other_employeeCreateManyOther_roomInputEnvelope = {
    data: other_employeeCreateManyOther_roomInput | other_employeeCreateManyOther_roomInput[]
    skipDuplicates?: boolean
  }

  export type roomCreateWithoutOther_roomInput = {
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomCreateNestedOneWithoutRoomInput
    management_room?: management_roomCreateNestedOneWithoutRoomInput
    building: buildingCreateNestedOneWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutOther_roomInput = {
    building_id: string
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedCreateNestedOneWithoutRoomInput
    management_room?: management_roomUncheckedCreateNestedOneWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutOther_roomInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutOther_roomInput, roomUncheckedCreateWithoutOther_roomInput>
  }

  export type other_employeeUpsertWithWhereUniqueWithoutOther_roomInput = {
    where: other_employeeWhereUniqueInput
    update: XOR<other_employeeUpdateWithoutOther_roomInput, other_employeeUncheckedUpdateWithoutOther_roomInput>
    create: XOR<other_employeeCreateWithoutOther_roomInput, other_employeeUncheckedCreateWithoutOther_roomInput>
  }

  export type other_employeeUpdateWithWhereUniqueWithoutOther_roomInput = {
    where: other_employeeWhereUniqueInput
    data: XOR<other_employeeUpdateWithoutOther_roomInput, other_employeeUncheckedUpdateWithoutOther_roomInput>
  }

  export type other_employeeUpdateManyWithWhereWithoutOther_roomInput = {
    where: other_employeeScalarWhereInput
    data: XOR<other_employeeUpdateManyMutationInput, other_employeeUncheckedUpdateManyWithoutOther_roomInput>
  }

  export type other_employeeScalarWhereInput = {
    AND?: other_employeeScalarWhereInput | other_employeeScalarWhereInput[]
    OR?: other_employeeScalarWhereInput[]
    NOT?: other_employeeScalarWhereInput | other_employeeScalarWhereInput[]
    essn?: StringFilter<"other_employee"> | string
    room_id?: StringNullableFilter<"other_employee"> | string | null
    building_id?: StringNullableFilter<"other_employee"> | string | null
    typeWork?: StringNullableFilter<"other_employee"> | string | null
  }

  export type roomUpsertWithoutOther_roomInput = {
    update: XOR<roomUpdateWithoutOther_roomInput, roomUncheckedUpdateWithoutOther_roomInput>
    create: XOR<roomCreateWithoutOther_roomInput, roomUncheckedCreateWithoutOther_roomInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutOther_roomInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutOther_roomInput, roomUncheckedUpdateWithoutOther_roomInput>
  }

  export type roomUpdateWithoutOther_roomInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUpdateOneWithoutRoomNestedInput
    management_room?: management_roomUpdateOneWithoutRoomNestedInput
    building?: buildingUpdateOneRequiredWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutOther_roomInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedUpdateOneWithoutRoomNestedInput
    management_room?: management_roomUncheckedUpdateOneWithoutRoomNestedInput
  }

  export type studentCreateWithoutRelativeInput = {
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    Dormitory_Card?: Dormitory_CardCreateNestedManyWithoutStudentInput
    People: PeopleCreateNestedOneWithoutStudentInput
    living_room?: living_roomCreateNestedOneWithoutStudentInput
    studentDiscipline?: studentDisciplineCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutRelativeInput = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    building_id?: string | null
    room_id?: string | null
    Dormitory_Card?: Dormitory_CardUncheckedCreateNestedManyWithoutStudentInput
    studentDiscipline?: studentDisciplineUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutRelativeInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutRelativeInput, studentUncheckedCreateWithoutRelativeInput>
  }

  export type studentUpsertWithoutRelativeInput = {
    update: XOR<studentUpdateWithoutRelativeInput, studentUncheckedUpdateWithoutRelativeInput>
    create: XOR<studentCreateWithoutRelativeInput, studentUncheckedCreateWithoutRelativeInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutRelativeInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutRelativeInput, studentUncheckedUpdateWithoutRelativeInput>
  }

  export type studentUpdateWithoutRelativeInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUpdateManyWithoutStudentNestedInput
    People?: PeopleUpdateOneRequiredWithoutStudentNestedInput
    living_room?: living_roomUpdateOneWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutRelativeInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUncheckedUpdateManyWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type health_roomCreateWithoutRoomInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    equipment_status: $Enums.health_room_equipment_status
    medical_employee?: medical_employeeCreateNestedManyWithoutHealth_roomInput
  }

  export type health_roomUncheckedCreateWithoutRoomInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    equipment_status: $Enums.health_room_equipment_status
    medical_employee?: medical_employeeUncheckedCreateNestedManyWithoutHealth_roomInput
  }

  export type health_roomCreateOrConnectWithoutRoomInput = {
    where: health_roomWhereUniqueInput
    create: XOR<health_roomCreateWithoutRoomInput, health_roomUncheckedCreateWithoutRoomInput>
  }

  export type management_roomCreateWithoutRoomInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    manager_employee?: manager_employeeCreateNestedManyWithoutManagement_roomInput
  }

  export type management_roomUncheckedCreateWithoutRoomInput = {
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    manager_employee?: manager_employeeUncheckedCreateNestedManyWithoutManagement_roomInput
  }

  export type management_roomCreateOrConnectWithoutRoomInput = {
    where: management_roomWhereUniqueInput
    create: XOR<management_roomCreateWithoutRoomInput, management_roomUncheckedCreateWithoutRoomInput>
  }

  export type other_roomCreateWithoutRoomInput = {
    room_type: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    other_employee?: other_employeeCreateNestedManyWithoutOther_roomInput
  }

  export type other_roomUncheckedCreateWithoutRoomInput = {
    room_type: string
    num_of_staff?: number
    start_time: Date | string
    end_time: Date | string
    other_employee?: other_employeeUncheckedCreateNestedManyWithoutOther_roomInput
  }

  export type other_roomCreateOrConnectWithoutRoomInput = {
    where: other_roomWhereUniqueInput
    create: XOR<other_roomCreateWithoutRoomInput, other_roomUncheckedCreateWithoutRoomInput>
  }

  export type buildingCreateWithoutRoomInput = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor?: string | null
    construction_date: Date | string
    last_renovation?: Date | string | null
    building_equipment?: building_equipmentCreateNestedManyWithoutBuildingInput
  }

  export type buildingUncheckedCreateWithoutRoomInput = {
    building_id: string
    building_name: string
    floors: number
    rooms: number
    has_air_conditioner: boolean
    sponsor?: string | null
    construction_date: Date | string
    last_renovation?: Date | string | null
    building_equipment?: building_equipmentUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type buildingCreateOrConnectWithoutRoomInput = {
    where: buildingWhereUniqueInput
    create: XOR<buildingCreateWithoutRoomInput, buildingUncheckedCreateWithoutRoomInput>
  }

  export type health_roomUpsertWithoutRoomInput = {
    update: XOR<health_roomUpdateWithoutRoomInput, health_roomUncheckedUpdateWithoutRoomInput>
    create: XOR<health_roomCreateWithoutRoomInput, health_roomUncheckedCreateWithoutRoomInput>
    where?: health_roomWhereInput
  }

  export type health_roomUpdateToOneWithWhereWithoutRoomInput = {
    where?: health_roomWhereInput
    data: XOR<health_roomUpdateWithoutRoomInput, health_roomUncheckedUpdateWithoutRoomInput>
  }

  export type health_roomUpdateWithoutRoomInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
    medical_employee?: medical_employeeUpdateManyWithoutHealth_roomNestedInput
  }

  export type health_roomUncheckedUpdateWithoutRoomInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment_status?: Enumhealth_room_equipment_statusFieldUpdateOperationsInput | $Enums.health_room_equipment_status
    medical_employee?: medical_employeeUncheckedUpdateManyWithoutHealth_roomNestedInput
  }

  export type management_roomUpsertWithoutRoomInput = {
    update: XOR<management_roomUpdateWithoutRoomInput, management_roomUncheckedUpdateWithoutRoomInput>
    create: XOR<management_roomCreateWithoutRoomInput, management_roomUncheckedCreateWithoutRoomInput>
    where?: management_roomWhereInput
  }

  export type management_roomUpdateToOneWithWhereWithoutRoomInput = {
    where?: management_roomWhereInput
    data: XOR<management_roomUpdateWithoutRoomInput, management_roomUncheckedUpdateWithoutRoomInput>
  }

  export type management_roomUpdateWithoutRoomInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    manager_employee?: manager_employeeUpdateManyWithoutManagement_roomNestedInput
  }

  export type management_roomUncheckedUpdateWithoutRoomInput = {
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    manager_employee?: manager_employeeUncheckedUpdateManyWithoutManagement_roomNestedInput
  }

  export type other_roomUpsertWithoutRoomInput = {
    update: XOR<other_roomUpdateWithoutRoomInput, other_roomUncheckedUpdateWithoutRoomInput>
    create: XOR<other_roomCreateWithoutRoomInput, other_roomUncheckedCreateWithoutRoomInput>
    where?: other_roomWhereInput
  }

  export type other_roomUpdateToOneWithWhereWithoutRoomInput = {
    where?: other_roomWhereInput
    data: XOR<other_roomUpdateWithoutRoomInput, other_roomUncheckedUpdateWithoutRoomInput>
  }

  export type other_roomUpdateWithoutRoomInput = {
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    other_employee?: other_employeeUpdateManyWithoutOther_roomNestedInput
  }

  export type other_roomUncheckedUpdateWithoutRoomInput = {
    room_type?: StringFieldUpdateOperationsInput | string
    num_of_staff?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    other_employee?: other_employeeUncheckedUpdateManyWithoutOther_roomNestedInput
  }

  export type buildingUpsertWithoutRoomInput = {
    update: XOR<buildingUpdateWithoutRoomInput, buildingUncheckedUpdateWithoutRoomInput>
    create: XOR<buildingCreateWithoutRoomInput, buildingUncheckedCreateWithoutRoomInput>
    where?: buildingWhereInput
  }

  export type buildingUpdateToOneWithWhereWithoutRoomInput = {
    where?: buildingWhereInput
    data: XOR<buildingUpdateWithoutRoomInput, buildingUncheckedUpdateWithoutRoomInput>
  }

  export type buildingUpdateWithoutRoomInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    building_equipment?: building_equipmentUpdateManyWithoutBuildingNestedInput
  }

  export type buildingUncheckedUpdateWithoutRoomInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    building_name?: StringFieldUpdateOperationsInput | string
    floors?: IntFieldUpdateOperationsInput | number
    rooms?: IntFieldUpdateOperationsInput | number
    has_air_conditioner?: BoolFieldUpdateOperationsInput | boolean
    sponsor?: NullableStringFieldUpdateOperationsInput | string | null
    construction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_renovation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    building_equipment?: building_equipmentUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type Dormitory_CardCreateWithoutStudentInput = {
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Validity?: boolean | null
    Identity_Card: Identity_CardCreateNestedOneWithoutDormitory_CardInput
  }

  export type Dormitory_CardUncheckedCreateWithoutStudentInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Validity?: boolean | null
  }

  export type Dormitory_CardCreateOrConnectWithoutStudentInput = {
    where: Dormitory_CardWhereUniqueInput
    create: XOR<Dormitory_CardCreateWithoutStudentInput, Dormitory_CardUncheckedCreateWithoutStudentInput>
  }

  export type Dormitory_CardCreateManyStudentInputEnvelope = {
    data: Dormitory_CardCreateManyStudentInput | Dormitory_CardCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type relativeCreateWithoutStudentInput = {
    fname: string
    lname: string
    birthday: Date | string
    relationship: string
    address: string
    phoneNumber?: string | null
    job?: string | null
  }

  export type relativeUncheckedCreateWithoutStudentInput = {
    fname: string
    lname: string
    birthday: Date | string
    relationship: string
    address: string
    phoneNumber?: string | null
    job?: string | null
  }

  export type relativeCreateOrConnectWithoutStudentInput = {
    where: relativeWhereUniqueInput
    create: XOR<relativeCreateWithoutStudentInput, relativeUncheckedCreateWithoutStudentInput>
  }

  export type relativeCreateManyStudentInputEnvelope = {
    data: relativeCreateManyStudentInput | relativeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PeopleCreateWithoutStudentInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressCreateNestedManyWithoutPeopleInput
    Email?: EmailCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberCreateNestedManyWithoutPeopleInput
    employee?: employeeCreateNestedOneWithoutPeopleInput
  }

  export type PeopleUncheckedCreateWithoutStudentInput = {
    SSN: string
    Full_Name: string
    Last_Name: string
    Birthday: Date | string
    Sex?: string | null
    Health_State?: string | null
    Ethnic_Group?: string | null
    Address?: AddressUncheckedCreateNestedManyWithoutPeopleInput
    Email?: EmailUncheckedCreateNestedManyWithoutPeopleInput
    PhoneNumber?: PhoneNumberUncheckedCreateNestedManyWithoutPeopleInput
    employee?: employeeUncheckedCreateNestedOneWithoutPeopleInput
  }

  export type PeopleCreateOrConnectWithoutStudentInput = {
    where: PeopleWhereUniqueInput
    create: XOR<PeopleCreateWithoutStudentInput, PeopleUncheckedCreateWithoutStudentInput>
  }

  export type living_roomCreateWithoutStudentInput = {
    building_id: string
    room_id: string
    max_num_of_students: number
    current_num_of_students?: number
    rental_price: Decimal | DecimalJsLike | number | string
    occupancy_rate?: Decimal | DecimalJsLike | number | string
  }

  export type living_roomUncheckedCreateWithoutStudentInput = {
    building_id: string
    room_id: string
    max_num_of_students: number
    current_num_of_students?: number
    rental_price: Decimal | DecimalJsLike | number | string
    occupancy_rate?: Decimal | DecimalJsLike | number | string
  }

  export type living_roomCreateOrConnectWithoutStudentInput = {
    where: living_roomWhereUniqueInput
    create: XOR<living_roomCreateWithoutStudentInput, living_roomUncheckedCreateWithoutStudentInput>
  }

  export type studentDisciplineCreateWithoutStudentInput = {
    disciplinaryAction: disciplinaryActionCreateNestedOneWithoutStudentDisciplineInput
  }

  export type studentDisciplineUncheckedCreateWithoutStudentInput = {
    actionId: string
  }

  export type studentDisciplineCreateOrConnectWithoutStudentInput = {
    where: studentDisciplineWhereUniqueInput
    create: XOR<studentDisciplineCreateWithoutStudentInput, studentDisciplineUncheckedCreateWithoutStudentInput>
  }

  export type studentDisciplineCreateManyStudentInputEnvelope = {
    data: studentDisciplineCreateManyStudentInput | studentDisciplineCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type Dormitory_CardUpsertWithWhereUniqueWithoutStudentInput = {
    where: Dormitory_CardWhereUniqueInput
    update: XOR<Dormitory_CardUpdateWithoutStudentInput, Dormitory_CardUncheckedUpdateWithoutStudentInput>
    create: XOR<Dormitory_CardCreateWithoutStudentInput, Dormitory_CardUncheckedCreateWithoutStudentInput>
  }

  export type Dormitory_CardUpdateWithWhereUniqueWithoutStudentInput = {
    where: Dormitory_CardWhereUniqueInput
    data: XOR<Dormitory_CardUpdateWithoutStudentInput, Dormitory_CardUncheckedUpdateWithoutStudentInput>
  }

  export type Dormitory_CardUpdateManyWithWhereWithoutStudentInput = {
    where: Dormitory_CardScalarWhereInput
    data: XOR<Dormitory_CardUpdateManyMutationInput, Dormitory_CardUncheckedUpdateManyWithoutStudentInput>
  }

  export type Dormitory_CardScalarWhereInput = {
    AND?: Dormitory_CardScalarWhereInput | Dormitory_CardScalarWhereInput[]
    OR?: Dormitory_CardScalarWhereInput[]
    NOT?: Dormitory_CardScalarWhereInput | Dormitory_CardScalarWhereInput[]
    Number?: StringFilter<"Dormitory_Card"> | string
    Start_Date?: DateTimeNullableFilter<"Dormitory_Card"> | Date | string | null
    End_Date?: DateTimeNullableFilter<"Dormitory_Card"> | Date | string | null
    ID_Card?: StringFilter<"Dormitory_Card"> | string
    Validity?: BoolNullableFilter<"Dormitory_Card"> | boolean | null
  }

  export type relativeUpsertWithWhereUniqueWithoutStudentInput = {
    where: relativeWhereUniqueInput
    update: XOR<relativeUpdateWithoutStudentInput, relativeUncheckedUpdateWithoutStudentInput>
    create: XOR<relativeCreateWithoutStudentInput, relativeUncheckedCreateWithoutStudentInput>
  }

  export type relativeUpdateWithWhereUniqueWithoutStudentInput = {
    where: relativeWhereUniqueInput
    data: XOR<relativeUpdateWithoutStudentInput, relativeUncheckedUpdateWithoutStudentInput>
  }

  export type relativeUpdateManyWithWhereWithoutStudentInput = {
    where: relativeScalarWhereInput
    data: XOR<relativeUpdateManyMutationInput, relativeUncheckedUpdateManyWithoutStudentInput>
  }

  export type relativeScalarWhereInput = {
    AND?: relativeScalarWhereInput | relativeScalarWhereInput[]
    OR?: relativeScalarWhereInput[]
    NOT?: relativeScalarWhereInput | relativeScalarWhereInput[]
    Sssn?: StringFilter<"relative"> | string
    fname?: StringFilter<"relative"> | string
    lname?: StringFilter<"relative"> | string
    birthday?: DateTimeFilter<"relative"> | Date | string
    relationship?: StringFilter<"relative"> | string
    address?: StringFilter<"relative"> | string
    phoneNumber?: StringNullableFilter<"relative"> | string | null
    job?: StringNullableFilter<"relative"> | string | null
  }

  export type PeopleUpsertWithoutStudentInput = {
    update: XOR<PeopleUpdateWithoutStudentInput, PeopleUncheckedUpdateWithoutStudentInput>
    create: XOR<PeopleCreateWithoutStudentInput, PeopleUncheckedCreateWithoutStudentInput>
    where?: PeopleWhereInput
  }

  export type PeopleUpdateToOneWithWhereWithoutStudentInput = {
    where?: PeopleWhereInput
    data: XOR<PeopleUpdateWithoutStudentInput, PeopleUncheckedUpdateWithoutStudentInput>
  }

  export type PeopleUpdateWithoutStudentInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUpdateManyWithoutPeopleNestedInput
    Email?: EmailUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUpdateManyWithoutPeopleNestedInput
    employee?: employeeUpdateOneWithoutPeopleNestedInput
  }

  export type PeopleUncheckedUpdateWithoutStudentInput = {
    SSN?: StringFieldUpdateOperationsInput | string
    Full_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    Sex?: NullableStringFieldUpdateOperationsInput | string | null
    Health_State?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnic_Group?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateManyWithoutPeopleNestedInput
    Email?: EmailUncheckedUpdateManyWithoutPeopleNestedInput
    PhoneNumber?: PhoneNumberUncheckedUpdateManyWithoutPeopleNestedInput
    employee?: employeeUncheckedUpdateOneWithoutPeopleNestedInput
  }

  export type living_roomUpsertWithoutStudentInput = {
    update: XOR<living_roomUpdateWithoutStudentInput, living_roomUncheckedUpdateWithoutStudentInput>
    create: XOR<living_roomCreateWithoutStudentInput, living_roomUncheckedCreateWithoutStudentInput>
    where?: living_roomWhereInput
  }

  export type living_roomUpdateToOneWithWhereWithoutStudentInput = {
    where?: living_roomWhereInput
    data: XOR<living_roomUpdateWithoutStudentInput, living_roomUncheckedUpdateWithoutStudentInput>
  }

  export type living_roomUpdateWithoutStudentInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    max_num_of_students?: IntFieldUpdateOperationsInput | number
    current_num_of_students?: IntFieldUpdateOperationsInput | number
    rental_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type living_roomUncheckedUpdateWithoutStudentInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    max_num_of_students?: IntFieldUpdateOperationsInput | number
    current_num_of_students?: IntFieldUpdateOperationsInput | number
    rental_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupancy_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type studentDisciplineUpsertWithWhereUniqueWithoutStudentInput = {
    where: studentDisciplineWhereUniqueInput
    update: XOR<studentDisciplineUpdateWithoutStudentInput, studentDisciplineUncheckedUpdateWithoutStudentInput>
    create: XOR<studentDisciplineCreateWithoutStudentInput, studentDisciplineUncheckedCreateWithoutStudentInput>
  }

  export type studentDisciplineUpdateWithWhereUniqueWithoutStudentInput = {
    where: studentDisciplineWhereUniqueInput
    data: XOR<studentDisciplineUpdateWithoutStudentInput, studentDisciplineUncheckedUpdateWithoutStudentInput>
  }

  export type studentDisciplineUpdateManyWithWhereWithoutStudentInput = {
    where: studentDisciplineScalarWhereInput
    data: XOR<studentDisciplineUpdateManyMutationInput, studentDisciplineUncheckedUpdateManyWithoutStudentInput>
  }

  export type disciplinaryActionCreateWithoutStudentDisciplineInput = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date | string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    severityLevel?: string | null
    status?: string | null
    disciplineStaff?: disciplineStaffCreateNestedManyWithoutDisciplinaryActionInput
  }

  export type disciplinaryActionUncheckedCreateWithoutStudentDisciplineInput = {
    actionId: string
    actionType: string
    reason: string
    decisionDate: Date | string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    severityLevel?: string | null
    status?: string | null
    disciplineStaff?: disciplineStaffUncheckedCreateNestedManyWithoutDisciplinaryActionInput
  }

  export type disciplinaryActionCreateOrConnectWithoutStudentDisciplineInput = {
    where: disciplinaryActionWhereUniqueInput
    create: XOR<disciplinaryActionCreateWithoutStudentDisciplineInput, disciplinaryActionUncheckedCreateWithoutStudentDisciplineInput>
  }

  export type studentCreateWithoutStudentDisciplineInput = {
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    Dormitory_Card?: Dormitory_CardCreateNestedManyWithoutStudentInput
    relative?: relativeCreateNestedManyWithoutStudentInput
    People: PeopleCreateNestedOneWithoutStudentInput
    living_room?: living_roomCreateNestedOneWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutStudentDisciplineInput = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
    building_id?: string | null
    room_id?: string | null
    Dormitory_Card?: Dormitory_CardUncheckedCreateNestedManyWithoutStudentInput
    relative?: relativeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutStudentDisciplineInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutStudentDisciplineInput, studentUncheckedCreateWithoutStudentDisciplineInput>
  }

  export type disciplinaryActionUpsertWithoutStudentDisciplineInput = {
    update: XOR<disciplinaryActionUpdateWithoutStudentDisciplineInput, disciplinaryActionUncheckedUpdateWithoutStudentDisciplineInput>
    create: XOR<disciplinaryActionCreateWithoutStudentDisciplineInput, disciplinaryActionUncheckedCreateWithoutStudentDisciplineInput>
    where?: disciplinaryActionWhereInput
  }

  export type disciplinaryActionUpdateToOneWithWhereWithoutStudentDisciplineInput = {
    where?: disciplinaryActionWhereInput
    data: XOR<disciplinaryActionUpdateWithoutStudentDisciplineInput, disciplinaryActionUncheckedUpdateWithoutStudentDisciplineInput>
  }

  export type disciplinaryActionUpdateWithoutStudentDisciplineInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    disciplineStaff?: disciplineStaffUpdateManyWithoutDisciplinaryActionNestedInput
  }

  export type disciplinaryActionUncheckedUpdateWithoutStudentDisciplineInput = {
    actionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    disciplineStaff?: disciplineStaffUncheckedUpdateManyWithoutDisciplinaryActionNestedInput
  }

  export type studentUpsertWithoutStudentDisciplineInput = {
    update: XOR<studentUpdateWithoutStudentDisciplineInput, studentUncheckedUpdateWithoutStudentDisciplineInput>
    create: XOR<studentCreateWithoutStudentDisciplineInput, studentUncheckedCreateWithoutStudentDisciplineInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutStudentDisciplineInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutStudentDisciplineInput, studentUncheckedUpdateWithoutStudentDisciplineInput>
  }

  export type studentUpdateWithoutStudentDisciplineInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUpdateManyWithoutStudentNestedInput
    relative?: relativeUpdateManyWithoutStudentNestedInput
    People?: PeopleUpdateOneRequiredWithoutStudentNestedInput
    living_room?: living_roomUpdateOneWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutStudentDisciplineInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    building_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUncheckedUpdateManyWithoutStudentNestedInput
    relative?: relativeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AddressCreateManyPeopleInput = {
    commune: string
    district: string
    province: string
  }

  export type EmailCreateManyPeopleInput = {
    email: string
  }

  export type PhoneNumberCreateManyPeopleInput = {
    phoneNumber: string
  }

  export type AddressUpdateWithoutPeopleInput = {
    commune?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateWithoutPeopleInput = {
    commune?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutPeopleInput = {
    commune?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
  }

  export type EmailUpdateWithoutPeopleInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type EmailUncheckedUpdateWithoutPeopleInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type EmailUncheckedUpdateManyWithoutPeopleInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneNumberUpdateWithoutPeopleInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneNumberUncheckedUpdateWithoutPeopleInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneNumberUncheckedUpdateManyWithoutPeopleInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type building_equipmentCreateManyBuildingInput = {
    equipment_id: string
    quantity: number
  }

  export type roomCreateManyBuildingInput = {
    room_id: string
    room_status: $Enums.room_room_status
    room_area: Decimal | DecimalJsLike | number | string
  }

  export type building_equipmentUpdateWithoutBuildingInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    large_equipment?: large_equipmentUpdateOneRequiredWithoutBuilding_equipmentNestedInput
  }

  export type building_equipmentUncheckedUpdateWithoutBuildingInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type building_equipmentUncheckedUpdateManyWithoutBuildingInput = {
    equipment_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type roomUpdateWithoutBuildingInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUpdateOneWithoutRoomNestedInput
    management_room?: management_roomUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUpdateOneWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutBuildingInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_room?: health_roomUncheckedUpdateOneWithoutRoomNestedInput
    management_room?: management_roomUncheckedUpdateOneWithoutRoomNestedInput
    other_room?: other_roomUncheckedUpdateOneWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateManyWithoutBuildingInput = {
    room_id?: StringFieldUpdateOperationsInput | string
    room_status?: Enumroom_room_statusFieldUpdateOperationsInput | $Enums.room_room_status
    room_area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type disciplineStaffCreateManyDisciplinaryActionInput = {
    essn: string
  }

  export type studentDisciplineCreateManyDisciplinaryActionInput = {
    Sssn: string
  }

  export type disciplineStaffUpdateWithoutDisciplinaryActionInput = {
    manager_employee?: manager_employeeUpdateOneRequiredWithoutDisciplineStaffNestedInput
  }

  export type disciplineStaffUncheckedUpdateWithoutDisciplinaryActionInput = {
    essn?: StringFieldUpdateOperationsInput | string
  }

  export type disciplineStaffUncheckedUpdateManyWithoutDisciplinaryActionInput = {
    essn?: StringFieldUpdateOperationsInput | string
  }

  export type studentDisciplineUpdateWithoutDisciplinaryActionInput = {
    student?: studentUpdateOneRequiredWithoutStudentDisciplineNestedInput
  }

  export type studentDisciplineUncheckedUpdateWithoutDisciplinaryActionInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
  }

  export type studentDisciplineUncheckedUpdateManyWithoutDisciplinaryActionInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
  }

  export type Employee_CardCreateManyEmployeeInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Employee_Type?: string | null
  }

  export type Employee_CardUpdateWithoutEmployeeInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
    Identity_Card?: Identity_CardUpdateOneRequiredWithoutEmployee_CardNestedInput
  }

  export type Employee_CardUncheckedUpdateWithoutEmployeeInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Employee_CardUncheckedUpdateManyWithoutEmployeeInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee_Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medical_employeeCreateManyHealth_roomInput = {
    essn: string
    experience?: Decimal | DecimalJsLike | number | string | null
  }

  export type medical_employeeUpdateWithoutHealth_roomInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUpdateManyWithoutMedical_employeeNestedInput
    employee?: employeeUpdateOneRequiredWithoutMedical_employeeNestedInput
  }

  export type medical_employeeUncheckedUpdateWithoutHealth_roomInput = {
    essn?: StringFieldUpdateOperationsInput | string
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_degree?: medical_degreeUncheckedUpdateManyWithoutMedical_employeeNestedInput
  }

  export type medical_employeeUncheckedUpdateManyWithoutHealth_roomInput = {
    essn?: StringFieldUpdateOperationsInput | string
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type building_equipmentCreateManyLarge_equipmentInput = {
    building_id: string
    quantity: number
  }

  export type building_equipmentUpdateWithoutLarge_equipmentInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    building?: buildingUpdateOneRequiredWithoutBuilding_equipmentNestedInput
  }

  export type building_equipmentUncheckedUpdateWithoutLarge_equipmentInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type building_equipmentUncheckedUpdateManyWithoutLarge_equipmentInput = {
    building_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type studentCreateManyLiving_roomInput = {
    Sssn: string
    studentId: string
    hasHealthInsurance: boolean
    studyStatus?: string | null
    className?: string | null
    faculty?: string | null
  }

  export type studentUpdateWithoutLiving_roomInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUpdateManyWithoutStudentNestedInput
    relative?: relativeUpdateManyWithoutStudentNestedInput
    People?: PeopleUpdateOneRequiredWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutLiving_roomInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    Dormitory_Card?: Dormitory_CardUncheckedUpdateManyWithoutStudentNestedInput
    relative?: relativeUncheckedUpdateManyWithoutStudentNestedInput
    studentDiscipline?: studentDisciplineUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateManyWithoutLiving_roomInput = {
    Sssn?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    hasHealthInsurance?: BoolFieldUpdateOperationsInput | boolean
    studyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type manager_employeeCreateManyManagement_roomInput = {
    essn: string
    experience?: Decimal | DecimalJsLike | number | string | null
  }

  export type manager_employeeUpdateWithoutManagement_roomInput = {
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUpdateManyWithoutManager_employeeNestedInput
    manager_degree?: manager_degreeUpdateManyWithoutManager_employeeNestedInput
    employee?: employeeUpdateOneRequiredWithoutManager_employeeNestedInput
  }

  export type manager_employeeUncheckedUpdateWithoutManagement_roomInput = {
    essn?: StringFieldUpdateOperationsInput | string
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disciplineStaff?: disciplineStaffUncheckedUpdateManyWithoutManager_employeeNestedInput
    manager_degree?: manager_degreeUncheckedUpdateManyWithoutManager_employeeNestedInput
  }

  export type manager_employeeUncheckedUpdateManyWithoutManagement_roomInput = {
    essn?: StringFieldUpdateOperationsInput | string
    experience?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type disciplineStaffCreateManyManager_employeeInput = {
    actionId: string
  }

  export type manager_degreeCreateManyManager_employeeInput = {
    degree: string
  }

  export type disciplineStaffUpdateWithoutManager_employeeInput = {
    disciplinaryAction?: disciplinaryActionUpdateOneRequiredWithoutDisciplineStaffNestedInput
  }

  export type disciplineStaffUncheckedUpdateWithoutManager_employeeInput = {
    actionId?: StringFieldUpdateOperationsInput | string
  }

  export type disciplineStaffUncheckedUpdateManyWithoutManager_employeeInput = {
    actionId?: StringFieldUpdateOperationsInput | string
  }

  export type manager_degreeUpdateWithoutManager_employeeInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type manager_degreeUncheckedUpdateWithoutManager_employeeInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type manager_degreeUncheckedUpdateManyWithoutManager_employeeInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type medical_degreeCreateManyMedical_employeeInput = {
    degree: string
  }

  export type medical_degreeUpdateWithoutMedical_employeeInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type medical_degreeUncheckedUpdateWithoutMedical_employeeInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type medical_degreeUncheckedUpdateManyWithoutMedical_employeeInput = {
    degree?: StringFieldUpdateOperationsInput | string
  }

  export type other_employee_time_workCreateManyOther_employeeInput = {
    date_work: $Enums.other_employee_time_work_date_work
    time_start: Date | string
    time_end: Date | string
  }

  export type other_employee_time_workUpdateWithoutOther_employeeInput = {
    date_work?: Enumother_employee_time_work_date_workFieldUpdateOperationsInput | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFieldUpdateOperationsInput | Date | string
    time_end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_employee_time_workUncheckedUpdateWithoutOther_employeeInput = {
    date_work?: Enumother_employee_time_work_date_workFieldUpdateOperationsInput | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFieldUpdateOperationsInput | Date | string
    time_end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_employee_time_workUncheckedUpdateManyWithoutOther_employeeInput = {
    date_work?: Enumother_employee_time_work_date_workFieldUpdateOperationsInput | $Enums.other_employee_time_work_date_work
    time_start?: DateTimeFieldUpdateOperationsInput | Date | string
    time_end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type other_employeeCreateManyOther_roomInput = {
    essn: string
    typeWork?: string | null
  }

  export type other_employeeUpdateWithoutOther_roomInput = {
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: employeeUpdateOneRequiredWithoutOther_employeeNestedInput
    other_employee_time_work?: other_employee_time_workUpdateManyWithoutOther_employeeNestedInput
  }

  export type other_employeeUncheckedUpdateWithoutOther_roomInput = {
    essn?: StringFieldUpdateOperationsInput | string
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
    other_employee_time_work?: other_employee_time_workUncheckedUpdateManyWithoutOther_employeeNestedInput
  }

  export type other_employeeUncheckedUpdateManyWithoutOther_roomInput = {
    essn?: StringFieldUpdateOperationsInput | string
    typeWork?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Dormitory_CardCreateManyStudentInput = {
    Number: string
    Start_Date?: Date | string | null
    End_Date?: Date | string | null
    Validity?: boolean | null
  }

  export type relativeCreateManyStudentInput = {
    fname: string
    lname: string
    birthday: Date | string
    relationship: string
    address: string
    phoneNumber?: string | null
    job?: string | null
  }

  export type studentDisciplineCreateManyStudentInput = {
    actionId: string
  }

  export type Dormitory_CardUpdateWithoutStudentInput = {
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Identity_Card?: Identity_CardUpdateOneRequiredWithoutDormitory_CardNestedInput
  }

  export type Dormitory_CardUncheckedUpdateWithoutStudentInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type Dormitory_CardUncheckedUpdateManyWithoutStudentInput = {
    Number?: StringFieldUpdateOperationsInput | string
    Start_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    End_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Validity?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type relativeUpdateWithoutStudentInput = {
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type relativeUncheckedUpdateWithoutStudentInput = {
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type relativeUncheckedUpdateManyWithoutStudentInput = {
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentDisciplineUpdateWithoutStudentInput = {
    disciplinaryAction?: disciplinaryActionUpdateOneRequiredWithoutStudentDisciplineNestedInput
  }

  export type studentDisciplineUncheckedUpdateWithoutStudentInput = {
    actionId?: StringFieldUpdateOperationsInput | string
  }

  export type studentDisciplineUncheckedUpdateManyWithoutStudentInput = {
    actionId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}